<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Base64编码格式</title>
    <url>/2021/08/08/Base64%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="base64编码格式"><a href="#base64编码格式" class="headerlink" title="base64编码格式"></a>base64编码格式</h3><p><img src="https://cdn.jsdelivr.net/gh/yinlifan/img/20220808103513.png"></p>
<h4 id="什么是Base64"><a href="#什么是Base64" class="headerlink" title="什么是Base64"></a>什么是Base64</h4><p><strong>Base64</strong> 是一种基于 64 个可打印字符来表示二进制数据的表示方法。由于 2⁶ &#x3D; 64 ，所以每 6 个比特为一个单元，对应某个可打印字符。3 个字节有 24 个比特，对应于 4 个 base64 单元，即 3 个字节可由 4 个可打印字符来表示。</p>
<span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/yinlifan/img/20220808104350.png"></p>
<p><strong>Base64 常用于在处理文本数据的场合，表示、传输、存储一些二进制数据，包括 MIME 的电子邮件及 XML 的一些复杂数据。</strong>在 MIME 格式的电子邮件中，base64 可以用来将二进制的字节序列数据编码成 ASCII 字符序列构成的文本。使用时，在传输编码方式中指定 base64。使用的字符包括大小写拉丁字母各 26 个、数字 10 个、加号 + 和斜杠 &#x2F;，共 64 个字符，等号  &#x3D; 用来作为后缀用途。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yinlifan/img/20220808104501.png"></p>
<h4 id="为什么要使用-Base64"><a href="#为什么要使用-Base64" class="headerlink" title="为什么要使用 Base64"></a>为什么要使用 Base64</h4><p>我们知道一个字节可表示的范围是 0 ～ 255（十六进制：0x00 ～ 0xFF）， 其中 ASCII 值的范围为 0 ～ 127（十六进制：0x00 ～ 0x7F）；而超过 ASCII 范围的 128～255（十六进制：0x80 ～ 0xFF）之间的值是不可见字符。</p>
<blockquote>
<p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统。它主要用于显示现代英语，而其扩展版本延伸美国标准信息交换码则可以部分支持其他西欧语言，并等同于国际标准 ISO&#x2F;IEC 646。</p>
</blockquote>
<p>在 ASCII 码中 0 - 31和 127 是控制字符，共 33 个。以下是其中一部分控制字符：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yinlifan/img/20220808104806.png"></p>
<p>其余 95 个，即 32 - 126 是可打印字符，包括数字、大小写字母、常用符号等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yinlifan/img/20220808104951.png"></p>
<p><strong>当不可见字符在网络上传输时，比如说从 A 计算机传到 B 计算机，往往要经过多个路由设备，由于不同的设备对字符的处理方式有一些不同，这样那些不可见字符就有可能被处理错误，这是不利于传输的。</strong> 为了解决这个问题，我们可以先对数据进行编码，比如 base64 编码，变成可见字符，也就是 ASCII 码可表示的可见字符，从而确保数据可靠传输。Base64 的内容是有 0 ～ 9，a ～ z，A ～ Z，+，&#x2F; 组成，正好 64 个字符，这些字符是在 ASCII 可表示的范围内，属于 95 个可见字符的一部分。</p>
<p><strong>总结一句话：base64编码的初衷是应用在文件传输中，主要是为了将ascii编码的不可字符转换为可见字符。</strong></p>
<h4 id="base64进阶"><a href="#base64进阶" class="headerlink" title="base64进阶"></a>base64进阶</h4><h5 id="1、基础数据转换为二进制"><a href="#1、基础数据转换为二进制" class="headerlink" title="1、基础数据转换为二进制"></a>1、基础数据转换为二进制</h5><p><a style='color: blue' href='https://www.rapidtables.org/zh-CN/convert/number/ascii-to-binary.html'>文本到二进制转换器</a></p>
<p>举例：</p>
<p><strong>文本：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">我是周正</span><br></pre></td></tr></table></figure>

<p><strong>二进制：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">11100110</span> <span class="number">10001000</span> <span class="number">10010001</span> <span class="number">11100110</span> <span class="number">10011000</span> <span class="number">10101111</span> </span><br><span class="line"><span class="number">11100101</span> <span class="number">10010001</span> <span class="number">10101000</span> <span class="number">11100110</span> <span class="number">10101101</span> <span class="number">10100011</span></span><br></pre></td></tr></table></figure>

<h5 id="2、对二进制数据按6位切割"><a href="#2、对二进制数据按6位切割" class="headerlink" title="2、对二进制数据按6位切割"></a>2、对二进制数据按6位切割</h5><p>首先以6bit为单位进行分隔,并给每个片段头部进行2bit补位 “00”：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 11100110 10001000 10010001 11100110 10011000 10101111 11100101 10010001 10101000 11100110 10101101 10100011</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cutInPiceBin</span>(<span class="params">list = [], size</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cutTimes = list.<span class="property">length</span> / size; <span class="comment">// 需要切割的次数</span></span><br><span class="line">    <span class="keyword">let</span> piceQuene = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cutTimes; i++) &#123;</span><br><span class="line">        piceQuene.<span class="title function_">unshift</span>(list.<span class="title function_">splice</span>(size * -<span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(piceQuene.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="string">`00<span class="subst">$&#123;item&#125;</span>`</span>));</span><br><span class="line">    <span class="keyword">return</span> piceQuene.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="string">`00<span class="subst">$&#123;item&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cutInPiceBin</span>(<span class="string">&#x27;11100110 10001000 10010001 11100110 10011000 10101111 11100101 10010001 10101000 11100110 10101101 10100011&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/\s+/g</span>, <span class="string">&quot;&quot;</span>).<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>), <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>处理后的数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">&#x27;00111001&#x27;</span>, <span class="string">&#x27;00101000&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;00100010&#x27;</span>, <span class="string">&#x27;00010001&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;00111001&#x27;</span>, <span class="string">&#x27;00101001&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;00100010&#x27;</span>, <span class="string">&#x27;00101111&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;00111001&#x27;</span>, <span class="string">&#x27;00011001&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;00000110&#x27;</span>, <span class="string">&#x27;00101000&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;00111001&#x27;</span>, <span class="string">&#x27;00101010&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;00110110&#x27;</span>, <span class="string">&#x27;00100011&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><a style="color: rgb(232, 50, 60);">现在我们发现数据的长度由原来的12*8 bit变为了 16 *8 bit。</a></p>
<h5 id="3、按照映射表进行编码"><a href="#3、按照映射表进行编码" class="headerlink" title="3、按照映射表进行编码"></a>3、按照映射表进行编码</h5><p>首先转换为10进制表示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> binBase64 = <span class="title function_">cutInPiceBin</span>(<span class="string">&#x27;11100110 10001000 10010001 11100110 10011000 10101111 11100101 10010001 10101000 11100110 10101101 10100011&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/\s+/g</span>, <span class="string">&quot;&quot;</span>).<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>), <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decBase64 = binBase64.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">parseInt</span>(item, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;decBase64&#x27;</span>, decBase64);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="number">57</span>, <span class="number">40</span>, <span class="number">34</span>, <span class="number">17</span>, <span class="number">57</span>, <span class="number">41</span>,</span><br><span class="line">  <span class="number">34</span>, <span class="number">47</span>, <span class="number">57</span>, <span class="number">25</span>,  <span class="number">6</span>, <span class="number">40</span>,</span><br><span class="line">  <span class="number">57</span>, <span class="number">42</span>, <span class="number">54</span>, <span class="number">35</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>按照映射表进行编码:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">5oiR5piv5ZGo5q2j</span><br></pre></td></tr></table></figure>

<h5 id="4、验证一下"><a href="#4、验证一下" class="headerlink" title="4、验证一下"></a>4、验证一下</h5><p><a style='color:blue' href='https://base64.us/'>Base64 在线编码解码 | Base64 加密解密 - Base64.us</a></p>
<h3 id="Base64在前端中应用"><a href="#Base64在前端中应用" class="headerlink" title="Base64在前端中应用"></a>Base64在前端中应用</h3><blockquote>
<p>在前端中最常见的使用Base64来处理图片—将图片的url替换成Base64格式的dataUrl。</p>
</blockquote>
<h4 id="什么是-Data-URL"><a href="#什么是-Data-URL" class="headerlink" title="什么是 Data URL"></a>什么是 Data URL</h4><blockquote>
<p><a href="http://en.wikipedia.org/wiki/Data_URL">Data URL</a>给了我们一种很巧妙的将图片“嵌入”到HTML中的方法。跟传统的用<code>img</code>标记将服务器上的图片引用到页面中的方式不一样，在Data URL协议中，图片被转换成<a href="http://en.wikipedia.org/wiki/Base64">base64</a>编码的字符串形式，并存储在URL中，冠以mime-type。本文中，我将介绍如何巧妙的使用Data URL优化网站加载速度和执行效率</p>
</blockquote>
<p>图片在网页中的使用方法通常是下面这种利用<code>img</code>标记的形式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/myimage.gif &quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种方式中，<code>img</code>标记的<code>src</code>属性指定了一个远程服务器上的资源。当网页加载到浏览器中时，浏览器会针对每个外部资源都向服务器发送一次拉取资源请求，占用网络资源。大多数的浏览器都有一个并发请求数不能超过4个的限制。这意味着，如果一个网页里嵌入了过多的外部资源，这些请求会导致整个页面的加载延迟。而使用Data URL技术，图片数据以base64字符串格式嵌入到了页面中，与HTML成为一体，它的形式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;data:image/gif;base64,R0lGODlhMwAxAIAAAAAAAP///</span></span></span><br><span class="line"><span class="string"><span class="tag">yH5BAAAAAAALAAAAAAzADEAAAK8jI+pBr0PowytzotTtbm/DTqQ6C3hGX</span></span></span><br><span class="line"><span class="string"><span class="tag">ElcraA9jIr66ozVpM3nseUvYP1UEHF0FUUHkNJxhLZfEJNvol06tzwrgd</span></span></span><br><span class="line"><span class="string"><span class="tag">LbXsFZYmSMPnHLB+zNJFbq15+SOf50+6rG7lKOjwV1ibGdhHYRVYVJ9Wn</span></span></span><br><span class="line"><span class="string"><span class="tag">k2HWtLdIWMSH9lfyODZoZTb4xdnpxQSEF9oyOWIqp6gaI9pI1Qo7BijbF</span></span></span><br><span class="line"><span class="string"><span class="tag">ZkoaAtEeiiLeKn72xM7vMZofJy8zJys2UxsCT3kO229LH1tXAAAOw==&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从上面的base64字符串中你看不出任何跟图片相关的东西，但下面，我们将传统的<code>img</code>写法和现在的Data URL用法左右对比显示，你就能看出它们是完全一样的效果。但实际上它们是不一样的，它们一个是引用了外部资源，一个是使用了Data URL。</p>
<h6 id="简单来说url大概分为两种"><a href="#简单来说url大概分为两种" class="headerlink" title="简单来说url大概分为两种"></a>简单来说url大概分为两种</h6><ul>
<li>普通URL（每个URL指向服务器的一个资源，需要发请求获取该资源）</li>
<li>Data URL(<span style="color: rgb(245, 34, 45);">即前缀为 data: 协议的 URL，其允许内容创建者向文档中嵌入小文件，不进行资源请求</span>)</li>
</ul>
<h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><p>Data URLs 由四个部分组成：前缀 (data:)、指示数据类型的 MIME 类型、如果非文本则为可选的base64标记、数据本身：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>:[&lt;mediatype&gt;][;base64],&lt;data&gt; </span><br></pre></td></tr></table></figure>



<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><p><strong>提升性能：</strong> 网页上的每一个图片，都是需要消耗一个 http 请求下载而来的, 图片的下载始终都要向服务器发出请求，要是图片的下载不用向服务器发出请求，base64可以随着 HTML 的下载同时下载到本地.减少https请求。 </p>
</li>
<li><p><strong>加密：</strong> 让用户一眼看不出图片内容 , 只能看到编码。 </p>
</li>
<li><p><strong>方便引用：</strong>: 在多个文件同时使用某些图片时, 可以把图片转为base64格式的文件, 把样式放在全局中, 比如common.css, 以后在用的时候就可以直接加类名, 二不需要多层找文件路径, 会提升效率。</p>
</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>Base64转换的缺点是显而易见的：<span style='color: red;'>编码后体积增大</span></p>
<p>前面我们转化的例子可以看出，转化后又12<em>8bit变为了16</em>8 bit。</p>
<p>基本转换关系为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">preBit * <span class="number">8</span> = afterBit * <span class="number">6</span></span><br><span class="line"></span><br><span class="line">- <span class="attr">preBit</span>:   转化前的体积</span><br><span class="line">- <span class="attr">afterBit</span>: 转化后的体积</span><br></pre></td></tr></table></figure>

<p>体积增大了 1&#x2F;3,因为base64只是个编码一些小文本，不适合大文本编码（如视频）。</p>
]]></content>
      <categories>
        <category>Base64</category>
      </categories>
      <tags>
        <tag>Base64</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>ES5,ES6和ES2015</title>
    <url>/2019/02/20/ES5-ES6%E5%92%8CES2015/</url>
    <content><![CDATA[<h4 id="ES5，ES6和ES2015有什么区别？"><a href="#ES5，ES6和ES2015有什么区别？" class="headerlink" title="ES5，ES6和ES2015有什么区别？"></a>ES5，ES6和ES2015有什么区别？</h4><p>Es2015是指2015年发布的新一代js语言标准，es6泛指下一代js语言标准，包含了es2015，es2016，es2017，es2018等。现阶段在绝大部分场景下，es2015默认等同es6。es5泛指上一代语言标准。es2015可以理解为ES5和ES6的时间分解线。</p>
<h4 id="babel是什么，有什么作用？"><a href="#babel是什么，有什么作用？" class="headerlink" title="babel是什么，有什么作用？"></a>babel是什么，有什么作用？</h4><p>babel是一个es6的转换器，可以将es6代码转为es5代码，以便兼容那些还没支持es6的平台。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6对象新增扩展</title>
    <url>/2018/07/30/ES6%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h4 id="ES6对象新增扩展"><a href="#ES6对象新增扩展" class="headerlink" title="ES6对象新增扩展"></a>ES6对象新增扩展</h4><h5 id="属性的简写"><a href="#属性的简写" class="headerlink" title="属性的简写"></a>属性的简写</h5><ul>
<li><p>ES6中，当对象键名与对应值名相等的时候，可以进行简写 。 方法也能够进行简写 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>:foo&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;foo&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在函数内作为返回值，也会变得方便很多</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPoint</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getPoint</span>()</span><br><span class="line"><span class="comment">// &#123;x:1, y:10&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>

<ul>
<li><p>注意：简写的对象方法不能用作构造函数，否则会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">f</span>() <span class="comment">// 报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h5><ul>
<li><p>ES6 允许字面量定义对象时，将表达式放在括号内 , 表达式还可以用于定义方法名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lastWord = <span class="string">&#x27;last word&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="string">&#x27;first word&#x27;</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  [lastWord]: <span class="string">&#x27;world&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;first word&#x27;</span>] <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">a[lastWord] <span class="comment">// &quot;world&quot;</span></span><br><span class="line">a[<span class="string">&#x27;last word&#x27;</span>] <span class="comment">// &quot;world&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="string">&#x27;h&#x27;</span> + <span class="string">&#x27;ello&#x27;</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">hello</span>() <span class="comment">// hi</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h5><ul>
<li><p><code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">  <span class="title function_">find</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="property">foo</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, proto); <span class="comment">// 为obj设置原型对象</span></span><br><span class="line">obj.<span class="title function_">find</span>() <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h5><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<ul>
<li>for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</li>
<li>Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名</li>
<li>Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名</li>
<li>Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名</li>
<li>Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举</li>
</ul>
<p>上述遍历，都遵守同样的属性遍历的次序规则：</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列</li>
<li>其次遍历所有字符串键，按照加入时间升序排列</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排</li>
</ul>
<h5 id="对象新增的方法"><a href="#对象新增的方法" class="headerlink" title="对象新增的方法"></a>对象新增的方法</h5><ul>
<li>Object.is()</li>
<li>Object.assign()</li>
<li>Object.getOwnPropertyDescriptors()</li>
<li>Object.setPrototypeOf()，Object.getPrototypeOf()</li>
<li>Object.keys()，Object.values()，Object.entries()</li>
<li>Object.fromEntries()</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6数组新增扩展</title>
    <url>/2018/07/29/ES6%E6%95%B0%E7%BB%84%E6%96%B0%E5%A2%9E%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h4 id="ES6数组新增扩展"><a href="#ES6数组新增扩展" class="headerlink" title="ES6数组新增扩展"></a>ES6数组新增扩展</h4><h5 id="扩展运算符的引用"><a href="#扩展运算符的引用" class="headerlink" title="扩展运算符的引用 ..."></a>扩展运算符的引用 <code>...</code></h5><ul>
<li><p>主要用于函数调用，将一个数组变为参数序列。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">array, ...items</span>) &#123;</span><br><span class="line">  array.<span class="title function_">push</span>(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line"><span class="title function_">add</span>(...numbers) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>能够更简单的实现数组复制。也可进行数组合并。可以将字符串转化为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组复制</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br><span class="line"><span class="comment">// [1,2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组合并</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"></span><br><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]	</span></span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>
<p>注意：</p>
<ul>
<li><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="构造函数新增的方法"><a href="#构造函数新增的方法" class="headerlink" title="构造函数新增的方法"></a>构造函数新增的方法</h5><ul>
<li><p>Array.from()</p>
<ul>
<li>将两类对象转为真正的数组：类似数组的对象和可遍历<code>（iterable）</code>的对象（包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x)</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Array.of()</p>
<ul>
<li>用于将一组值，转换为数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>没有参数的时候，返回一个空数组</p>
<p>当参数只有一个的时候，实际上是指定数组的长度</p>
<p>参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="实例对象新增的方法"><a href="#实例对象新增的方法" class="headerlink" title="实例对象新增的方法"></a>实例对象新增的方法</h5><p>关于数组实例对象新增的方法有如下：</p>
<ul>
<li><p>copyWithin( )</p>
</li>
<li><p>find( )、findIndex( )</p>
<ul>
<li><code>find()</code>用于找出第一个符合条件的数组成员 参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>findIndex</code>返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].<span class="title function_">findIndex</span>(<span class="keyword">function</span>(<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>fill( )</p>
<ul>
<li>使用给定值，填充一个数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">fill</span>(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>entries( )，keys( )，values( )</p>
<ul>
<li><code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>includes( )</p>
<ul>
<li>用于判断数组是否包含给定的值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="title class_">NaN</span>].<span class="title function_">includes</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>方法的第二个参数表示搜索的起始位置，默认为<code>0</code> 参数为负数则表示倒数的位置</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">3</span>, <span class="number">3</span>);  <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">3</span>, -<span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>flat( )，flatMap( )</p>
<ul>
<li>将数组扁平化处理，返回一个新数组，对原数据没有影响</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].<span class="title function_">flat</span>()</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].<span class="title function_">flat</span>()</span><br><span class="line"><span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].<span class="title function_">flat</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>flatMap()</code>方法对原数组的每个成员执行一个函数相当于执行<code>Array.prototype.map()</code>，然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">flatMap</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr>
<blockquote>
<ul>
<li><a href="https://es6.ruanyifeng.com/#docs/array">https://es6.ruanyifeng.com/#docs/array</a></li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Generator</title>
    <url>/2021/09/11/Generator/</url>
    <content><![CDATA[<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>Generator 函数是ES6引入的，主要作用是用于异步编程。</p>
<p>​                   <span style="color:red"> 最大特点是可以交出函数的执行权（即暂停执行）。–通过 yield 来暂停</span></p>
<p><strong>它和普通函数写法不太一样，主要有两个不同:</strong></p>
<p>1.函数关键字与函数名之间有一个 * 号，以示与普通函数的区别。</p>
<p>2.Generator函数体内部使用 yield 语句，可以定义不同的内部状态。</p>
<p>   状态即数据，（内部的状态，即函数内部的值，它不同的时候是不一样的。）</p>
<p><span style="color:red;">本质上，Generator就是一个封装的异步任务，或者说是异步任务的容器。</span></p>
<h4 id="yield（读音：you-de）"><a href="#yield（读音：you-de）" class="headerlink" title="yield（读音：you de）"></a>yield（读音：you de）</h4><p>只存在于Generator函数内</p>
<p>yield 是异步不同阶段的分界线，所以有时也会把 yield 当成是 return。（当然，yield和return有本质的不同，return函数就结束运行了）</p>
<p><strong>例子：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个Generator函数</span></span><br><span class="line"><span class="keyword">function</span>* fn () &#123;</span><br><span class="line">  <span class="keyword">yield</span> a;</span><br><span class="line">  <span class="keyword">yield</span> b;</span><br><span class="line">  <span class="keyword">yield</span> c;</span><br><span class="line"><span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="title function_">fn</span>()</span><br><span class="line"><span class="keyword">var</span> resfn.<span class="title function_">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">让它启动起来，我们需要使用 .next() 方法</span></span><br><span class="line"><span class="comment">可以理解为一个启动方法</span></span><br><span class="line"><span class="comment">作用是分阶段执行Generator函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">每次调用.next() 方法，都会返回一个对象，表示当前阶段的信息（value, done）</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">value: ,（返回的值）</span></span><br><span class="line"><span class="comment">done: true表示函数已经执行完，false表示函数还没执行完</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>


<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个Generator函数</span></span><br><span class="line"><span class="keyword">function</span>* fn () &#123;</span><br><span class="line">  <span class="keyword">yield</span> a;</span><br><span class="line">  <span class="keyword">yield</span> b;</span><br><span class="line">  <span class="keyword">yield</span> c;</span><br><span class="line"><span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="title function_">fn</span>()</span><br><span class="line"><span class="keyword">var</span> res = fn.<span class="title function_">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时候，我们说 fn 它是一个迭代器的引用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个Generator函数</span></span><br><span class="line"><span class="keyword">function</span>* fn () &#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> ++n;</span><br><span class="line">  <span class="keyword">yield</span> ++n;</span><br><span class="line">  <span class="keyword">yield</span> ++n;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这是声明了两个迭代器</span></span><br><span class="line"><span class="keyword">var</span> aa = <span class="title function_">fn</span>()</span><br><span class="line"><span class="keyword">var</span> bb = <span class="title function_">fn</span>()  <span class="comment">//aa,bb这是两个内存指针</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aa.<span class="title function_">next</span>())  <span class="comment">//2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aa.<span class="title function_">next</span>())  <span class="comment">//3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bb.<span class="title function_">next</span>())  <span class="comment">//2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aa.<span class="title function_">next</span>())  <span class="comment">//4</span></span><br><span class="line"><span class="comment">// 每个迭代器之间是相互独立的，作用域独立</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">每当你调用了迭代器内部的.next()方法，Generator函数内部的指针就从上一次停下来的地方继续运行，直到遇到下一个yield</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="next-传参"><a href="#next-传参" class="headerlink" title=".next()传参"></a>.next()传参</h4><p>.next()方法可以接收参数</p>
<ul>
<li>传入的参数，其实是把上一个yield语句返回的值给覆盖了</li>
<li>第一个使用的.next()方法其实是启动器，在它之前是没有yield的，所以给第一个.next()传参是没有意义的</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* fn () &#123;</span><br><span class="line">  <span class="keyword">var</span> _n = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> _m = <span class="keyword">yield</span> _n + <span class="number">22</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;aa--:&#x27;</span> + _m)</span><br><span class="line">  <span class="keyword">yield</span> ++n</span><br><span class="line">  <span class="keyword">yield</span> ++n</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _fn = <span class="title function_">fn</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(_fn.<span class="title function_">next</span>()) <span class="comment">// 23</span></span><br><span class="line"></span><br><span class="line">_fn.<span class="title function_">next</span>(<span class="string">&#x27;abc&#x27;</span>)   <span class="comment">// aa--:abc</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(_fn.<span class="title function_">next</span>()) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>



<h4 id="For-of-循环"><a href="#For-of-循环" class="headerlink" title="For  of  循环"></a>For  of  循环</h4><p>generator函数支持 for of 循环,用来迭代Generator函数执行时生成的那个迭代对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* fn () &#123;</span><br><span class="line">  <span class="keyword">yield</span> a;</span><br><span class="line">  <span class="keyword">yield</span> b;</span><br><span class="line">  <span class="keyword">yield</span> c;</span><br><span class="line"><span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> _fn = <span class="title function_">fn</span>()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> _fn)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)     <span class="comment">// a b c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title>JS手写代码</title>
    <url>/2020/03/18/JS%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h3 id="JS手写代码"><a href="#JS手写代码" class="headerlink" title="JS手写代码"></a>JS手写代码</h3><h4 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h4><blockquote>
<p>函数防抖是指在事件被<span style='color: red'>触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时</span>。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数防抖的实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="variable language_">this</span>,</span><br><span class="line">        args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器，使事件间隔指定事件后执行</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h4><blockquote>
<p>函数节流是指规定一个单位时间，<span style='color: red'>在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效</span>。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数节流的实现;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="variable language_">this</span>,</span><br><span class="line">        args = <span class="variable language_">arguments</span>,</span><br><span class="line">        nowTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span></span><br><span class="line">    <span class="keyword">if</span> (nowTime - curTime &gt;= delay) &#123;</span><br><span class="line">      curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现AJAX请求"><a href="#实现AJAX请求" class="headerlink" title="实现AJAX请求"></a>实现AJAX请求</h4><blockquote>
<p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p>
</blockquote>
<p>创建AJAX请求的步骤：</p>
<ul>
<li><strong>创建一个 XMLHttpRequest 对象。</strong></li>
<li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li>
<li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li>
<li>当对象的属性和监听函数设置完成后，最后调<strong>用 send 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">SERVER_URL</span> = <span class="string">&quot;/server&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"><span class="comment">// 创建 Http 请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="variable constant_">SERVER_URL</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置状态监听函数</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 当请求成功时</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="title function_">handle</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求头信息</span></span><br><span class="line">xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"><span class="comment">// 发送 Http 请求</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h4 id="使用Promise封装AJAX请求"><a href="#使用Promise封装AJAX请求" class="headerlink" title="使用Promise封装AJAX请求"></a>使用Promise封装AJAX请求</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise 封装实现：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="comment">// 新建一个 http 请求</span></span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 设置状态的监听函数</span></span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 当请求成功或失败时，改变 promise 的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置错误监听函数</span></span><br><span class="line">    xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置响应的数据类型</span></span><br><span class="line">    xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    <span class="comment">// 设置请求头信息</span></span><br><span class="line">    xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    <span class="comment">// 发送 http 请求</span></span><br><span class="line">    xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现浅拷贝"><a href="#实现浅拷贝" class="headerlink" title="实现浅拷贝"></a>实现浅拷贝</h4><blockquote>
<p>浅拷贝是指，一个新的对象对原始对象的属性值进行精确地拷贝，<span style='color:red'>如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址</span>。如果其中一个对象的引用内存地址发生改变，另一个对象也会发生变化。</p>
</blockquote>
<h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h5><p><code>Object.assign()</code>是ES6中对象的拷贝方法，接受的第一个参数是目标对象，其余参数是源对象，用法：<code>Object.assign(target, source_1, ···)</code>，该方法可以实现浅拷贝，也可以实现一维对象的深拷贝。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。</li>
<li>如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。</li>
<li>因为<code>null</code> 和 <code>undefined</code> 不能转化为对象，所以第一个参数不能为<code>null</code>或 <code>undefined</code>，会报错。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object2 = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> object3 = &#123;<span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target,object2,object3);  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target);  <span class="comment">// &#123;a: 1, b: 2, c: 3&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h5><p>使用扩展运算符可以在构造字面量对象的时候，进行属性的拷贝。语法：<code>let cloneObj = &#123; ...obj &#125;;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:&#123;<span class="attr">c</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;...obj1&#125;;</span><br><span class="line">obj1.<span class="property">a</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1); <span class="comment">//&#123;a:2,b:&#123;c:1&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">//&#123;a:1,b:&#123;c:1&#125;&#125;</span></span><br><span class="line">obj1.<span class="property">b</span>.<span class="property">c</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1); <span class="comment">//&#123;a:2,b:&#123;c:2&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">//&#123;a:1,b:&#123;c:2&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="数组方法实现数组浅拷贝"><a href="#数组方法实现数组浅拷贝" class="headerlink" title="数组方法实现数组浅拷贝"></a>数组方法实现数组浅拷贝</h5><h6 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice"></a><strong>Array.prototype.slice</strong></h6><ul>
<li><code>slice()</code>方法是JavaScript数组的一个方法，这个方法可以从已有数组中返回选定的元素：用法：<code>array.slice(start, end)</code>，该方法不会改变原始数组。</li>
<li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">slice</span>()); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">slice</span>() === arr); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h6 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat"></a><strong>Array.prototype.concat</strong></h6><ul>
<li><code>concat()</code> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</li>
<li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">concat</span>()); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">concat</span>() === arr); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h5 id="手写实现浅拷贝"><a href="#手写实现浅拷贝" class="headerlink" title="手写实现浅拷贝"></a>手写实现浅拷贝</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;<span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;<span class="comment">// 浅拷贝的实现;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h4><blockquote>
<p>深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。</p>
</blockquote>
<h5 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h5><p><code>JSON.parse(JSON.stringify(obj))</code>是目前比较常用的深拷贝方法之一，它的原理就是利用<code>JSON.stringify</code> 将<code>js</code>对象序列化（JSON字符串），再使用<code>JSON.parse</code>来反序列化(还原)<code>js</code>对象。</p>
<p>这个方法可以简单粗暴的实现深拷贝，但是还存在问题，拷贝的对象中如果有函数，undefined，symbol，当使用过<code>JSON.stringify()</code>进行处理之后，都会消失。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;  </span><br><span class="line">    <span class="attr">a</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">       <span class="attr">c</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj1));</span><br><span class="line">obj1.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">obj1.<span class="property">b</span>.<span class="property">c</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1); <span class="comment">// &#123;a: 1, b: &#123;c: 1&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123;a: 0, b: &#123;c: 0&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="函数库lodash的-cloneDeep方法"><a href="#函数库lodash的-cloneDeep方法" class="headerlink" title="函数库lodash的_.cloneDeep方法"></a>函数库lodash的_.cloneDeep方法</h5><p>该函数库也有提供_.cloneDeep用来做 Deep Copy</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = _.<span class="title function_">cloneDeep</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">f</span> === obj2.<span class="property">b</span>.<span class="property">f</span>);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h5 id="手写实现深拷贝函数"><a href="#手写实现深拷贝函数" class="headerlink" title="手写实现深拷贝函数"></a>手写实现深拷贝函数</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深拷贝的实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">object</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      newObject[key] =</span><br><span class="line">        <span class="keyword">typeof</span> object[key] === <span class="string">&quot;object&quot;</span> ? <span class="title function_">deepCopy</span>(object[key]) : object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="手写-new-操作符"><a href="#手写-new-操作符" class="headerlink" title="手写 new 操作符"></a>手写 new 操作符</h4><p>在调用 <code>new</code> 的过程中会发生以上四件事情：</p>
<p>（1）首先创建了一个新的空对象</p>
<p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p>
<p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p>
<p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectFactory</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> constructor = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断参数是否是一个函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> constructor !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 将 this 指向新建对象，并执行函数</span></span><br><span class="line">  result = constructor.<span class="title function_">apply</span>(newObject, <span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 判断返回对象</span></span><br><span class="line">  <span class="keyword">let</span> flag = result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line">  <span class="comment">// 判断返回结果</span></span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="title function_">objectFactory</span>(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Options请求</title>
    <url>/2020/08/02/Options%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h3 id="Options请求-跨域预检"><a href="#Options请求-跨域预检" class="headerlink" title="Options请求(跨域预检)"></a>Options请求(跨域预检)</h3><h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><blockquote>
<p>options 请求就是预检请求，可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 OPTIONS 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。</p>
</blockquote>
<h4 id="什么是-options-请求"><a href="#什么是-options-请求" class="headerlink" title="什么是 options 请求"></a>什么是 options 请求</h4><p>HTTP 的 <strong>OPTIONS</strong> 方法 用于获取目的资源所支持的通信选项。客户端可以对特定的 URL 使用 OPTIONS 方法，也可以对整站（通过将 URL 设置为”*”）使用该方法。(简而言之，就是可以用 options 请求去嗅探某个请求在对应的服务器中都支持哪种请求方法)。</p>
<p><span style="color: red;"><strong>原因</strong></span></p>
<p>这是因为在跨域的情况下，在浏览器发起”复杂请求”时主动发起的。跨域共享标准规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。</p>
<span id="more"></span>
<h4 id="简单请求和复杂请求"><a href="#简单请求和复杂请求" class="headerlink" title="简单请求和复杂请求"></a>简单请求和复杂请求</h4><blockquote>
<p>某些请求不会触发CORS预检请求，这样的请求一般称为 <strong>“简单请求”</strong> ，而会触发预检的请求则是 <strong>“复杂请求”</strong> 。</p>
</blockquote>
<h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><ul>
<li>请求方式为<code>GET、HEAD、POST</code>时的请求；</li>
<li>认为设置规范集合之内的首部字段，如<code>Accept/Accept-Language/Content-Language/Content-Type/DPR/Downlink/Save-Data/Viewport-Width/Width</code>;</li>
<li>Content-Type 的值仅限于下列三者之一,即<code>application/x-www-form-urlencoded、multipart/form-data、text/plain</code>；</li>
<li>请求中的任意 <code>XMLHttpRequestUpload</code>对象均没有注册任何事件监听器；</li>
<li>请求中没有使用 <code>ReadableStream</code>对象。</li>
</ul>
<h5 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h5><ul>
<li>PUT&#x2F;DELETE&#x2F;CONNECT&#x2F;OPTIONS&#x2F;TRACE&#x2F;PATCH;</li>
<li>人为设置了以下集合之外首部字段，即简单请求外的字段;</li>
<li>Content-Type 的值不属于下列之一，即application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain。</li>
</ul>
<h4 id="Option关键字段"><a href="#Option关键字段" class="headerlink" title="Option关键字段"></a>Option关键字段</h4><p><span style='color: red'>request header 的关键字段</span></p>
<table>
<thead>
<tr>
<th>关键字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Access-Control-Request-Method</td>
<td>告知服务器，实际请求将使用POST方法</td>
</tr>
<tr>
<td>Access-Control-Request-Headers</td>
<td>告知服务器，实际请求将携带的自定义请求首部字段</td>
</tr>
</tbody></table>
<p><span style='color: red'>response header 的关键字段</span></p>
<table>
<thead>
<tr>
<th>关键字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Access-Control-Allow-Methods</td>
<td>表明服务器允许客户端使用什么方法发起请求</td>
</tr>
<tr>
<td>Access-Control-Allow-Origin</td>
<td>允许跨域请求的域名，如果要允许所有域名则设置为*</td>
</tr>
<tr>
<td>Access-Control-Allow-Headers</td>
<td>将实际请求所携带的首部字段告诉服务器</td>
</tr>
<tr>
<td>Access-Control-Max-Age</td>
<td>指定了预检请求的结果能够被缓存多久</td>
</tr>
</tbody></table>
<h4 id="Options-请求优化"><a href="#Options-请求优化" class="headerlink" title="Options 请求优化"></a>Options 请求优化</h4><blockquote>
<p>当发起跨域请求时，简单请求只发起一次请求；复杂请求则需要2次，先发起options请求，确认目标资源是否支持跨域，浏览器会根据服务端响应的header自动处理剩余的请求，如果响应支持跨域，则继续发出正常请求；不支持的话，会在控制台显示错误。<br>所以，当触发预检时，跨域请求便会发送2次请求，增加请求次数，同时，也延迟了请求真正发起的时间，会严重地影响性能。</p>
</blockquote>
<h4 id="优化options请求的两种方法"><a href="#优化options请求的两种方法" class="headerlink" title="优化options请求的两种方法"></a>优化options请求的两种方法</h4><p><span style='color: red'>方法一</span></p>
<ul>
<li>用其它的跨域方式做跨域请求，将复杂请求转为简单请求，比如JSONP等；</li>
</ul>
<p><span style='color: red'>方法二</span></p>
<ul>
<li>服务器端设置 <code>Access-Control-Max-Age</code> 字段，那么当第一次请求该 URL 时会发出<code>OPTIONS</code>请求，浏览器会根据返回的 Access-Control-Max-Age 字段缓存该请求的 OPTIONS 预检请求的响应结果（具体缓存时间还取决于浏览器的支持的默认最大值，取两者最小值，一般为 10 分钟）。在缓存有效期内，该资源的请求（URL 和 header 字段都相同的情况下）不会再触发预检。（chrome 打开控制台可以看到，当服务器响应 Access-Control-Max-Age 时只有第一次请求会有预检，后面不会了。注意要开启缓存，去掉 disable cache 勾选。）</li>
</ul>
]]></content>
      <categories>
        <category>网络通讯</category>
      </categories>
      <tags>
        <tag>网络通讯</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2020/10/11/Promise/</url>
    <content><![CDATA[<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>为了解决回调地狱的</p>
<ul>
<li>在回调函数中嵌套回调</li>
</ul>
<h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h4><p>promise是一个构造函数，通过 new 关键字实例化对象</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>Promise 接受一个函数作为参数</li>
<li>在函数中接收两个参数<ul>
<li>resolve</li>
<li>reject</li>
</ul>
</li>
</ul>
<p>Promise 实例有两个属性</p>
<ul>
<li>state：状态</li>
<li>result：结果</li>
</ul>
<h5 id="promise的状态"><a href="#promise的状态" class="headerlink" title="promise的状态"></a>promise的状态</h5><p>第一种状态：pending(准备，待解决，进行中)</p>
<p>第二种状态：fulfiled（成功，已完成）</p>
<p>第三种状态：rejected（失败，已拒绝）</p>
<span id="more"></span>

<h5 id="promise的状态的改变"><a href="#promise的状态的改变" class="headerlink" title="promise的状态的改变"></a>promise的状态的改变</h5><p>通过调用resolve（）和reject（）改变当前promise对象的状态</p>
<p>调用resolve（）,使当前promise对象的状态变成fulfilled</p>
<p>调用reject（）,使当前promise对象的状态变成rejected</p>
<p><strong>promise的状态改变是一次性的</strong></p>
<h5 id="promise的结果"><a href="#promise的结果" class="headerlink" title="promise的结果"></a>promise的结果</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;成功的结果&#x27;</span>)</span><br><span class="line">  <span class="comment">// reject(&#x27;失败的结果&#x27;)</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(p)</span><br></pre></td></tr></table></figure>

<ul>
<li>通过调用resolve，传递参数，改变当前 promise对像的结果</li>
</ul>
<h4 id="2-Promise-的方法"><a href="#2-Promise-的方法" class="headerlink" title="2.Promise 的方法"></a>2.Promise 的方法</h4><h5 id="then"><a href="#then" class="headerlink" title=".then"></a>.then</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;成功的结果&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功时调用&#x27;</span>,res)  <span class="comment">// 成功的结果</span></span><br><span class="line">&#125;， () =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败时调用&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>then 方法接收两个函数作为参数，</p>
</li>
<li><p>第一个在promise状态是fulfilled的时候执行，</p>
</li>
<li><p>第二个在状态是rejected的时候执行</p>
</li>
<li><p>方法的返回值是一个promise对象</p>
</li>
<li><p>then中函数接收形参，返回相对应的结果</p>
</li>
</ul>
<h5 id="then的返回值"><a href="#then的返回值" class="headerlink" title="then的返回值"></a>then的返回值</h5><ul>
<li><p>then方法返回一个新的promise实例，状态是pending </p>
<p>&#x3D;&#x3D;&gt;可以进行链式操作</p>
</li>
<li><p>promise的状态不改变，不会执行then方法</p>
<p>&#x3D;&#x3D;&gt; 解决方法：</p>
<p>   &#x3D;&#x3D;&gt; <strong>在then中函数中 return 即可</strong>（这时状态被改为fulfilled）</p>
<p>   &#x3D;&#x3D;&gt; 如果函数中执行的代码出错 ，实例的状态就会变成 rejected</p>
</li>
</ul>
<h5 id="catch"><a href="#catch" class="headerlink" title=".catch"></a>.catch</h5><p>执行时机：</p>
<ul>
<li>当promise的状态改为rejected的时候，被执行</li>
<li>当promise执行体中出现代码错误时，被执行</li>
</ul>
<p>总结：使用promise来管理异步操作，使得看起来像同步操作</p>
<h5 id="all"><a href="#all" class="headerlink" title=".all"></a>.all</h5><p><span style="color:red">all的用法：谁跑的慢，以谁为准执行回调。all接收一个数组参数，里面的值最终都算返回Promise对象</span></p>
<p>Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Promise1</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;&#125;)</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Promise2</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;&#125;)</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Promise3</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title class_">Promise1</span>, <span class="title class_">Promise2</span>, <span class="title class_">Promise3</span>])</span><br><span class="line"> </span><br><span class="line">p.<span class="title function_">then</span>(<span class="title function_">funciton</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 三个都成功则成功  </span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 只要有失败，则失败 </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据。</p>
<p><span style="color: green"><em>有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</em></span></p>
<h5 id="race"><a href="#race" class="headerlink" title=".race"></a>.race</h5><p><span style="color:red">race的用法：谁跑的快，以谁为准执行回调</span></p>
<p>race的使用场景：比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求某个图片资源</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">requestImg</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">           img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">               <span class="title function_">resolve</span>(img);</span><br><span class="line">           &#125;</span><br><span class="line">           img.<span class="property">src</span> = <span class="string">&#x27;图片的路径&#x27;</span>;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//延时函数，用于给请求计时</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">               <span class="title function_">reject</span>(<span class="string">&#x27;图片请求超时&#x27;</span>);</span><br><span class="line">           &#125;, <span class="number">5000</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title class_">Promise</span>.<span class="title function_">race</span>([<span class="title function_">requestImg</span>(), <span class="title function_">timeout</span>()]).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span>&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">   &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>

<p>requestImg函数会异步请求一张图片，我把地址写为”图片的路径”，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>React中的Hooks</title>
    <url>/2021/12/11/React%E4%B8%AD%E7%9A%84Hooks/</url>
    <content><![CDATA[<h3 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h3><p>前言：React中组件由函数组件与类组件，在 React Hooks 出现之前，我们可以使用函数和类组件来进行项目开发，但是如果组件中需要进行状态管理，函数组件就显得无能为力。React在v16.8 的版本中推出了 React Hooks 新特性，Hook是<strong>一套工具函数的集合</strong>,它增强了函数组件的功能，<strong>hook不等于函数组件，所有的hook函数都是以use开头。</strong></p>
<blockquote>
<p><strong>使用 React Hooks 相比于从前的类组件有以下几点好处</strong>：</p>
<ul>
<li>代码可读性更强，原本同一块功能的代码逻辑被拆分在了不同的生命周期函数中，容易使开发者不利于维护和迭代，通过 React Hooks 可以将功能代码聚合，方便阅读维护</li>
<li>组件树层级变浅，在原本的代码中，我们经常使用 HOC&#x2F;render&#x2F;Props 等方式来复用组件的状态，增强功能等，无疑增加了组件树层数及渲染，而在 React Hooks 中，这些功能都可以通过强大的自定义的 Hooks 来实现</li>
<li>hook使用比使用类组件简单许多（仁者见仁智者见智）</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/yinlifan/img/20220811150931.png"></p>
<span id="more"></span>

<h4 id="Hooks的使用限制"><a href="#Hooks的使用限制" class="headerlink" title="Hooks的使用限制"></a>Hooks的使用限制</h4><ul>
<li>hooks<strong>只能</strong>用在函数组件<strong>中</strong>，class组件不行</li>
<li><strong>普通</strong>函数不能使用hooks（hooks不能在组件函数外去使用）</li>
<li>Hooks不能被有条件的调用，因此不能放在if&#x2F;for中（如果真有有条件调用的需求，请把条件写在hooks函数内）</li>
</ul>
<h4 id="常用的hooks函数"><a href="#常用的hooks函数" class="headerlink" title="常用的hooks函数"></a>常用的hooks函数</h4><p><span style="color: blue;">官网文档：<a href="https://reactjs.org/docs/hooks-reference.html">https://reactjs.org/docs/hooks-reference.html</a></span></p>
<p>Hooks的使用步骤：</p>
<ul>
<li>导入hook成员</li>
<li>使用hook成员</li>
</ul>
<h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h4><p>作用：保存组件的状态</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setstate] = <span class="title function_">useState</span>(initialState);</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hook：useState</span></span><br><span class="line"><span class="comment">// 提供者：React</span></span><br><span class="line"><span class="comment">// 作用：为函数组件模拟状态</span></span><br><span class="line"><span class="comment">// 语法：const [变量名,方法名] = useState(state初始化)</span></span><br><span class="line"><span class="comment">//      一般约定俗成的为：假设变量名为state，则方法名就为setState</span></span><br><span class="line"><span class="comment">//      变量名：用于后续在组件的jsx语法中获取和使用状态的数据【获取】</span></span><br><span class="line"><span class="comment">//      方法名：通过执行该方法，来实现对状态的修改【设置】</span></span><br><span class="line"><span class="comment">// state初始化的默认值，可以是任意形式（可以是字面量，也可以是复合数据类型）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">HooksState</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 使用useState</span></span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> [uInfo, setInfo] = <span class="title function_">useState</span>(&#123; <span class="attr">uname</span>: <span class="string">&quot;zhangsan&quot;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>计数器：&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名：&#123;uInfo.uname&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄：&#123;uInfo.age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;/* 修改方法的参数就是最终想改成的值（记得带上旧数据） */&#125;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setInfo(&#123; ...uInfo, age: uInfo.age + 2 &#125;)&#125;&gt;age+2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">HooksState</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h4><p>作用：模拟类组件中的生命周期的</p>
<p>函数组件对于在一些生命周期中操作还是无能为力，所以 React提供了 useEffect 来帮助开发者处理函数组件，来帮助模拟完成一部份的开发中<strong>非常常用的生命周期方法（并不是全部的生命周期）</strong>。常被称为：<strong>副作用处理函数</strong>。此函数的操作是异步的。</p>
<p>useEffect 相当类组件中的3个生命周期 （但含义上不完全等同）</p>
<ul>
<li>componentDidMount</li>
<li>componentDidUpdate </li>
<li>componetWillUnMount</li>
</ul>
<p>语法：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    effect... 副作用的操作,（类似于组件挂载完毕后、更新完毕后的操作）</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        cleanup... 清理副作用</span><br><span class="line">        （类似于组件的解除挂载的周期，可选）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[<span class="variable constant_">INPUT</span>,....])</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hook：useEffect</span></span><br><span class="line"><span class="comment">// 提供者：React</span></span><br><span class="line"><span class="comment">// 作用：副作用Hook函数，用于执行有副作用的代码和清理副作用。【模拟生命周期】</span></span><br><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="comment">//      useEffect(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//          执行有副作用的代码...</span></span><br><span class="line"><span class="comment">//          return () =&gt; &#123;</span></span><br><span class="line"><span class="comment">//              执行清理副作用代码....</span></span><br><span class="line"><span class="comment">//          &#125;</span></span><br><span class="line"><span class="comment">//      &#125;,[元素1,元素2...])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">HooksEffect</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 初始化状态</span></span><br><span class="line">    <span class="keyword">const</span> [state1, setState1] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> [state2, setState2] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 案例：点击页面，记录点击的坐标</span></span><br><span class="line">    <span class="keyword">const</span> [state3, setState3] = <span class="title function_">useState</span>(&#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;);</span><br><span class="line">    <span class="comment">// 事件处理程序</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handler</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;点了&quot;</span>);</span><br><span class="line">        <span class="title function_">setState3</span>(&#123; <span class="attr">x</span>: e.<span class="property">clientX</span>, <span class="attr">y</span>: e.<span class="property">clientY</span> &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况1：每次渲染（首次+后续更新）的时候都会执行（模拟挂载完毕和更新完毕）</span></span><br><span class="line">    <span class="comment">// useEffect(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(&quot;走了这里&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况2：首次渲染的时候执行（模拟挂载完毕）</span></span><br><span class="line">    <span class="comment">// useEffect(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(&quot;走了这里&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;,[]);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况3：首次渲染及后续指定元素更新（监听）后会执行</span></span><br><span class="line">    <span class="comment">// useEffect(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(&quot;走了这里&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;, [state1]);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况4：清理副作用，清理代码会在下一次执行副作用代码之前执行【可以看作是模拟解挂周期】</span></span><br><span class="line">    <span class="comment">// useEffect(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(&quot;走了这里&quot;);</span></span><br><span class="line">    <span class="comment">//     return () =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//         console.log(&quot;走了这里2&quot;);</span></span><br><span class="line">    <span class="comment">//     &#125;;</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 案例：</span></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的代码：每次渲染（首次+后续更新）的时候都会执行</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, handler);</span><br><span class="line">        <span class="comment">// 清理副作用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;click&quot;</span>, handler);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>状态1值是：&#123;state1&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setState1(state1 + 1)&#125;&gt;state1+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>状态2值是：&#123;state2&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setState2(state2 + 1)&#125;&gt;state2+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">HooksEffect</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h4><p>作用：用来生成对 DOM 对象的引用（类似于类组件中的createRef方法）</p>
<p>案例：实现表单项数据的获取</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hook：useRef</span></span><br><span class="line"><span class="comment">// 提供者：React</span></span><br><span class="line"><span class="comment">// 作用：用来替代之前的createRef</span></span><br><span class="line"><span class="comment">// 语法：const 变量名 = useRef()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">HooksRef</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 产生ref对象</span></span><br><span class="line">    <span class="keyword">const</span> ref_dom = <span class="title function_">useRef</span>();</span><br><span class="line">    <span class="comment">// this.ref_dom = createRef()</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;ref_dom&#125;</span>&gt;</span>今天是个好日子，晚上很开心，剁手<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;/* 与之前一样，如果绑在普通的html标签上则获取dom，绑在组件标签上则获取的是组件的实例 */&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> console.log(ref_dom.current)&#125;&gt;获取<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">HooksRef</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h4><p>作用：createContext实现数据的共享</p>
<p>步骤回顾：</p>
<ul>
<li>独立产生context对象（通过createContext）</li>
<li>需要共享数据的组件导入context中的Provider身份，通过value属性共享数据</li>
<li>需要使用共享数据的组件需要被Provider给包裹起来</li>
<li>消费数据【useContext解决的是消费数据方式比较繁琐的问题】<ul>
<li>组件消费</li>
<li>属性消费</li>
</ul>
</li>
</ul>
<p>根据上述提示，目前消费方式统一，因此只需要建立俩个组件即可：</p>
<p>①创建独立的context对象产生文件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建context对象</span></span><br><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="comment">// 导出对象</span></span><br><span class="line"><span class="comment">// 该方法执行的时候支持传递参数【默认值】</span></span><br><span class="line"><span class="comment">// 正常情况下，value是有数据的，但是数据是通过父子关系去使用的。但是实际开发的时候存在一种情况：不想通过父子关系去使用数据【单元测试，unit test】</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createContext</span>(&#123; <span class="attr">goods_name</span>: <span class="number">1</span>, <span class="attr">goods_price</span>: <span class="number">2</span>, <span class="attr">goods_number</span>: <span class="number">3</span>, <span class="attr">obj</span>: &#123; <span class="attr">a</span>: <span class="number">0</span> &#125; &#125;);</span><br></pre></td></tr></table></figure>

<p>②创建共享数据的组件（父）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&quot;./Child&quot;</span>;</span><br><span class="line"><span class="comment">// 导入context对象</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Obj</span> <span class="keyword">from</span> <span class="string">&quot;./context&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Parent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 父的数据（商品）</span></span><br><span class="line">    <span class="keyword">const</span> goods = &#123;</span><br><span class="line">        <span class="attr">goods_name</span>: <span class="string">&quot;小米 100&quot;</span>,</span><br><span class="line">        <span class="attr">goods_price</span>: <span class="number">10000</span>,</span><br><span class="line">        <span class="attr">goods_number</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">obj</span>: &#123;</span><br><span class="line">            <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Obj.Provider</span> <span class="attr">value</span>=<span class="string">&#123;goods&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Child</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Obj.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Parent</span>;</span><br></pre></td></tr></table></figure>

<p>③创建消费组件（子）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hook：useContext</span></span><br><span class="line"><span class="comment">// 提供者：React</span></span><br><span class="line"><span class="comment">// 作用：消费数据</span></span><br><span class="line"><span class="comment">// 语法：const 变量名 = useContext(context对象)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Obj</span> <span class="keyword">from</span> <span class="string">&quot;./context&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 消费数据</span></span><br><span class="line">    <span class="keyword">const</span> goods = <span class="title function_">useContext</span>(<span class="title class_">Obj</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(goods);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>商品名称：&#123;goods.goods_name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>商品单价：&#123;goods.goods_price&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>商品数量：&#123;goods.goods_number&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>输出1：&#123;goods.obj.a&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Child</span>;</span><br></pre></td></tr></table></figure>

<h4 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h4><p>React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。</p>
<p>Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是<code>(state, action) =&gt; newState</code>。</p>
<p><code>useReducers()</code>钩子用来引入 Reducer 功能。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState);</span><br></pre></td></tr></table></figure>

<p>上面是<code>useReducer()</code>的基本用法，它接受 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的<code>dispatch</code>函数。</p>
<p>下面是一个计数器的例子。用于计算状态的 Reducer 函数如下。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myReducer</span> = (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.<span class="property">type</span>)  &#123;</span><br><span class="line">    <span class="keyword">case</span>(<span class="string">&#x27;countUp&#x27;</span>):</span><br><span class="line">      <span class="keyword">return</span>  &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span>  state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件代码如下。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(myReducer, &#123; <span class="attr">count</span>:   <span class="number">0</span> &#125;);</span><br><span class="line">  <span class="keyword">return</span>  (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;countUp&#x27; &#125;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        +1</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Hooks 可以提供共享状态和 Reducer 函数，所以它在这些方面可以取代 Redux。但是，它没法提供中间件（middleware）和时间旅行（time travel），如果你需要这两个功能，还是要用 Redux。</p>
<h4 id="创建自己的-Hooks"><a href="#创建自己的-Hooks" class="headerlink" title="创建自己的 Hooks"></a>创建自己的 Hooks</h4><p>上例的 Hooks 代码还可以封装起来，变成一个自定义的 Hook，便于共享。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">usePerson</span> = (<span class="params">personId</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = <span class="title function_">useState</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> [person, setPerson] = <span class="title function_">useState</span>(&#123;&#125;);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setLoading</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">`https://swapi.co/api/people/<span class="subst">$&#123;personId&#125;</span>/`</span>)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setPerson</span>(data);</span><br><span class="line">        <span class="title function_">setLoading</span>(<span class="literal">false</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, [personId]);  </span><br><span class="line">  <span class="keyword">return</span> [loading, person];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>usePerson()</code>就是一个自定义的 Hook。</p>
<p>Person 组件就改用这个新的钩子，引入封装的逻辑。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Person</span> = (<span class="params">&#123; personId &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [loading, person] = <span class="title function_">usePerson</span>(personId);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loading === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading ...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You&#x27;re viewing: &#123;person.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Height: &#123;person.height&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Mass: &#123;person.mass&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://www.valentinog.com/blog/hooks/">https://www.valentinog.com/blog/hooks/</a></p>
<p><a href="https://reactjs.org/docs/hooks-reference.html">https://reactjs.org/docs/hooks-reference.html</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React中的事件处理逻辑</title>
    <url>/2020/11/08/React%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h4 id="React中的事件处理逻辑"><a href="#React中的事件处理逻辑" class="headerlink" title="React中的事件处理逻辑"></a>React中的事件处理逻辑</h4><p>为了解决跨浏览器兼容性问题，会将浏览器的原生事件封装成合并事件并且传入到事件处理器中。这里的合成事件提供了与原生事件相同的接口，它们都屏蔽了底层浏览器的细节差异，保证了行为的一致性。react并没有直接将事件绑定在子元素上，而是将所有的事件发送到顶层处理。这样在更新dom的时候就不需要考虑如何处理附着在dom上的事件，最终达到优化性能的目的。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React坑点</title>
    <url>/2020/12/05/React%E5%9D%91%E7%82%B9/</url>
    <content><![CDATA[<h4 id="使用React遇到的坑点"><a href="#使用React遇到的坑点" class="headerlink" title="使用React遇到的坑点"></a><strong>使用React遇到的坑点</strong></h4><h5 id="1-jsx做表达式判断时候，需要强转为boolean类型。"><a href="#1-jsx做表达式判断时候，需要强转为boolean类型。" class="headerlink" title="1.jsx做表达式判断时候，需要强转为boolean类型。"></a>1.jsx做表达式判断时候，需要强转为boolean类型。</h5><blockquote>
<p>如果不使用 <code>!!b </code>进行强转数据类型，会在页面输出 <code>0</code>。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;</span></span><br><span class="line"><span class="language-xml">      !!b &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一段文本<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-尽量不要再-componentWillReviceProps-里使用setState，如果一定要使用，那么需要判断结束条件，不然会出现无限重渲染，导致页面崩溃。"><a href="#2-尽量不要再-componentWillReviceProps-里使用setState，如果一定要使用，那么需要判断结束条件，不然会出现无限重渲染，导致页面崩溃。" class="headerlink" title="2.尽量不要再 componentWillReviceProps 里使用setState，如果一定要使用，那么需要判断结束条件，不然会出现无限重渲染，导致页面崩溃。"></a>2.尽量不要再 componentWillReviceProps 里使用setState，如果一定要使用，那么需要判断结束条件，不然会出现无限重渲染，导致页面崩溃。</h5><h5 id="3-给组件添加ref时候，尽量不要使用匿名函数，因为当组件更新的时候，匿名函数会被当做新的prop处理，让ref属性接受到性函数的时候，react内部会先清空ref，也就是会以null为回调参数先执行一次热风。这个props，然后在以该组件的实例执行一次ref，所以用匿名函数做ref的时候，有时候去ref赋值后的属性会取到null。"><a href="#3-给组件添加ref时候，尽量不要使用匿名函数，因为当组件更新的时候，匿名函数会被当做新的prop处理，让ref属性接受到性函数的时候，react内部会先清空ref，也就是会以null为回调参数先执行一次热风。这个props，然后在以该组件的实例执行一次ref，所以用匿名函数做ref的时候，有时候去ref赋值后的属性会取到null。" class="headerlink" title="3.给组件添加ref时候，尽量不要使用匿名函数，因为当组件更新的时候，匿名函数会被当做新的prop处理，让ref属性接受到性函数的时候，react内部会先清空ref，也就是会以null为回调参数先执行一次热风。这个props，然后在以该组件的实例执行一次ref，所以用匿名函数做ref的时候，有时候去ref赋值后的属性会取到null。"></a>3.给组件添加ref时候，尽量不要使用匿名函数，因为当组件更新的时候，匿名函数会被当做新的prop处理，让ref属性接受到性函数的时候，react内部会先清空ref，也就是会以null为回调参数先执行一次热风。这个props，然后在以该组件的实例执行一次ref，所以用匿名函数做ref的时候，有时候去ref赋值后的属性会取到null。</h5><h5 id="4-遍历子节点的时候，不要用index作为组件的key进行传入。"><a href="#4-遍历子节点的时候，不要用index作为组件的key进行传入。" class="headerlink" title="4.遍历子节点的时候，不要用index作为组件的key进行传入。"></a>4.遍历子节点的时候，不要用index作为组件的key进行传入。</h5>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React杂记</title>
    <url>/2020/09/05/React%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="React-中-refs-的作用是什么-？"><a href="#React-中-refs-的作用是什么-？" class="headerlink" title="React 中 refs 的作用是什么 ？"></a><strong>React 中 refs 的作用是什么</strong> ？</h4><p>refs是react 提供给我们安全访问dom的一个方法（句柄）。</p>
<p>可以使用refs属性，在回调函数中第一个参数拿到绑定refs属性的dom值。</p>
<h4 id="传入-setState-函数的第二个参数的作用是什么？"><a href="#传入-setState-函数的第二个参数的作用是什么？" class="headerlink" title="传入 setState 函数的第二个参数的作用是什么？"></a><strong>传入 setState 函数的第二个参数的作用是什么？</strong></h4><p>setState第一个参数是个对象，第二个参数是个函数。在修改完状态，页面重新渲染的时候。就会触法这个函数。可以用来监听状态是否更新。</p>
<h4 id="在生命周期中的哪一步你应该发起-AJAX-请求"><a href="#在生命周期中的哪一步你应该发起-AJAX-请求" class="headerlink" title="在生命周期中的哪一步你应该发起 AJAX 请求 ?"></a><strong>在生命周期中的哪一步你应该发起 AJAX 请求</strong> ?</h4><p>在componentDidmount（）生命周期函数中执行。</p>
<p>原因：</p>
<p>在react下一代调和算法中，会通过开始或停止来优化性能。这回影响到comonentWillmount触发的次数。触发次数不确定，可能会多次调用componentWillmount（）生命周期方法。如果键ajax请求放到这个生命周期里明显不是一个明智的选择。</p>
<p>如果将ajax请求放在其他生命周期里，我们不能保证是在挂载完毕后才发出请求。 如果数据在挂载之前就已经完成了，并使用setState将数据添加到组件状态中，对于为挂载的组件则会报错。而在componentDidmount中使用就会避免这个问题。</p>
<h4 id="shouldComponentUpdate-的作用-？"><a href="#shouldComponentUpdate-的作用-？" class="headerlink" title="shouldComponentUpdate 的作用 ？"></a><strong>shouldComponentUpdate 的作用</strong> ？</h4><p>使用shouldComponentUpdate是优化性能的一个方式。shouldComponentUpdate可以手动的判断组件是否更新渲染，根据组件的是否渲染，来返回一个布尔值。true或者false。从而避免不必要的更新。</p>
<h4 id="如何告诉-React-它应该编译生产环境版-？"><a href="#如何告诉-React-它应该编译生产环境版-？" class="headerlink" title="如何告诉 React 它应该编译生产环境版 ？"></a><strong>如何告诉 React 它应该编译生产环境版</strong> ？</h4><p>通常情况下我们会使用<code>webpack</code>的<code>DefinePlugin</code>方法来将NODE_ENV变量值设置为<code>production</code>。编译版本中<code>react</code>会忽略<code>proptype</code>验证以及其他的警告信息，同时还会降低代码库的大小。<code>react</code>使用了<code>uglify</code>插件来移除生产环境下不必要的注释等信息。</p>
<h4 id="概述下-React-中的事件处理逻辑-？"><a href="#概述下-React-中的事件处理逻辑-？" class="headerlink" title="概述下 React 中的事件处理逻辑 ？"></a><strong>概述下 React 中的事件处理逻辑</strong> ？</h4><p>为了解决快于浏览器兼容性的问题，<code>react</code>会将浏览器原生事件封装为合成事件传入设置的事件处理器中。这里的合成时间提供了于原生时间相同的接口，不过他们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，<code>react</code>并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样<code>react</code>在更新DOM的时候就不许哟啊考虑如何去处理附着在dom上的事件监听器，最终达到优化性能的目的。</p>
<h4 id="createElement-与-cloneElement-的区别是什么-？"><a href="#createElement-与-cloneElement-的区别是什么-？" class="headerlink" title="createElement 与 cloneElement 的区别是什么 ？"></a><strong>createElement 与 cloneElement 的区别是什么</strong> ？</h4><p><code>createElement</code>函数是JSX编译后使用创建<code>react Element</code>的函数。</p>
<p><code>cloneElement</code>是用于复制某个元素并传入新的props。</p>
<h4 id="React-中-keys-的作用是什么？"><a href="#React-中-keys-的作用是什么？" class="headerlink" title="React 中 keys 的作用是什么？"></a><strong>React 中 keys 的作用是什么？</strong></h4><blockquote>
<p><code>keys</code>是<code>react</code>用于追踪那些列表中元素被修改，被添加或者被移除的辅助标识。</p>
</blockquote>
<p>在开发过程中，我们需要保证某个元素的<code>key</code>值在同级元素中具有唯一性。在<code>react diff</code>算法中，react会借助元素<code>key</code>值来判断该元素新创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，<code>react</code>还借助<code>key</code>值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中<code>key</code>的重要性。</p>
<h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><blockquote>
<ul>
<li><a href="https://interview2.poetries.top/excellent-docs/6-React.html#_1%E3%80%81react-%E4%B8%AD-keys-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">https://interview2.poetries.top/excellent-docs/6-React.html#_1%E3%80%81react-%E4%B8%AD-keys-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux实现原理</title>
    <url>/2020/10/20/Redux%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h4 id="redux实现原理解析"><a href="#redux实现原理解析" class="headerlink" title="redux实现原理解析"></a>redux实现原理解析</h4><h5 id="为什么要用redux？"><a href="#为什么要用redux？" class="headerlink" title="为什么要用redux？"></a>为什么要用redux？</h5><blockquote>
<p>在react中，数据在组件中是单向流动的，数据从一个方向父组件传给子组件，所以两个非父子之间通信就会相对麻烦，redux的出现就是为了解决state里面的数据问题。</p>
</blockquote>
<h5 id="redux设计理念"><a href="#redux设计理念" class="headerlink" title="redux设计理念"></a>redux设计理念</h5><blockquote>
<p>redux是将整个应用状态存储到一个地方称为store，里面保存着一个状态树store tree，组件可以通过dispatch派发action给store，而不是直接通知其他组件，组件内部通过订阅store中的状态来刷新自己的视图。</p>
</blockquote>
<span id="more"></span>
<p><img src="https://cdn.jsdelivr.net/gh/yinlifan/img/20220805180910.png"></p>
<h5 id="redux三大原则"><a href="#redux三大原则" class="headerlink" title="redux三大原则"></a>redux三大原则</h5><ul>
<li>唯一数据源<ul>
<li>整个应用的state都被存储到redux仓库当中。只存在一个store。</li>
</ul>
</li>
<li>保持只读状态<ul>
<li>state是只读的，唯一改变state的方法就是触发action，action是一个动作对象，type类型，和data传递参数。</li>
</ul>
</li>
<li>只能通过纯函数改变状态</li>
</ul>
<h5 id="redux三大核心："><a href="#redux三大核心：" class="headerlink" title="redux三大核心："></a>redux三大核心：</h5><ul>
<li>action： 动作对象，两个参数type，和data</li>
<li>reducer： 用于初始化状态，加工状态</li>
<li>store：只存在一个store应用</li>
</ul>
<p>原理： 页面需要获取数据时，通过Action creates创建一个action动作对象，提交dispatch请求给store。store通知reducer进行匹配action的属性type。从而进行返回一个新的对象。</p>
]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux缺点与中间件</title>
    <url>/2020/09/06/Redux%E7%BC%BA%E7%82%B9%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h4 id="redux的缺点"><a href="#redux的缺点" class="headerlink" title="redux的缺点"></a>redux的缺点</h4><ul>
<li>一个组件所需要的数据，必须从父组件传递过来，而不能像flux，直接从store中获取。</li>
<li>一个组件的数据发生了改变，即使父组件不需要用到这个组件，父组件也会重新render渲染。这样可能会造成效率问题。或者写复杂的shouldComponentUpdate进行判断。</li>
</ul>
<h4 id="redux中间件"><a href="#redux中间件" class="headerlink" title="redux中间件"></a>redux中间件</h4><h5 id="什么是redux中间件？"><a href="#什么是redux中间件？" class="headerlink" title="什么是redux中间件？"></a>什么是redux中间件？</h5><p>中间件提供第三方插件的模式，自定义拦截action –reducer 的过程。变为action –middlewares（执行中间件代码）– reducer。这种机制可以让我们改变数据流，实现如异步action，日志输出，异常报告等。</p>
<h5 id="为什么需要redux中间件？"><a href="#为什么需要redux中间件？" class="headerlink" title="为什么需要redux中间件？"></a>为什么需要redux中间件？</h5><p>默认情况下，redux自身只能处理同步数据流。但是在实际项目开发中，状态的更新，获取，通常是使用异步操作来实现的。</p>
<ul>
<li><code>redux-logger</code>：提供日志输出</li>
<li><code>redux-thunk</code>：处理异步操作</li>
<li><code>redux-promise</code>：处理异步操作，<code>actionCreator</code>的返回值是<code>promise</code></li>
</ul>
<h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr>
<blockquote>
<ul>
<li><a href="https://interview2.poetries.top/excellent-docs/6-React.html">https://interview2.poetries.top/excellent-docs/6-React.html</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>Rollup优缺点</title>
    <url>/2019/04/03/Rollup%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    <content><![CDATA[<h4 id="介绍一下Rollup"><a href="#介绍一下Rollup" class="headerlink" title="介绍一下Rollup"></a>介绍一下Rollup</h4><p>Rollup 是一款 ES Modules 打包器。它也可以将项目中散落的细小模块打包为整块代码，从而使得这些划分的模块可以更好地运行在浏览器环境或者 Node.js 环境。</p>
<blockquote>
<p>Rollup 是一款 ES Modules 打包器。它也可以将项目中散落的细小模块打包为整块代码，从而使得这些划分的模块可以更好地运行在浏览器环境或者 Node.js 环境。</p>
</blockquote>
<h5 id="Rollup优势："><a href="#Rollup优势：" class="headerlink" title="Rollup优势："></a><strong>Rollup优势：</strong></h5><ul>
<li>输出结果更加扁平，执行效率更高；</li>
<li>自动移除未引用代码；</li>
<li>打包结果依然完全可读</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h5><span id="more"></span>
<ul>
<li>加载非 ESM 的第三方模块比较复杂；</li>
<li>因为模块最终都被打包到全局中，所以无法实现 <code>HMR</code>；</li>
<li>浏览器环境中，代码拆分功能必须使用 <code>Require.js</code> 这样的 <code>AMD</code> 库</li>
</ul>
<blockquote>
<ul>
<li>我们发现如果我们开发的是一个应用程序，需要大量引用第三方模块，同时还需要 HMR 提升开发体验，而且应用过大就必须要分包。那这些需求 Rollup 都无法满足。</li>
<li>如果我们是开发一个 JavaScript 框架或者库，那这些优点就特别有必要，而缺点呢几乎也都可以忽略，所以在很多像 React 或者 Vue 之类的框架中都是使用的 Rollup 作为模块打包器，而并非 Webpack</li>
</ul>
</blockquote>
<p><strong>总结一下</strong>：<code>Webpack 大而全，Rollup 小而美</code>。</p>
<p>在对它们的选择上，我的基本原则是：<code>应用开发使用 Webpack，类库或者框架开发使用 Rollup</code>。</p>
<p>不过这并不是绝对的标准，只是经验法则。因为 Rollup 也可用于构建绝大多数应用程序，而 Webpack 同样也可以构建类库或者框架。</p>
<p><a href="http://zslin.xyz/2019/04/10/webpack/%E4%BB%8B%E7%BB%8DRollup/tt.png"><img src="http://zslin.xyz/2019/04/10/webpack/%E4%BB%8B%E7%BB%8DRollup/tt.png" alt="img"></a></p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>Rollup</tag>
      </tags>
  </entry>
  <entry>
    <title>Vite工程化实践</title>
    <url>/2022/02/10/Vite%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h3 id="Vite工程化实践"><a href="#Vite工程化实践" class="headerlink" title="Vite工程化实践"></a>Vite工程化实践</h3><h4 id="为什么要使用vite"><a href="#为什么要使用vite" class="headerlink" title="为什么要使用vite"></a>为什么要使用vite</h4><p>在浏览器支持ES模块之前，诸如webpack、Rollup等打包工具的出现，确实是极大的改善了前端开发者的开发体验。但是当我们开始构建越来越大型的应用时，需要处理的js代码量也是呈指数级增长，模块和模块之间的依赖往往会使我们的开发工具需要更长的时间（甚至使几分钟）才能启动开发服务器，即使使用HMR，文件的修改后的效果也需要几秒钟才能在浏览器中反映出来。这也会我们要是用vite的原因，提示构建速率来改善开发体验。</p>
<h4 id="Vite-vs-传统脚手架"><a href="#Vite-vs-传统脚手架" class="headerlink" title="Vite vs 传统脚手架"></a>Vite vs 传统脚手架</h4><p>下面主要是介绍一下<strong>vite</strong>和<strong>webpack</strong>的区别</p>
<table>
<thead>
<tr>
<th></th>
<th>Vite</th>
<th>Webpack</th>
</tr>
</thead>
<tbody><tr>
<td>启动开发服务器</td>
<td>利用浏览器的原生ESM加载源码模块，启动时处理一次依赖预构建即可，二次启动秒开，访问时浏览器原生解析依赖</td>
<td>递归依赖分析、转换代码、编译、打包输出主流浏览器可直接执行的js文件，浏览器访问直接渲染</td>
</tr>
<tr>
<td>构建打包器</td>
<td>基于ESBuild使用Go编写，构建速度比nodejs快10-100倍</td>
<td>webpack由javascript编写运行在nodejs环境，运行效率较差</td>
</tr>
<tr>
<td>热更新</td>
<td>精准更新已修改的ESM模块</td>
<td>修改文件后需要重新构建文件，且随着应用体积增大而花费更长时间</td>
</tr>
<tr>
<td>生态</td>
<td>vite生态只能说勉强够用，某些功能可能需要妥协或者自己实现</td>
<td>Loader和Plugin生态丰富，方案齐全</td>
</tr>
<tr>
<td>生产环境</td>
<td>Esbuild本身存在一些限制，所以生产环境采用的Rollup</td>
<td>依托丰富的生态，稳定可靠</td>
</tr>
</tbody></table>
<span id="more"></span>
<p><span style='color: red;font-size: 900'>总结一下：</span></p>
<p>webpack启动后会做一堆事情，经历一条很长的编译打包链条，从入口开始需要逐步经历 <span style='color: blue'>语法解析 &#x3D;&gt; 依赖收集 &#x3D;&gt; 代码转译 &#x3D;&gt; 打包合并 &#x3D;&gt; 代码优化</span>,最终将高版本的、离散的源码编译打包成低版本的、高兼容性的产物代码，这可满满都是CPU、IO操做啊！在node运行时下性能必然是有问题。</p>
<p>而 vite 运行 dev 命令后只做了两件事，<span style='color:blue;'>一是</span>启动了一个用于承载资源服务的server； <span style='color:blue;'>二是</span>使用ESBuild预构建npm依赖包。之后就一直躺着，直到浏览器以http方式发来ESM规范的模块请求时，Vite才开始<strong>“按需编译”</strong>被请求的模块。</p>
<h4 id="搭建vite项目"><a href="#搭建vite项目" class="headerlink" title="搭建vite项目"></a>搭建vite项目</h4><p>这里官网提供了npm, yarn, pnpm 三种模式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm create vite@latest <span class="comment">// 使用npm</span></span><br><span class="line">yarn create vite <span class="comment">// 使用yarn</span></span><br><span class="line">pnpm create vite <span class="comment">// 使用pnpm</span></span><br></pre></td></tr></table></figure>

<p>这里选择yarn，创建了一个基于vite构建的react项目</p>
<p><img src="https://cdn.jsdelivr.net/gh/yinlifan/img/20220808134657.png"></p>
<p>生成的目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">│  .gitignore</span><br><span class="line">│  index.html</span><br><span class="line">│  package.json</span><br><span class="line">│  tsconfig.json</span><br><span class="line">│  tsconfig.node.json</span><br><span class="line">│  vite.config.ts</span><br><span class="line">│</span><br><span class="line">├─public</span><br><span class="line">│      vite.svg</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">    │  App.css</span><br><span class="line">    │  App.tsx</span><br><span class="line">    │  index.css</span><br><span class="line">    │  main.tsx</span><br><span class="line">    │  vite-env.d.ts</span><br><span class="line">    │</span><br><span class="line">    └─assets</span><br><span class="line">            react.svg</span><br></pre></td></tr></table></figure>

<p>其中index.html为页面的入口文件，main.tsx为系统主入口，vite.config.ts为vite的配置文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn install // 安装依赖</span><br><span class="line">yarn dev // 启动项目</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yinlifan/img/20220808134935.png"></p>
<p>这里我们根据脚手架启动的项目就已经运行起来了。</p>
<h4 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h4><p>在项目开始之前，引入项目的所需的react-router、ant design、axios、less or sass并使用git作为版本管理工具。</p>
<h5 id="vite的按需加载"><a href="#vite的按需加载" class="headerlink" title="vite的按需加载"></a>vite的按需加载</h5><p>vite的按需加载需要vite-plugin-imp来实现按需加载</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add vite-plugin-imp -dev</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> react <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vitePluginImp  <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">react</span>(),</span><br><span class="line">    <span class="title function_">vitePluginImp</span>(&#123;</span><br><span class="line">      <span class="attr">libName</span>: <span class="string">&quot;antd&quot;</span>,</span><br><span class="line">      <span class="attr">style</span>: <span class="function">(<span class="params">name: string</span>) =&gt;</span> <span class="string">`antd/lib/<span class="subst">$&#123;name&#125;</span>/style/index.less`</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="配置antd主题颜色"><a href="#配置antd主题颜色" class="headerlink" title="配置antd主题颜色"></a>配置antd主题颜色</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; getThemeVariables &#125; <span class="keyword">from</span> <span class="string">&#x27;antd/dist/theme&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lessVarsToJs <span class="keyword">from</span> <span class="string">&#x27;less-vars-to-js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析你的配置</span></span><br><span class="line"><span class="keyword">const</span> antdThemeConfig = <span class="title function_">lessVarsToJs</span>(</span><br><span class="line">  fs.<span class="title function_">readFileSync</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src/assets/antdTheme.less&#x27;</span>))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">css</span>: &#123;</span><br><span class="line">    <span class="attr">preprocessorOptions</span>: &#123;</span><br><span class="line">      <span class="attr">less</span>: &#123;</span><br><span class="line">        <span class="comment">// 支持内联 JavaScript</span></span><br><span class="line">        <span class="attr">javascriptEnabled</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">modifyVars</span>: &#123;...<span class="title function_">getThemeVariables</span>(), ...antdThemeConfig&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="简写路径配置"><a href="#简写路径配置" class="headerlink" title="简写路径配置"></a>简写路径配置</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&quot;@&quot;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>) </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<h5 id="ts的路径解析能力"><a href="#ts的路径解析能力" class="headerlink" title="ts的路径解析能力"></a>ts的路径解析能力</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tsConfigPaths <span class="keyword">from</span> <span class="string">&#x27;vite-tsconfig-paths&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">tsConfigPaths</span>(),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tsConfigPaths <span class="keyword">from</span> <span class="string">&#x27;vite-plugin-package-version&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">pluginPackageVersion</span>(),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="端口配置"><a href="#端口配置" class="headerlink" title="端口配置"></a>端口配置</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">server</span>: &#123;</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="attr">strictPort</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="vite-config-ts最终配置"><a href="#vite-config-ts最终配置" class="headerlink" title="vite.config.ts最终配置"></a>vite.config.ts最终配置</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; getThemeVariables &#125; <span class="keyword">from</span> <span class="string">&#x27;antd/dist/theme&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> react <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vitePluginImp  <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> tsConfigPaths <span class="keyword">from</span> <span class="string">&#x27;vite-tsconfig-paths&#x27;</span></span><br><span class="line"><span class="keyword">import</span> pluginPackageVersion <span class="keyword">from</span> <span class="string">&#x27;vite-plugin-package-version&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lessVarsToJs <span class="keyword">from</span> <span class="string">&#x27;less-vars-to-js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> antdThemeConfig = <span class="title function_">lessVarsToJs</span>(</span><br><span class="line">  fs.<span class="title function_">readFileSync</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src/assets/antdTheme.less&#x27;</span>))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">react</span>(),</span><br><span class="line">    <span class="title function_">tsConfigPaths</span>(),</span><br><span class="line">    <span class="title function_">pluginPackageVersion</span>(),</span><br><span class="line">    <span class="title function_">vitePluginImp</span>(&#123;</span><br><span class="line">      <span class="attr">libName</span>: <span class="string">&quot;antd&quot;</span>,</span><br><span class="line">      <span class="attr">style</span>: <span class="function">(<span class="params">name: string</span>) =&gt;</span> <span class="string">`antd/lib/<span class="subst">$&#123;name&#125;</span>/style/index.less`</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  </span><br><span class="line">  <span class="attr">css</span>: &#123;</span><br><span class="line">    <span class="attr">preprocessorOptions</span>: &#123;</span><br><span class="line">      <span class="attr">less</span>: &#123;</span><br><span class="line">        <span class="comment">// 支持内联 JavaScript</span></span><br><span class="line">        <span class="attr">javascriptEnabled</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">modifyVars</span>: &#123;...<span class="title function_">getThemeVariables</span>(), ...antdThemeConfig&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">server</span>: &#123;</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="attr">strictPort</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&quot;@&quot;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>) </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;composite&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;ESNext&quot;</span>,</span><br><span class="line">    <span class="string">&quot;moduleResolution&quot;</span>: <span class="string">&quot;Node&quot;</span>,</span><br><span class="line">    <span class="string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;baseUrl&quot;</span>: <span class="string">&quot;.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;@/*&quot;</span>: [<span class="string">&quot;./src/*&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [<span class="string">&quot;vite.config.ts&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="添加prettier格式化代码格式"><a href="#添加prettier格式化代码格式" class="headerlink" title="添加prettier格式化代码格式"></a>添加prettier格式化代码格式</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add prettier --save</span><br></pre></td></tr></table></figure>

<h6 id="增加prettier-config-ts文件"><a href="#增加prettier-config-ts文件" class="headerlink" title="增加prettier.config.ts文件"></a>增加prettier.config.ts文件</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">printWidth</span>: <span class="number">80</span>,</span><br><span class="line">    <span class="attr">tabWidth</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">useTabs</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">semi</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">singleQuote</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">quoteProps</span>: <span class="string">&#x27;as-needed&#x27;</span>,</span><br><span class="line">    <span class="attr">jsxSingleQuote</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">trailingComma</span>: <span class="string">&#x27;es5&#x27;</span>,</span><br><span class="line">    <span class="attr">bracketSpacing</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">bracketSameLine</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">arrowParens</span>: <span class="string">&#x27;always&#x27;</span>,</span><br><span class="line">    <span class="attr">htmlWhitespaceSensitivity</span>: <span class="string">&#x27;ignore&#x27;</span>,</span><br><span class="line">    <span class="attr">vueIndentScriptAndStyle</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">endOfLine</span>: <span class="string">&#x27;lf&#x27;</span>,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="React-Router配置"><a href="#React-Router配置" class="headerlink" title="React Router配置"></a>React Router配置</h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">React</span> <span class="title class_">Router</span>配置<span class="comment">// src/App.tsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span>, <span class="title class_">Routes</span>, <span class="title class_">Route</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ConfigProvider</span>, <span class="title class_">Layout</span>, <span class="title class_">Result</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> zhCN <span class="keyword">from</span> <span class="string">&#x27;antd/es/locale/zh_CN&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="variable constant_">ROUTES</span>, &#123; <span class="title class_">IRoute</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./routes&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">from</span> <span class="string">&#x27;./components/ErrorBoundary&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./App.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FullBack</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ConfigProvider</span> <span class="attr">locale</span>=<span class="string">&#123;zhCN&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Layout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              &#123;/* 使用懒加载会导致加载延迟，使用suspense优化体验 */&#125;</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">FullBack</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                  &#123;ROUTES?.map((route) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">                    return (</span></span><br><span class="line"><span class="language-xml">                      <span class="tag">&lt;<span class="name">Route</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">key</span>=<span class="string">&#123;route.url&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">path</span>=<span class="string">&#123;route.url&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">element</span>=<span class="string">&#123;route.Element&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                      /&gt;</span></span></span><br><span class="line"><span class="language-xml">                    );</span></span><br><span class="line"><span class="language-xml">                  &#125;)&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;<span class="name">Route</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">path</span>=<span class="string">&quot;*&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">element</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                      &lt;<span class="attr">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginTop:</span> <span class="attr">80</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">Result</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                          <span class="attr">status</span>=<span class="string">&quot;404&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                          <span class="attr">title</span>=<span class="string">&quot;404&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                          <span class="attr">subTitle</span>=<span class="string">&quot;抱歉，您访问的资源不存在&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        /&gt;</span></span></span><br><span class="line"><span class="language-xml">                      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#125;</span></span><br><span class="line"><span class="language-xml">                  /&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ConfigProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/routes</span></span><br><span class="line"><span class="keyword">import</span> &#123; lazy &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">IRoute</span> &#123;</span><br><span class="line">  <span class="attr">path</span>: string;</span><br><span class="line">  <span class="title class_">Element</span>?: <span class="title class_">React</span>.<span class="property">ReactElement</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Home</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./../pages/Home&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Test</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./../pages/Test&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">ROUTES</span>: <span class="title class_">Array</span>&lt;<span class="title class_">IRoute</span> | <span class="literal">undefined</span>&gt; = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="title class_">Element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">    <span class="title class_">Element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Test</span> /&gt;</span></span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="variable constant_">ROUTES</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/components/ErrorBoundary</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Result</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&lt;&#123;</span><br><span class="line">  <span class="attr">children</span>: <span class="title class_">React</span>.<span class="property">ReactNode</span>;</span><br><span class="line">  hasError?: boolean;</span><br><span class="line">&#125;&gt; &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">hasError</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; children &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">  <span class="keyword">const</span> &#123; hasError &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Result</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">status</span>=<span class="string">&quot;500&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">title</span>=<span class="string">&quot;500&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">subTitle</span>=<span class="string">&quot;抱歉，服务器出错了，请刷新重试&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="请求库函数"><a href="#请求库函数" class="headerlink" title="请求库函数"></a>请求库函数</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add ahooks --save</span><br></pre></td></tr></table></figure>

<p>ahooks提供了大量的封装好的Hooks使用，其中useRequest更是一个强大的异步数据管理的Hooks，一般情况下的请求场景都是足够使用的。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>vite实现了真正的按需加载，我们只需要提供页面加载所需的模块，剩下的就让浏览器去做。对于我们来说，<code>打包</code>不是目的，能够快速的<code>运行</code>才是我们的目的。配置简单，学习成本也比较低，不需要像webpack一样去加载各种loader。</p>
<hr>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://segmentfault.com/a/1190000040278828">https://segmentfault.com/a/1190000040278828</a></p>
<p><a href="https://juejin.cn/post/7000182183344209934">https://juejin.cn/post/7000182183344209934</a></p>
<p><a href="https://cn.vitejs.dev/">https://cn.vitejs.dev/</a></p>
]]></content>
      <categories>
        <category>Vite</category>
      </categories>
      <tags>
        <tag>Vite</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2,Vue3响应式原理</title>
    <url>/2020/12/29/Vue2,Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><a href="http://zslin.xyz/2019/05/27/vue2/vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/15.png"><img src="http://zslin.xyz/2019/05/27/vue2/vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/15.png" alt="img"></a></p>
<h3 id="Vue2-x响应式原理："><a href="#Vue2-x响应式原理：" class="headerlink" title="Vue2.x响应式原理："></a>Vue2.x响应式原理：</h3><p>vue创建一个实例时，首先会遍历data属性。采用数据劫持结合发布者订阅者的方式。使用es5的object.defindeproperty 方法将他们转化成getter，setter，并在内部追踪相关依赖。在属性被访问和修改时通知变化。也就是observer使用object.defindproerty来监听数据的读写。读取数据时，调用get方法通知dep去收集订阅者（watcher）。添加到道dep的一个属性subs数理。 dep有很多属性，其中就有一个subsadd添加订阅者的方法。修改1数据时，调用set方法，通知dep数据发生了改变。使用dep.notify方法遍历subs数组里面的每个watcher。调用watcher的update（）方法。创建出一个新的dom树，与原来旧的dom树作对比，根据差异性，从而更新视图。</p>
<span id="more"></span>
<p><a href="http://zslin.xyz/2019/05/27/vue2/vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/vue.jpeg"><img src="http://zslin.xyz/2019/05/27/vue2/vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/vue.jpeg" alt="img"></a></p>
<p><strong>Object.defineProperty( )</strong> ，那么它的用法是什么，以及优缺点是什么呢？</p>
<ul>
<li>可以检测对象中数据发生的修改</li>
<li>对于复杂的对象，层级很深的话，是不友好的，需要经行深度监听，这样子就需要递归到底，这也是它的缺点。</li>
<li>对于一个对象中，如果你新增加属性，删除属性，<strong>Object.defineProperty()</strong> 是不能观测到的，那么应该如何解决呢？可以通过<code>Vue.set()</code>和<code>Vue.delete()</code>来实现。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟 Vue 中的 data 选项 </span></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟 Vue 的实例 </span></span><br><span class="line"><span class="keyword">let</span> vm = &#123;&#125;</span><br><span class="line"><span class="comment">// 数据劫持:当访问或者设置 vm 中的成员的时候，做一些干预操作</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(vm, <span class="string">&#x27;msg&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 可枚举(可遍历)</span></span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 可配置(可以使用 delete 删除，可以通过 defineProperty 重新定义) </span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 当获取值的时候执行 </span></span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get: &#x27;</span>, data.<span class="property">msg</span>)</span><br><span class="line">    <span class="keyword">return</span> data.<span class="property">msg</span> </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 当设置值的时候执行 </span></span><br><span class="line">  set (newValue) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set: &#x27;</span>, newValue) </span><br><span class="line">    <span class="keyword">if</span> (newValue === data.<span class="property">msg</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    data.<span class="property">msg</span> = newValue</span><br><span class="line">    <span class="comment">// 数据更改，更新 DOM 的值 </span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">textContent</span> = data.<span class="property">msg</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">vm.<span class="property">msg</span> = <span class="string">&#x27;Hello World&#x27;</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">msg</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Vue3-X响应式原理："><a href="#Vue3-X响应式原理：" class="headerlink" title="Vue3.X响应式原理："></a>Vue3.X响应式原理：</h3><p><code>Vue3.x</code>改用<code>Proxy</code>替代<code>Object.defineProperty</code>。因为<code>Proxy</code>可以直接监听<code>对象和数组</code>的变化，并且有多达13种拦截方法。</p>
<p>代理，顾名思义，就是在要访问的对象之前增加⼀个中间层，这样就不直接访问对象，⽽是通过中间层做⼀个中转，通过操作代理对象，来实现修改目标对象。</p>
<p><strong>监测数组的时候可能触发多次get&#x2F;set，那么如何防止触发多次呢？</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟 Vue 中的 data 选项 </span></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟 Vue 实例</span></span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="comment">// 当访问 vm 的成员会执行</span></span><br><span class="line">  get (target, key) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get, key: &#x27;</span>, key, target[key])</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 当设置 vm 的成员会执行</span></span><br><span class="line">  set (target, key, newValue) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set, key: &#x27;</span>, key, newValue)</span><br><span class="line">    <span class="keyword">if</span> (target[key] === newValue) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    target[key] = newValue</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#app&#x27;</span>).<span class="property">textContent</span> = target[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">vm.<span class="property">msg</span> = <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(vm.<span class="property">msg</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>Vue<ul>
<li>记录传入的选项，设置 <code>$data/$el</code></li>
<li>把 <code>data</code> 的成员注入到 <code>Vue</code> 实例</li>
<li>负责调用 <code>Observer</code> 实现数据响应式处理(数据劫持)</li>
<li>负责调用 <code>Compiler</code> 编译指令&#x2F;插值表达式等</li>
</ul>
</li>
<li>Observer<ul>
<li>数据劫持<ul>
<li>负责把 <code>data</code> 中的成员转换成 <code>getter/setter</code></li>
<li>负责把多层属性转换成 <code>getter/setter</code></li>
<li>如果给属性赋值为新对象，把新对象的成员设置为 <code>getter/setter</code></li>
</ul>
</li>
<li>添加 <code>Dep</code> 和 <code>Watcher</code> 的依赖关系</li>
<li>数据变化发送通知</li>
</ul>
</li>
<li>Compiler<ul>
<li>负责编译模板，解析指令&#x2F;插值表达式</li>
<li>负责页面的首次渲染过程</li>
<li>当数据变化后重新渲染</li>
</ul>
</li>
<li>Dep<ul>
<li>收集依赖，添加订阅者(<code>watcher</code>)</li>
<li>通知所有订阅者</li>
</ul>
</li>
<li>Watcher<ul>
<li>自身实例化的时候往<code>dep</code>对象中添加自己</li>
<li>当数据变化<code>dep</code>通知所有的 <code>Watcher</code> 实例更新视图</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3与Vue2API的区别</title>
    <url>/2021/09/02/Vue3%E4%B8%8EVue2API%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h4><ol>
<li><p>options API:</p>
<p>即选项式API，通过定义methods，data，computed，watch等属性与方法，共同处理页面逻辑。</p>
<p>一个功能的实现，需要不同的vue配置项，定义属相和方法比较分散。大项目可能包含多个方法，这可能会导致组件难以阅读和理解。</p>
</li>
</ol>
<span id="more"></span>

<p>   <a href="http://zslin.xyz/2021/06/09/vue3/vue3%E5%92%8Cvue2-API%E7%9A%84%E5%8C%BA%E5%88%AB/tt.png"><img src="http://zslin.xyz/2021/06/09/vue3/vue3%E5%92%8Cvue2-API%E7%9A%84%E5%8C%BA%E5%88%AB/tt.png" alt="img"></a></p>
<ol start="2">
<li><p>composition API:</p>
<p>一个功能的所有api都会放在一起，实现了高内聚，低耦合。方便找到功能所对应的方法及属性。</p>
<p>根据逻辑相关性组织代码，提高可读性和可维护性，基于函数组合的API。</p>
<p><a href="http://zslin.xyz/2021/06/09/vue3/vue3%E5%92%8Cvue2-API%E7%9A%84%E5%8C%BA%E5%88%AB/cc.png"><img src="http://zslin.xyz/2021/06/09/vue3/vue3%E5%92%8Cvue2-API%E7%9A%84%E5%8C%BA%E5%88%AB/cc.png" alt="img"></a></p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><hr>
<blockquote>
<ul>
<li><a href="https://vue3js.cn/interview/vue3/composition.html#%E6%AD%A3%E6%96%87">https://vue3js.cn/interview/vue3/composition.html#%E6%AD%A3%E6%96%87</a></li>
</ul>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3中Treeshaking</title>
    <url>/2021/07/27/Vue3%E4%B8%ADTreeshaking/</url>
    <content><![CDATA[<h4 id="说说Vue-3-0中Treeshaking特性？举例说明一下？"><a href="#说说Vue-3-0中Treeshaking特性？举例说明一下？" class="headerlink" title="说说Vue 3.0中Treeshaking特性？举例说明一下？"></a>说说Vue 3.0中Treeshaking特性？举例说明一下？</h4><p><a href="http://zslin.xyz/2021/07/27/vue3/vue3%E4%B8%ADTreeshaking%E7%89%B9%E6%80%A7/tt.png"><img src="http://zslin.xyz/2021/07/27/vue3/vue3%E4%B8%ADTreeshaking%E7%89%B9%E6%80%A7/tt.png" alt="img"></a></p>
<h5 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h5><p>Tree shaking是一种术语，在打包时将不打包没有用到的代码清除掉，这些代码会成为dead code（死代码）。也就是说，treeshaking在打包时所留下的，是我们用到的代码。</p>
<ul>
<li>在vue2中，无论我们使用什么功能，它们最终都会出现在打包后的文件中。因为vue2在项目中是单例的，无法检测到哪些代码在项目中是被用到的。</li>
<li>vue3引入了treeshaking特性，将全局api进行分块。如果没有使用到某个功能，他们将不会包含在你打包后的文件中。</li>
</ul>
<h5 id="如何做？"><a href="#如何做？" class="headerlink" title="如何做？"></a>如何做？</h5><p>Tree shaking是基于es6的模板语法import，exports静态编辑思想确定模块依赖关系的。</p>
<span id="more"></span>
<ul>
<li>treeshaking在编译阶段会判断模块的加载状态。</li>
<li>判断未使用的相关变量，进行移除。</li>
</ul>
<p>举个例子：<br>如果，新创建的项目中，data中的变量1，和变量2被使用了，但是变量3，并没有被使用，那么变量3，会在打包的时候被移除<br>在比如，可以对比一下项目在使用treeShaking打包之后和未使用的情况下进行打包后的大小，<br>data中的数据都被正常使用，methods的方法也被正常使用，component方法和watch方法未使用，然后进行打包<br>答案显而易见，在使用treeShaking后进行打包只会将data和methods这种使用的方法进行打包，而不是打包所有</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>减少程序体积（更小）</li>
<li>减少程序执行时间（更快）</li>
<li>便于维护优化项目框架</li>
</ul>
<h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr>
<blockquote>
<ul>
<li><a href="https://segmentfault.com/a/1190000038962700">https://segmentfault.com/a/1190000038962700</a></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><a href="https://vue3js.cn/interview/vue3/treeshaking.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88">https://vue3js.cn/interview/vue3/treeshaking.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3响应式改进</title>
    <url>/2021/09/25/Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E6%94%B9%E8%BF%9B/</url>
    <content><![CDATA[<h4 id="Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？"><a href="#Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？" class="headerlink" title="Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？"></a>Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</h4><p>proxy的性能本来比defindproerty好，proxy可以拦截属性的访问，赋值，删除等操作，不需要初始化的时候遍历所有属性。另外如果是多层嵌套的对象，只有访问某个属性的时候，才会递归处理下一级的属性。</p>
<p>object.defineproperty():</p>
<ul>
<li>检测不到对象属性的添加和删除 在这里可以使用set，delete方法。</li>
<li>不能根据数组索引来修改值</li>
<li>需要遍历每个属性进行遍历监听，如果是嵌套对象的话，就需要深层监听，造成性能问题。</li>
</ul>
<p>proxy：</p>
<ul>
<li>可以直接监听整个对象</li>
<li>可以直接监听数组的变化（push，shift，splice）</li>
<li>有多达13种拦截方法，不限于apply，has等等，是defindproerty不具备的</li>
<li>返回一个新的对象，只操作新的对象就能达到目的。</li>
</ul>
<h4 id="Proxy-API"><a href="#Proxy-API" class="headerlink" title="Proxy API"></a>Proxy API</h4><h5 id="get-target-propKey-receiver"><a href="#get-target-propKey-receiver" class="headerlink" title="get(target, propKey, receiver)"></a>get(target, propKey, receiver)</h5><blockquote>
<p>在我们代码案例中用到最多的拦截方法就是get和set了。</p>
<ul>
<li>get(target, propKey, receiver)方法用于拦截对象的属性读取，也就是说当我们通过Proxy的实例去访问对象的属性时会优先进入到get方法中。</li>
<li>get方法接收三个参数：target：要拦截的目标对象，propKey：目标对象中的属性， receiver（可选）：Proxy实例本身（严格的说应该是操作行为所针对的对象），第三个参数用到的场景很少，一般都是前两个参数比较多。</li>
<li>get方法是可以支持继承的。</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;Yannis&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj,&#123;</span><br><span class="line">	<span class="title function_">get</span>(<span class="params">target, key, receiver</span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;Hello &#x27;</span>+ target[key];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span>;</span><br><span class="line"><span class="comment">// &#123;name:&#x27;Yannis&#x27;&#125; target要拦截的对象</span></span><br><span class="line"><span class="comment">// name key：正在访问的对象的属性</span></span><br><span class="line"><span class="comment">// &#x27;Hello Yannis&#x27; 当我们访问对象属性时，拦截器自动加了个Hello前缀</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  get方法是可以支持继承</span></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;,&#123;</span><br><span class="line">	<span class="title function_">get</span>(<span class="params">target,key</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;Hello Proxy&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proxy);</span><br><span class="line">obj.<span class="property">name</span>;<span class="comment">//&#x27;Hello Proxy&#x27;</span></span><br><span class="line">obj.<span class="property">age</span>;<span class="comment">//&#x27;Hello Proxy&#x27;</span></span><br><span class="line"><span class="comment">//obj本身是没有这两个属性的，但由于继承了proxy，因此会走到proxy的get方法中，所以不管访问obj的什么属性，始终都会返回&#x27;Hello Proxy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  get方法的第三个参数</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;Yannis&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;,&#123;</span><br><span class="line">	<span class="title function_">get</span>(<span class="params">target, key, receiver</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> receiver;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.<span class="property">name</span> === proxy;<span class="comment">//true</span></span><br><span class="line"><span class="comment">//这里我们在get中直接返回了第三个参数，当通过proxy实例访问对象属性时，发现对象的属性跟proxy的实例是相等的。这也印证了第三个参数是Proxy实例本身这一说法</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h5 id="set-target-key-value"><a href="#set-target-key-value" class="headerlink" title="set(target, key, value)"></a>set(target, key, value)</h5><blockquote>
<p>Proxy的set方法也是比较常用的一个拦截方法。</p>
<ul>
<li>set方法主要是用来拦截对象属性的设置用的，即当我们通过Proxy实例给对象属性赋值时会进入到set拦截里。该方法返回一个布尔值</li>
<li>set方法接收4个参数，target：拦截的目标对象，propKey：目标对象的属性，value：要给目标属性设置的新值，receiver（可选）：Proxy实例本身</li>
<li>set方法大多用于对属性的合法校验或者添加一些额外的处理逻辑。</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假如Person对象有个age属性，那么年龄应该是一个数字，并且不能太大也不能太小，当用户输入年龄的时候我们就可以用set方法来进行拦截校验</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">age</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person,&#123;</span><br><span class="line">	<span class="title function_">set</span>(<span class="params">target,key,value</span>)&#123;</span><br><span class="line">		<span class="comment">//只对age属性进行处理</span></span><br><span class="line">		<span class="keyword">if</span>(key === <span class="string">&#x27;age&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="title class_">Number</span>.<span class="title function_">isInteget</span>(value))&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The age is not an integer&#x27;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(value&lt;=<span class="number">0</span> || value&gt;<span class="number">150</span>)&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;The age is incorrect&#x27;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		target[key] = value;<span class="comment">//将新值赋给target的key属性</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">person.<span class="property">age</span> = <span class="number">50</span>;<span class="comment">//true</span></span><br><span class="line">person.<span class="property">age</span>=<span class="string">&#x27;Yannis&#x27;</span>;<span class="comment">//报错</span></span><br><span class="line">person.<span class="property">age</span> = <span class="number">200</span>;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<h5 id="has-target-key"><a href="#has-target-key" class="headerlink" title="has(target, key)"></a>has(target, key)</h5><blockquote>
<p>has()方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<strong>in</strong>运算符。</p>
<ul>
<li>has方法接收两个参数：target：目标对象，key：需要查询的属性名，返回值为布尔类型</li>
<li>has方法拦截的是HasProperty操作而不是HasOwnProperty操作，也就是说has方法不判断一个属性是本身的属性还是继承来的属性</li>
<li>has方法拦截对for…in循环是不生效的</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 隐藏对象的某些属性不被in发现，比如带下划线的属性</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">_a</span>:<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">	<span class="attr">_b</span>:<span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">	<span class="attr">c</span>:<span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">	<span class="attr">d</span>:<span class="string">&#x27;d&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj,&#123;</span><br><span class="line">	<span class="title function_">has</span>(<span class="params">target,key</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;_a&#x27;</span> <span class="keyword">in</span> proxy;<span class="comment">//false</span></span><br><span class="line"><span class="string">&#x27;_b&#x27;</span> <span class="keyword">in</span> proxy;<span class="comment">//false</span></span><br><span class="line"><span class="string">&#x27;c&#x27;</span> <span class="keyword">in</span> proxy;<span class="comment">//true</span></span><br><span class="line"><span class="string">&#x27;d&#x27;</span> <span class="keyword">in</span> proxy;<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h5 id="ownKeys-target"><a href="#ownKeys-target" class="headerlink" title="ownKeys(target)"></a>ownKeys(target)</h5><blockquote>
<p>ownKeys方法跟has方法类似也是跟对象属性操作相关的，但是ownKeys是用来拦截获取对象属性的方法。它主要是拦截如下几个获取属性的方法：</p>
<ul>
<li>Object.getOwnPropertyNames(proxy)</li>
<li>Object.getOwnPropertySymbols(proxy)</li>
<li>Object.keys(proxy)</li>
<li>for…in循环</li>
<li>该方法返回一个数组。数组的元素为对象所有自身属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li>
<li>ownKeys方法只接收一个参数target，要拦截的目标对象</li>
</ul>
</blockquote>
<blockquote>
<p>另外需要注意的是：在使用Object.keys()方法是，有三类属性会被ownKeys方法自动过滤</p>
<ul>
<li>目标对象上不存在的属性</li>
<li>属性名为Symbol类型的值</li>
<li>不可遍历的属性（enumerable为false）</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//还是以隐藏对象的下划线属性为例</span></span><br><span class="line"><span class="keyword">let</span> obj= &#123;</span><br><span class="line">  <span class="attr">_a</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="attr">_b</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  <span class="attr">d</span>: <span class="string">&#x27;d&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">	 ownKeys (target) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target).<span class="title function_">filter</span>(<span class="function"><span class="params">key</span> =&gt;</span> key[<span class="number">0</span>] !== <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// d</span></span><br></pre></td></tr></table></figure>

<h5 id="deleteProperty-target-propKey"><a href="#deleteProperty-target-propKey" class="headerlink" title="deleteProperty(target, propKey)"></a>deleteProperty(target, propKey)</h5><blockquote>
<p>deleteProperty 方法用于拦截删除属性的操作，返回值为布尔类型。如果该方法抛出错误或者返回false，当前属性就无法被delete命令删除。</p>
<ul>
<li>该方法接收两个参数target：目标对象和propKey：对象对应的属性名</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//还是以对象的下划线属性为例</span></span><br><span class="line"><span class="keyword">let</span> obj= &#123;</span><br><span class="line">  <span class="attr">_a</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="attr">_b</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  <span class="attr">d</span>: <span class="string">&#x27;d&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">	 <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>)&#123;</span><br><span class="line">    		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Can not delete the private property&#x27;</span>)</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">delete</span> target[key]</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">delete</span> proxy[<span class="string">&#x27;c&#x27;</span>];<span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> proxy[<span class="string">&#x27;_a&#x27;</span>];<span class="comment">// Error: Can not delete the private property</span></span><br></pre></td></tr></table></figure>



<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><hr>
<blockquote>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><a href="https://vue3js.cn/interview/vue3/proxy.html#%E4%B8%80%E3%80%81object-defineproperty">https://vue3js.cn/interview/vue3/proxy.html#%E4%B8%80%E3%80%81object-defineproperty</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3性能提升</title>
    <url>/2021/09/21/Vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<h4 id="Vue3-0性能提升主要是通过哪几方面体现的？"><a href="#Vue3-0性能提升主要是通过哪几方面体现的？" class="headerlink" title="Vue3.0性能提升主要是通过哪几方面体现的？"></a>Vue3.0性能提升主要是通过哪几方面体现的？</h4><p><a href="http://zslin.xyz/2021/04/27/vue3/vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/tt.png"><img src="http://zslin.xyz/2021/04/27/vue3/vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/tt.png" alt="img"></a></p>
<h5 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h5><ul>
<li><p>diff算法优化</p>
<ul>
<li><p>vue3在diff算法中相比vue2增加了静态标记。作用：为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较即可。</p>
<p>下图这里，已经标记静态节点的p标签在diff过程中则不会比较，把性能进一步提高。</p>
</li>
</ul>
<p><a href="http://zslin.xyz/2021/04/27/vue3/vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/cc.png"><img src="http://zslin.xyz/2021/04/27/vue3/vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/cc.png" alt="img"></a></p>
</li>
<li><p>静态提升</p>
<ul>
<li>vue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用。</li>
</ul>
</li>
<li><p>事件监听缓存</p>
</li>
<li><p>SSR优化</p>
<ul>
<li>当静态内容达到一定量度时，会使用服务端渲染。</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h5 id="源码体积"><a href="#源码体积" class="headerlink" title="源码体积"></a>源码体积</h5><ul>
<li><p>相比vue2，vue3整体体积变小了，除了移除一些不常用的API，在重要的是<code>Tree shanking</code>(树摇)。比如任何一个函数（ref，reactived，computed）等，仅用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed, defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> age = <span class="title function_">ref</span>(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> readOnlyAge = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> age.<span class="property">value</span>++) <span class="comment">// 19</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            age,</span><br><span class="line">            state,</span><br><span class="line">            readOnlyAge</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h5><ul>
<li>vue2中采用defineProerty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式。</li>
<li>vue3采用proxy代理对象，因为proxy可以对整个对象进行监听，所以不需要深度遍历。<ul>
<li>可以监听整个对象的修改和添加</li>
<li>可以监听数组的索引和数组length属性。</li>
</ul>
</li>
</ul>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><hr>
<blockquote>
<ul>
<li><a href="https://juejin.cn/post/6903171037211557895">https://juejin.cn/post/6903171037211557895</a></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><a href="https://vue3js.cn/interview/vue3/performance.html#%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5">https://vue3js.cn/interview/vue3/performance.html#%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3系列面试</title>
    <url>/2021/08/19/Vue3%E7%B3%BB%E5%88%97%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h4 id="Vue3-0的设计目标是什么？做了哪些优化？"><a href="#Vue3-0的设计目标是什么？做了哪些优化？" class="headerlink" title="Vue3.0的设计目标是什么？做了哪些优化？"></a>Vue3.0的设计目标是什么？做了哪些优化？</h4><h5 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h5><ul>
<li>体积更小：<ul>
<li>vue3移除一些不常用的API，引入tree shaking，将一些无用的模块“剪辑掉”。仅打包需要的模块。使打包体积变小了。</li>
</ul>
</li>
<li>更快：<ul>
<li>diff算法优化：</li>
<li>静态提升</li>
<li>事件缓存机制</li>
<li>ssr优化</li>
</ul>
</li>
<li>更友好：<ul>
<li>vue3推出了composition API，大大增加了代码的组织能力和复用能力。</li>
</ul>
</li>
</ul>
<h5 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h5><span id="more"></span>
<ul>
<li>源码<ul>
<li>源码管理，体积更小</li>
<li>使用ts，提供类型检查</li>
</ul>
</li>
<li>性能<ul>
<li>体积优化</li>
<li>编译优化</li>
<li>数据劫持优化</li>
</ul>
</li>
<li>语法API<ul>
<li>组合式API，主要提高了代码的组织和复用能力</li>
</ul>
</li>
</ul>
<h4 id="Vue3-0性能提升主要是通过哪几方面体现的？"><a href="#Vue3-0性能提升主要是通过哪几方面体现的？" class="headerlink" title="Vue3.0性能提升主要是通过哪几方面体现的？"></a>Vue3.0性能提升主要是通过哪几方面体现的？</h4><ul>
<li>编译阶段<ul>
<li>diff算法优化：比vue2增加了静态标记，在发生改变的地方做一个flag标记，下次发生改变可以直接找到该地方进行比较。</li>
<li>静态提升： vue3对不参与更新的元素，会做静态提升，只创建一次，可以复用渲染。免去重复创建节点，优化了运行时的内存。</li>
<li>事件缓存机制</li>
<li>SSR优化： 当内容达到一定量的时候，采用服务端渲染。</li>
</ul>
</li>
<li>源码体积<ul>
<li>相对于vue2来说体积变小了，去除一些不常用API。使用树摇（tree shaking），只打包需要的模块，打包体积变小了</li>
</ul>
</li>
<li>响应式系统<ul>
<li>vue2采用object.proerty（）劫持整个对象，深度遍历每个属性，给每个属性添加getter，setter，来实现响应式。</li>
<li>vue3使用了vue3代理对象，可以对整个对象进行监听，不需要深度遍历。</li>
<li>可以监听整个对象以及属性的修改和删除，可以监听数组的索引和lenght属性。</li>
</ul>
</li>
</ul>
<h4 id="Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？"><a href="#Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？" class="headerlink" title="Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？"></a>Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</h4><ul>
<li>defineProerty API：<ul>
<li>检测不到对象属性的添加和删除， 提供了set，和delete方法。</li>
<li>数组的方法 无法监听到（push，shift）</li>
<li>需要对每个属性进行监听，如果是嵌套对象的话，需使用深度监听，可能会造成性能问题。</li>
</ul>
</li>
<li>Proxy：<ul>
<li>object.definproerty 只能遍历对象属性进行劫持，proxy直接监听整个对象。</li>
<li>返回一个新对象，只需操作新对象就能达到目的。</li>
<li>proxy有多达13种监听方法，不限于apply，has等，这是object.defineproerty（）不具备的</li>
<li>可以直接监听数组的变化（push，shift，splice）</li>
</ul>
</li>
</ul>
<h4 id="Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h4><ul>
<li>Options API:<ul>
<li>通过定义data，methods，computed等方法和属性，来共同处理页面逻辑，一个功能的实现，需要不同的位置的方法和属性，比较分散。可能会造成组件的难以理解和维护。</li>
</ul>
</li>
<li>Composition API:<ul>
<li>所有方法和功能都写在setup当中，将一个功能的所有方法，属性放在一起。（高内聚，低耦合）。根据相关逻辑来组织代码，提高代码的可读性和维护性。（当功能增多时，还可使用hook来封装出去）</li>
<li>组合式API中见不到this的使用，减少this指向不明的问题。</li>
<li>组合式API几乎都是函数，会有很好的类型判断。</li>
</ul>
</li>
</ul>
<h4 id="说说Vue-3-0中Treeshaking特性？举例说明一下？"><a href="#说说Vue-3-0中Treeshaking特性？举例说明一下？" class="headerlink" title="说说Vue 3.0中Treeshaking特性？举例说明一下？"></a>说说Vue 3.0中Treeshaking特性？举例说明一下？</h4><h5 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h5><p>Tree shaking是一种术语，在打包时不打包没有用到的模块，减小了打包体积。</p>
<h5 id="如何做？"><a href="#如何做？" class="headerlink" title="如何做？"></a>如何做？</h5><p>Tree shaking是基于es6的 <code>import</code> 和 <code>exports</code> 静态编程思想来确定模块的依赖关系。</p>
<ul>
<li>tree shaking会在编译阶段判断模块的加载状态</li>
<li>判断未使用的变量，进行移除。</li>
</ul>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>减小打包体积</li>
<li>减少程序打包的时间</li>
<li>便于维护优化项目框架</li>
</ul>
<h4 id="用Vue3-0-写过组件吗？如果想实现一个-Modal你会怎么设计？"><a href="#用Vue3-0-写过组件吗？如果想实现一个-Modal你会怎么设计？" class="headerlink" title="用Vue3.0 写过组件吗？如果想实现一个 Modal你会怎么设计？"></a>用Vue3.0 写过组件吗？如果想实现一个 Modal你会怎么设计？</h4><p>首先要考虑，大致实现的思路，根据ui设计图，确定好主体的内容，布局样式，做的那些交互操作，删除，修改等等。定义API方法来进行开发。</p>
]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
        <tag>前端面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3设计目标及优化</title>
    <url>/2021/09/06/Vue3%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h4 id="vue3-0的设计目标是什么？做了那些优化？"><a href="#vue3-0的设计目标是什么？做了那些优化？" class="headerlink" title="vue3.0的设计目标是什么？做了那些优化？"></a>vue3.0的设计目标是什么？做了那些优化？</h4><p>设计目标：</p>
<ul>
<li>打包体积更小： vue3移除一些不常用的API，将无用的模块“剪辑”掉，仅打包需要的，使打包体积更小了。</li>
<li>速度更快： diff算法优化，静态提升。</li>
<li>更灵活的代码组织能力： 推出composition API，大大增加了代码的逻辑组织能力和代码复用能力。</li>
</ul>
<p>优化方案：</p>
<span id="more"></span>
<ul>
<li><p>源码</p>
<ul>
<li>使用ts语法，源码的优化。</li>
</ul>
</li>
<li><p>性能</p>
<ul>
<li>体积，编译，数据劫持优化。</li>
</ul>
</li>
<li><p>语法 API</p>
<ul>
<li>组合式API，根据相关逻辑组织代码。</li>
</ul>
<p><a href="http://zslin.xyz/2021/06/06/vue3/vue3-0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BC%98%E5%8C%96/tt.png"><img src="http://zslin.xyz/2021/06/06/vue3/vue3-0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BC%98%E5%8C%96/tt.png" alt="img"></a></p>
</li>
</ul>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h4><hr>
<blockquote>
<ul>
<li><a href="https://juejin.cn/post/6850418112878575629#heading-5">https://juejin.cn/post/6850418112878575629#heading-5</a></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><a href="https://vue3js.cn/docs/zh">https://vue3js.cn/docs/zh</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue插槽</title>
    <url>/2020/07/23/Vue%E6%8F%92%E6%A7%BD/</url>
    <content><![CDATA[<h3 id="Vue插槽"><a href="#Vue插槽" class="headerlink" title="Vue插槽"></a>Vue插槽</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件</strong> 。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>默认插槽、具名插槽、作用域插槽</p>
<h4 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        <span class="tag">&lt;<span class="name">Category</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span>&gt;</span>html结构1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br><span class="line">子组件中：</span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 定义插槽 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">slot</span>&gt;</span>插槽默认内容...<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        <span class="tag">&lt;<span class="name">Category</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">div</span>&gt;</span>html结构1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">div</span>&gt;</span>html结构2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br><span class="line">子组件中：</span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 定义插槽 --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;center&quot;</span>&gt;</span>插槽默认内容...<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>插槽默认内容...<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line"> 		<span class="tag">&lt;<span class="name">Category</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">template</span> <span class="attr">scope</span>=<span class="string">&quot;scopeData&quot;</span>&gt;</span></span><br><span class="line"> 				<span class="comment">&lt;!-- 生成的是ul列表 --&gt;</span></span><br><span class="line"> 				<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"> 					<span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;g in scopeData.games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;g&quot;</span>&gt;</span>&#123;&#123;g&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> 				<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> 		<span class="tag">&lt;<span class="name">Category</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;scopeData&quot;</span>&gt;</span></span><br><span class="line"> 				<span class="comment">&lt;!-- 生成的是h4标题 --&gt;</span></span><br><span class="line"> 				<span class="tag">&lt;<span class="name">h4</span> <span class="attr">v-for</span>=<span class="string">&quot;g in scopeData.games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;g&quot;</span>&gt;</span>&#123;&#123;g&#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br><span class="line"> 子组件中：</span><br><span class="line">         <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:games</span>=<span class="string">&quot;games&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> 		</span><br><span class="line">         <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">             <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                 <span class="attr">name</span>:<span class="string">&#x27;Category&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                 <span class="attr">props</span>:[<span class="string">&#x27;title&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">                 <span class="comment">//数据在子组件自身</span></span></span><br><span class="line"><span class="language-javascript">                 <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                     <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                         <span class="attr">games</span>:[<span class="string">&#x27;红色警戒&#x27;</span>,<span class="string">&#x27;穿越火线&#x27;</span>,<span class="string">&#x27;劲舞团&#x27;</span>,<span class="string">&#x27;超级玛丽&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">                     &#125;</span></span><br><span class="line"><span class="language-javascript">                 &#125;,</span></span><br><span class="line"><span class="language-javascript">             &#125;</span></span><br><span class="line"><span class="language-javascript">         </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue生命周期的理解</title>
    <url>/2019/03/28/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="vue生命周期的理解"><a href="#vue生命周期的理解" class="headerlink" title="vue生命周期的理解"></a><strong>vue生命周期的理解</strong></h4><p>vue生命周期主要分为8个阶段：创建前&#x2F;后，载入前&#x2F;后，更新前&#x2F;后，销毁前&#x2F;后。</p>
<p>vue实例有一个完整的生命周期，也就是从开始创建，初始化数据，编译模板，挂载Dom &#x3D;&gt; 渲染，更新 &#x3D;&gt; 渲染，卸载这个过程。</p>
<table>
<thead>
<tr>
<th align="left">beforeCreate</th>
<th>组件实例被创建之初，组件的属性生效之前</th>
</tr>
</thead>
<tbody><tr>
<td align="left">created</td>
<td>组件实例已经完全创建，属性也绑定，但真实dom还没有生成，$el还不可用</td>
</tr>
<tr>
<td align="left">beforeMount</td>
<td>在挂载开始之前被调用：相关的 render 函数首次被调用</td>
</tr>
<tr>
<td align="left">mounted</td>
<td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td>
</tr>
<tr>
<td align="left">beforeUpdate</td>
<td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td>
</tr>
<tr>
<td align="left">update</td>
<td>组件数据更新之后</td>
</tr>
<tr>
<td align="left">activated</td>
<td>keep-alive专属，组件被激活时调用</td>
</tr>
<tr>
<td align="left">deactivated</td>
<td>keep-alive专属，组件被销毁时调用</td>
</tr>
<tr>
<td align="left">beforeDestroy</td>
<td>组件销毁前调用</td>
</tr>
<tr>
<td align="left">destroyed</td>
<td>组件销毁后调用</td>
</tr>
</tbody></table>
<p><a href="http://zslin.xyz/2019/06/27/vue2/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3/61.png"><img src="http://zslin.xyz/2019/06/27/vue2/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3/61.png" alt="img"></a></p>
<p><strong>什么是vue生命周期？</strong></p>
<ul>
<li>答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。</li>
</ul>
<p><strong>vue生命周期的作用是什么？</strong></p>
<ul>
<li>答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</li>
</ul>
<p><strong>vue生命周期总共有几个阶段？</strong></p>
<ul>
<li>答：它可以总共分为<code>8</code>个阶段：创建前&#x2F;后、载入前&#x2F;后、更新前&#x2F;后、销毁前&#x2F;销毁后。</li>
</ul>
<p><strong>第一次页面加载会触发哪几个钩子？</strong></p>
<ul>
<li>答：会触发下面这几个<code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code> 。</li>
</ul>
<p><strong>DOM 渲染在哪个周期中就已经完成？</strong></p>
<ul>
<li>答：<code>DOM</code> 渲染在 <code>mounted</code> 中就已经完成了</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue路由原理</title>
    <url>/2019/11/12/Vue%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h4 id="vue路由原理"><a href="#vue路由原理" class="headerlink" title="vue路由原理"></a>vue路由原理</h4><ul>
<li>hash模式：浏ener器中符号<code>#</code>，后面的字符称之为<code>hash</code>。<ul>
<li>其中对象中的<code>location.hash</code>储存的是路由的地址，可以赋值改变其URL的地址。而这会触发<code>hashchange</code>事件，通过<code>window.addEventListn</code>监听hash值然后去匹配对应的路由，从而渲染页面的组件。</li>
</ul>
</li>
<li>history：<ul>
<li>history采用HTML5的新特性，通过<code>pushState</code>和<code>replaceState</code>两个方法来实现url的变化。可以通过<code>popstagte</code>事件监听url的变化，从而对页面进行跳转（渲染）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack中Proxy工作原理</title>
    <url>/2019/04/12/Webpack%E4%B8%ADProxy%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h4 id="Webpack-Proxy工作原理？为什么能解决跨域？"><a href="#Webpack-Proxy工作原理？为什么能解决跨域？" class="headerlink" title="Webpack Proxy工作原理？为什么能解决跨域？"></a>Webpack Proxy工作原理？为什么能解决跨域？</h4><h5 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1. 是什么"></a><strong>1. 是什么</strong></h5><p><code>webpack proxy</code>，即<code>webpack</code>提供的代理服务</p>
<p>基本行为就是接收客户端发送的请求后转发给其他服务器</p>
<p>其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）</p>
<p>想要实现代理首先需要一个中间服务器，<code>webpack</code>中提供服务器的工具为<code>webpack-dev-server</code></p>
<h5 id="2-webpack-dev-server"><a href="#2-webpack-dev-server" class="headerlink" title="2. webpack-dev-server"></a><strong>2. webpack-dev-server</strong></h5><span id="more"></span>
<p><code>webpack-dev-server</code>是 <code>webpack</code> 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起</p>
<p>目的是为了提高开发者日常的开发效率，「只适用在开发阶段」</p>
<p>关于配置方面，在<code>webpack</code>配置对象属性中通过<code>devServer</code>属性提供，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">contentBase</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&#x27;https://api.github.com&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>devServetr</code>里面<code>proxy</code>则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配</p>
<p>属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为<code>/api</code>，值为对应的代理匹配规则，对应如下：</p>
<ul>
<li><code>target</code>：表示的是代理到的目标地址</li>
<li><code>pathRewrite</code>：默认情况下，我们的 <code>/api-hy</code> 也会被写入到URL中，如果希望删除，可以使用<code>pathRewrite</code></li>
<li><code>secure</code>：默认情况下不接收转发到<code>https</code>的服务器上，如果希望支持，可以设置为<code>false</code></li>
<li><code>changeOrigin</code>：它表示是否更新代理后请求的 <code>headers</code> 中<code>host</code>地址</li>
</ul>
<p><strong>2. 工作原理</strong></p>
<blockquote>
<p><code>proxy</code>工作原理实质上是利用<code>http-proxy-middleware</code> 这个<code>http</code>代理中间件，实现请求转发给其他服务器</p>
</blockquote>
<p>举个例子：</p>
<p>在开发阶段，本地地址为<code>http://localhost:3000</code>，该浏览器发送一个前缀带有<code>/api</code>标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, <span class="title function_">proxy</span>(&#123;<span class="attr">target</span>: <span class="string">&#x27;http://www.example.org&#x27;</span>, <span class="attr">changeOrigin</span>: <span class="literal">true</span>&#125;));</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://localhost:3000/api/foo/bar -&gt; http://www.example.org/api/foo/bar</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-跨域"><a href="#3-跨域" class="headerlink" title="3. 跨域"></a><strong>3. 跨域</strong></h5><blockquote>
<p>在开发阶段， <code>webpack-dev-server</code> 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 <code>localhost</code>的一个端口上，而后端服务又是运行在另外一个地址上</p>
</blockquote>
<p>所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题</p>
<p>通过设置<code>webpack proxy</code>实现代理请求后，相当于浏览器与服务端中添加一个代理者</p>
<p>当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地</p>
<p><img src="https://cdn.jsdelivr.net/gh/yinlifan/img/20220805175333.png"></p>
<p>在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据</p>
<blockquote>
<p>注意：<code>「服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制」</code></p>
</blockquote>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack中的Plugin</title>
    <url>/2019/08/23/Webpack%E4%B8%AD%E7%9A%84Plugin/</url>
    <content><![CDATA[<h4 id="介绍webpack中的plugin？"><a href="#介绍webpack中的plugin？" class="headerlink" title="介绍webpack中的plugin？"></a>介绍webpack中的plugin？</h4><p>plugin是插件，对于webpack本身的扩展，是一个扩展器。</p>
<p>配置方式：写在plugins属性中传入new实例对象，他是个数组，可以写多个插件。</p>
<ul>
<li>UglifyJsPlugin: 压缩、混淆代码；</li>
<li>CommonsChunkPlugin: 代码分割；</li>
<li>ProvidePlugin: 自动加载模块；</li>
<li>html-webpack-plugin: 加载 html 文件，并引入 css &#x2F; js 文件；</li>
<li>extract-text-webpack-plugin &#x2F; mini-css-extract-plugin: 抽离样式，生成 css 文件； DefinePlugin: 定义全局变量；</li>
<li>optimize-css-assets-webpack-plugin: CSS 代码去重；</li>
<li>webpack-bundle-analyzer: 代码分析；</li>
<li>compression-webpack-plugin: 使用 gzip 压缩 js 和 css；</li>
<li>happypack: 使用多进程，加速代码构建；</li>
<li>EnvironmentPlugin: 定义环境变量；</li>
</ul>
<h5 id="下面介绍几个常用的插件用法："><a href="#下面介绍几个常用的插件用法：" class="headerlink" title="下面介绍几个常用的插件用法："></a>下面介绍几个常用的插件用法：</h5><span id="more"></span>
<ul>
<li>HtmlWebpackPlugin<ul>
<li>⾃动生成⼀个 <code>html</code> ⽂文件，并把打包生成的<code>js</code> 模块引⼊到该 <code>html</code> 中</li>
</ul>
</li>
<li>clean-webpack-plugin<ul>
<li>删除（清理）构建目录</li>
</ul>
</li>
<li>mini-css-extract-plugin<ul>
<li>提取css到一个单独文件中</li>
</ul>
</li>
<li>copy-webpack-plugin<ul>
<li>复制文件或目录到执行区域。</li>
</ul>
</li>
</ul>
<h5 id="loader和plugin的区别？"><a href="#loader和plugin的区别？" class="headerlink" title="loader和plugin的区别？"></a>loader和plugin的区别？</h5><ul>
<li>对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程。</li>
<li>plugin是一个插件，在webpack中相当于一个扩展器。是对现有webpack功能的一个扩展。针对于loader结束后，在webpack打包过程中并不是直接进行操作的，而是遵循事件机制工作的。会监听webpack打包过程中的某些节点，执行广泛的任务。</li>
</ul>
<h5 id="一个最简单的-plugin-是这样的"><a href="#一个最简单的-plugin-是这样的" class="headerlink" title="一个最简单的 plugin 是这样的:"></a><strong>一个最简单的 plugin 是这样的:</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plugin</span>&#123;</span><br><span class="line">  	<span class="comment">// 注册插件时，会调用 apply 方法</span></span><br><span class="line">  	<span class="comment">// apply 方法接收 compiler 对象</span></span><br><span class="line">  	<span class="comment">// 通过 compiler 上提供的 Api，可以对事件进行监听，执行相应的操作</span></span><br><span class="line">  	<span class="title function_">apply</span>(<span class="params">compiler</span>)&#123;</span><br><span class="line">  		<span class="comment">// compilation 是监听每次编译循环</span></span><br><span class="line">  		<span class="comment">// 每次文件变化，都会生成新的 compilation 对象并触发该事件</span></span><br><span class="line">    	compiler.<span class="title function_">plugin</span>(<span class="string">&#x27;compilation&#x27;</span>,<span class="keyword">function</span>(<span class="params">compilation</span>) &#123;&#125;)</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注册插件:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">export</span> = &#123;</span><br><span class="line">	<span class="attr">plugins</span>:[</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Plugin</span>(options),</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr>
<blockquote>
<ul>
<li><a href="https://interview2.poetries.top/docs/simply.html#_3-%E4%BB%8B%E7%BB%8D-plugin">https://interview2.poetries.top/docs/simply.html#_3-%E4%BB%8B%E7%BB%8D-plugin</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack中的Loader</title>
    <url>/2019/08/24/Webpack%E4%B8%AD%E7%9A%84Loader/</url>
    <content><![CDATA[<h4 id="介绍webpack中的loader？"><a href="#介绍webpack中的loader？" class="headerlink" title="介绍webpack中的loader？"></a>介绍webpack中的loader？</h4><p>webpack默认情况下，只支持对js，json文件打包。像css，less，png图片啊这些类型文件，webpack需要采用相对应的loader（模块加载器）进行解析转换。</p>
<h5 id="loader配置（module-rules）："><a href="#loader配置（module-rules）：" class="headerlink" title="loader配置（module.rules）："></a>loader配置（module.rules）：</h5><ul>
<li>rules是一个数组的形式，因此我们可以配置多个loader。</li>
<li>每一个loader对应一个对象形式，属性test为匹配的规则，一般情况下为正则表达式。</li>
<li>属性use针对匹配到文件类型，调用对应的loader进行处理。</li>
</ul>
<h5 id="常见的loader："><a href="#常见的loader：" class="headerlink" title="常见的loader："></a>常见的loader：</h5><span id="more"></span>
<ul>
<li>style-loader：将css添加到dom的内联样式标签style中。</li>
<li>css-loader： 允许css文件通过import和url,引用css文件对应的资源。</li>
<li>sass-loader &#x2F; less-loader：css预处理器，提高了开发效率。</li>
<li>babel-loader： 用babel将es6&#x2F;es7 代码转换成es5。</li>
<li>file-loader： 加载文件资源，如 字体&#x2F;图片 等。</li>
<li>url-loader：对于图片格式的模块，可以选择性的把图片转成base64格式的字符串，并打包到js中，对小体积的图片比较合适，大图片不合适。</li>
</ul>
<h5 id="编写原则"><a href="#编写原则" class="headerlink" title="编写原则:"></a><strong>编写原则:</strong></h5><ul>
<li>单一原则: 每个 Loader 只做一件事；</li>
<li>链式调用: Webpack 会按顺序链式调用每个 Loader；</li>
<li>统一原则: 遵循 Webpack制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用；</li>
</ul>
<h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr>
<blockquote>
<ul>
<li><a href="https://interview2.poetries.top/docs/simply.html#_2-%E4%BB%8B%E7%BB%8D-loader">https://interview2.poetries.top/docs/simply.html#_2-%E4%BB%8B%E7%BB%8D-loader</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>Loader</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack层面的性能优化</title>
    <url>/2019/08/19/Webpack%E5%B1%82%E9%9D%A2%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h4 id="webpack-层面如何做性能优化"><a href="#webpack-层面如何做性能优化" class="headerlink" title="webpack 层面如何做性能优化"></a>webpack 层面如何做性能优化</h4><h5 id="优化前的准备工作"><a href="#优化前的准备工作" class="headerlink" title="优化前的准备工作"></a>优化前的准备工作</h5><p>准备基于时间的分析工具：我们需要一类插件，来帮助我们统计项目构建过程中在编译阶段的耗时情况。speed-measure-webpack-plugin 分析插件加载的时间<br>使用 webpack-bundle-analyzer 分析产物内容<br>代码优化:</p>
<blockquote>
<p>无用代码消除，是许多编程语言都具有的优化手段，这个过程称为 DCE (dead code elimination)，即 删除不可能执行的代码；</p>
</blockquote>
<p>例如我们的 UglifyJs，它就会帮我们在生产环境中删除不可能被执行的代码，例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 下面代码便属于 不可能执行的代码；</span></span><br><span class="line">	<span class="comment">// 通过 UglifyJs (Webpack4+ 已内置) 便会进行 DCE；</span></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<blockquote>
<p>摇树优化 (Tree-shaking)，这是一种形象比喻。我们把打包后的代码比喻成一棵树，这里其实表示的就是，通过工具 “摇” 我们打包后的 js 代码，将没有使用到的无用代码 “摇” 下来 (删除)。即 消除那些被 引用了但未被使用 的模块代码。</p>
</blockquote>
<ul>
<li>原理: 由于是在编译时优化，因此最基本的前提就是语法的静态分析，ES6的模块机制 提供了这种可能性。不需要运行时，便可进行代码字面上的静态分析，确定相应的依赖关系。</li>
<li>问题: 具有 副作用 的函数无法被tree-shaking<ul>
<li>在引用一些第三方库，需要去观察其引入的代码量是不是符合预期；</li>
<li>尽量写纯函数，减少函数的副作用；</li>
<li>可使用 <code>webpack-deep-scope-plugin</code>，可以进行作用域分析，减少此类情况的发生，但仍需要注意；</li>
</ul>
</li>
</ul>
<p><strong>code-spliting: 代码分割技术</strong>，将代码分割成多份进行 懒加载 或 异步加载，避免打包成一份后导致体积过大，影响页面的首屏加载；</p>
<ul>
<li><code>Webpack</code> 中使用 <code>SplitChunksPlugin</code> 进行拆分；</li>
<li>按 页面 拆分: 不同页面打包成不同的文件；</li>
<li>按 功能 拆分:<ul>
<li>将类似于播放器，计算库等大模块进行拆分后再懒加载引入；</li>
<li>提取复用的业务代码，减少冗余代码；</li>
</ul>
</li>
<li>按 文件修改频率 拆分: 将第三方库等不常修改的代码单独打包，而且不改变其文件 hash 值，能最大化运用浏览器的缓存；</li>
</ul>
<p><strong>scope hoisting</strong>: 作用域提升，将分散的模块划分到同一个作用域中，避免了代码的重复引入，有效减少打包后的代码体积和运行时的内存损耗；</p>
<h5 id="编译性能优化"><a href="#编译性能优化" class="headerlink" title="编译性能优化:"></a>编译性能优化:</h5><ul>
<li>升级至 最新 版本的 <code>webpack</code>，能有效提升编译性能；</li>
<li>使用 <code>dev-server</code> &#x2F; 模块热替换 (<code>HMR</code>) 提升开发体验；</li>
<li>监听文件变动 忽略 node_modules 目录能有效提高监听时的编译效率；</li>
<li>缩小编译范围<ul>
<li><code>modules</code>: 指定模块路径，减少递归搜索；</li>
<li><code>mainFields</code>: 指定入口文件描述字段，减少搜索；</li>
<li><code>noParse</code>: 避免对非模块化文件的加载；</li>
<li><code>includes/exclude</code>: 指定搜索范围&#x2F;排除不必要的搜索范围；</li>
<li><code>alias</code>: 缓存目录，避免重复寻址；</li>
</ul>
</li>
<li>babel-loader<ul>
<li>忽略<code>node_moudles</code>，避免编译第三方库中已经被编译过的代码</li>
<li>使用<code>cacheDirectory</code>，可以缓存编译结果，避免多次重复编译</li>
</ul>
</li>
<li>多进程并发<ul>
<li><code>webpack-parallel-uglify-plugin</code>: 可多进程并发压缩 js 文件，提高压缩速度；</li>
<li><code>HappyPack</code>: 多进程并发文件的 <code>Loader</code> 解析；</li>
</ul>
</li>
<li>第三方库模块缓存:<ul>
<li><code>DLLPlugin</code> 和 <code>DLLReferencePlugin</code> 可以提前进行打包并缓存，避免每次都重新编译；</li>
</ul>
</li>
<li>使用分析<ul>
<li><code>Webpack Analyse / webpack-bundle-analyzer</code> 对打包后的文件进行分析，寻找可优化的地方</li>
<li>配置profile：true，对各个编译阶段耗时进行监控，寻找耗时最多的地方</li>
</ul>
</li>
<li>source-map:<ul>
<li>开发: <code>cheap-module-eval-source-map</code></li>
<li>生产: <code>hidden-source-map</code>；</li>
</ul>
</li>
</ul>
<h5 id="优化webpack打包速度"><a href="#优化webpack打包速度" class="headerlink" title="优化webpack打包速度"></a>优化webpack打包速度</h5><ul>
<li>减少文件搜索范围<ul>
<li>比如通过别名</li>
<li><code>loader</code> 的 <code>test</code>，<code>include &amp; exclude</code></li>
</ul>
</li>
<li><code>Webpack4</code> 默认压缩并行</li>
<li><code>Happypack</code> 并发调用</li>
<li><code>babel</code> 也可以缓存编译</li>
<li><code>Resolve</code> 在构建时指定查找模块文件的规则</li>
<li>使用<code>DllPlugin</code>，不用每次都重新构建</li>
<li><code>externals</code> 和 <code>DllPlugin</code> 解决的是同一类问题：将依赖的框架等模块从构建过程中移除。它们的区别在于</li>
<li>在 Webpack 的配置方面，<code>externals</code> 更简单，而 <code>DllPlugin</code> 需要独立的配置文件。</li>
<li><code>DllPlugin</code> 包含了依赖包的独立构建流程，而 <code>externals</code> 配置中不包含依赖框架的生成方式，通常使用已传入 CDN 的依赖包</li>
<li><code>externals</code> 配置的依赖包需要单独指定依赖模块的加载方式：全局对象、CommonJS、AMD 等</li>
<li>在引用依赖包的子模块时，<code>DllPlugin</code> 无须更改，而 <code>externals</code> 则会将子模块打入项目包中</li>
</ul>
<h5 id="优化打包体积"><a href="#优化打包体积" class="headerlink" title="优化打包体积"></a>优化打包体积</h5><ul>
<li>提取第三方库或通过引用外部文件的方式引入第三方库</li>
<li>代码压缩插件<code>UglifyJsPlugin</code></li>
<li>服务器启用<code>gzip</code>压缩</li>
<li>按需加载资源文件 <code>require.ensure</code></li>
<li>优化<code>devtool</code>中的<code>source-map</code></li>
<li>剥离<code>css</code>文件，单独打包</li>
<li>去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致</li>
<li><code>Tree Shaking</code> 在构建打包过程中，移除那些引入但未被使用的无效代码</li>
<li>开启scope hosting<ul>
<li>体积更小</li>
<li>创建函数作用域更小</li>
<li>代码可读性更好</li>
</ul>
</li>
</ul>
<p><a href="http://zslin.xyz/2019/04/06/webpack/webpack%E5%B1%82%E9%9D%A2%E5%A6%82%E4%BD%95%E5%81%9A%E4%BC%98%E5%8C%96/tt.png"><img src="http://zslin.xyz/2019/04/06/webpack/webpack%E5%B1%82%E9%9D%A2%E5%A6%82%E4%BD%95%E5%81%9A%E4%BC%98%E5%8C%96/tt.png" alt="img"></a></p>
<p><a href="http://zslin.xyz/2019/04/06/webpack/webpack%E5%B1%82%E9%9D%A2%E5%A6%82%E4%BD%95%E5%81%9A%E4%BC%98%E5%8C%96/oo.png"><img src="http://zslin.xyz/2019/04/06/webpack/webpack%E5%B1%82%E9%9D%A2%E5%A6%82%E4%BD%95%E5%81%9A%E4%BC%98%E5%8C%96/oo.png" alt="img"></a></p>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack构建流程</title>
    <url>/2019/08/20/Webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="介绍一下-webpack-的构建流程"><a href="#介绍一下-webpack-的构建流程" class="headerlink" title="介绍一下 webpack 的构建流程"></a>介绍一下 webpack 的构建流程</h4><h5 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a><strong>核心概念</strong></h5><ul>
<li><code>entry</code>：入口配置。webpack从入口开始根据模块间依赖关系递归解析和处理所有资源文件。</li>
<li><code>output</code>：出口配置。经打包后的文件写入的位置。</li>
<li><code>loader</code>：模块转换器。纯文件转换。因为webpack默认只认识js，json文件。</li>
<li><code>plugin</code>：扩展插件。插件可以扩展 Webpack 的功能。</li>
<li><code>module</code>：模块。除了js范畴内的<code>es module、commonJs、AMD</code>等，<code>css @import、url(...)</code>、图片、字体等在webpack中都被视为模块。</li>
</ul>
<h5 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h5><span id="more"></span>
<ul>
<li>初始化参数：从配置文件和 Shell 语句中读取并合并参数，得出最终的配置参数。</li>
<li>开始编译：从上一步得到的参数初始化 <code>Compiler</code> 对象，加载所有配置的插件，执行对象的 <code>run</code> 方法开始执行编译。</li>
<li>确定入口：根scope据配置中的 <code>entry</code> 找出所有的入口文件。</li>
<li>编译模块：从入口文件出发，调用所有配置的 <code>loader</code> 对模块进行翻译，再找出该模块依赖的模块，这个步骤是递归执行的，直至所有入口依赖的模块文件都经过本步骤的处理。</li>
<li>完成模块编译：经过第 4 步使用 loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。</li>
<li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>chunk</code>，再把每个 <code>chunk</code> 转换成一个单独的文件加入到输出列表，这一步是可以修改输出内容的最后机会。</li>
<li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li>
</ul>
<p><a href="http://zslin.xyz/2019/03/28/webpack/webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/tt.png"><img src="http://zslin.xyz/2019/03/28/webpack/webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/tt.png" alt="img"></a></p>
<p>从配置文件中读取所需要的参数，初始化compiler对象，并且加载所有的插件，执行run方法开始编译。找到entry入口文件。调用loader对模板进行递归解析翻译。等确定每个模块的依赖关系后，将他们组装成一个个包含多个模块的chunk。确定好内容后，根据出口配置将打包后的文件写入到具体位置。</p>
<h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr>
<blockquote>
<ul>
<li><a href="https://interview2.poetries.top/docs/simply.html#_10-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BC%98%E5%8C%96">https://interview2.poetries.top/docs/simply.html#_10-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BC%98%E5%8C%96</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack热更新原理</title>
    <url>/2019/08/15/Webpack%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><a href="http://zslin.xyz/2019/04/04/webpack/webpack%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/rr.png"><img src="http://zslin.xyz/2019/04/04/webpack/webpack%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/rr.png" alt="img"></a></p>
<h5 id="HMR-的基本流程图"><a href="#HMR-的基本流程图" class="headerlink" title="HMR 的基本流程图"></a><strong>HMR 的基本流程图</strong></h5><p><a href="http://zslin.xyz/2019/04/04/webpack/webpack%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/tt.png"><img src="http://zslin.xyz/2019/04/04/webpack/webpack%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86/tt.png" alt="img"></a></p>
<span id="more"></span>
<ul>
<li>当修改了一个或多个文件；</li>
<li>文件系统接收更改并通知 <code>webpack</code>；</li>
<li><code>webpack</code> 重新编译构建一个或多个模块，并通知 HMR 服务器进行更新；</li>
<li><code>HMR Server</code> 使用 <code>webSocket</code> 通知 <code>HMR runtime</code> 需要更新，<code>HMR</code> 运行时通过 <code>HTTP</code> 请求更新 <code>jsonp</code></li>
<li><code>HMR</code> 运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新</li>
</ul>
<h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr>
<blockquote>
<ul>
<li><a href="https://interview2.poetries.top/docs/simply.html#_4-webpack-%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">https://interview2.poetries.top/docs/simply.html#_4-webpack-%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>css3新增特性</title>
    <url>/2020/07/01/css3%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h4 id="css3新增那些新特性？"><a href="#css3新增那些新特性？" class="headerlink" title="css3新增那些新特性？"></a>css3新增那些新特性？</h4><h5 id="选择器："><a href="#选择器：" class="headerlink" title="选择器："></a>选择器：</h5><ul>
<li>:first-of-type 选择其父元素第一个子元素</li>
<li>:last-of-type 选择其父元素最后一个子元素</li>
<li>:nth-of-type(2) 选择父元素的第二个元素</li>
<li>:only-child 选择属于父元素的唯一一个子元素</li>
<li>:last-child 选择属于其父元素的最后一个子元素</li>
</ul>
<h5 id="新样式："><a href="#新样式：" class="headerlink" title="新样式："></a>新样式：</h5><ul>
<li><p>边框 border-radius：创建圆角边框</p>
</li>
<li><p>border-shadow：为元素添加阴影</p>
</li>
<li><p>border-image：使用图片绘制边框</p>
</li>
<li><p>背景 background-clip</p>
</li>
<li><p>background-origin</p>
</li>
<li><p>background-size</p>
</li>
<li><p>background-break</p>
</li>
<li><p>文字 word-warp：</p>
<ul>
<li>narmal：使用浏览器默认换行</li>
<li>break-all：允许在单词内换行</li>
</ul>
</li>
<li><p>text-shadow：设置字体的阴影，位置及阴影颜色</p>
</li>
<li><p>颜色：增加了新的颜色表示方式</p>
<ul>
<li>rgba，rgb为颜色值，a为透明度</li>
<li>hsla，h色相，s为饱和度，l为高度，a为透明度。</li>
</ul>
</li>
</ul>
<h4 id="css3动画有那些？"><a href="#css3动画有那些？" class="headerlink" title="css3动画有那些？"></a>css3动画有那些？</h4><p>使用css动画的模块就是指元素从一种样式逐渐过渡为另一种样式的过程。</p>
<p>常见的动画有 平移，旋转，缩放等等。</p>
<ul>
<li>transition 实现渐变动画</li>
<li>transform 转变动画<ul>
<li>translate 位移</li>
<li>skew 倾斜</li>
<li>rotate：旋转</li>
<li>scale 缩放</li>
</ul>
</li>
<li>animation 实现自定义动画</li>
</ul>
]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title>inline-block缝隙问题</title>
    <url>/2020/07/08/inline-block%E7%BC%9D%E9%9A%99%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="display-inline-block元素之间空隙的产生原因和解决办法？"><a href="#display-inline-block元素之间空隙的产生原因和解决办法？" class="headerlink" title="display:inline-block元素之间空隙的产生原因和解决办法？"></a>display:inline-block元素之间空隙的产生原因和解决办法？</h4><h5 id="空隙产生原因"><a href="#空隙产生原因" class="headerlink" title="空隙产生原因"></a>空隙产生原因</h5><p>元素被当做行内元素进行排版布局的时候，元素之间的空格，换行符，空白会被浏览器处理，根据white-space的默认值 normal，合并多余的空白符。在html代码当中，换行符就会被当做是一处空白，当字体大小font-size不为零的情况下，两个元素之间就会有空隙。这些元素之间的间距会随着字体大小来变化，比如行内元素font-size：16px时，间距为8px。</p>
<h5 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h5><ul>
<li>将所有html标签写在一行 （代码可读性差）</li>
<li>给inline-block属性元素设置float：left （造成高度塌陷）</li>
<li>设置inlin-block属性元素font-size为零，需重更新设置子元素大小。</li>
<li>设置子元素margin-left:-2px。</li>
<li>给父元素设置display：table。word-sapcing：-1em。（根据实际情况来）</li>
</ul>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>jsonp原理及实现</title>
    <url>/2018/05/19/jsonp%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>jsonp是一种跨域通信的手段，它的原理其实很简单：</p>
<ul>
<li>首先是利用script标签的src属性来实现跨域。</li>
<li>通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。</li>
<li>由于使用script标签的src属性，因此只支持get方法<span id="more"></span></li>
</ul>
<h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><ol>
<li>设定一个script标签 。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://jsonp.js?callback=xxx&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>callback定义了一个函数名，而远程服务端通过调用指定的函数并传入参数来实现传递参数，将fn(response)传递回客户端 。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$callback = !<span class="title function_">empty</span>($_GET[<span class="string">&#x27;callback&#x27;</span>]) ? $_GET[<span class="string">&#x27;callback&#x27;</span>] : <span class="string">&#x27;callback&#x27;</span>;</span><br><span class="line">echo $callback.<span class="string">&#x27;(.json_encode($data).)&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>客户端接收到返回的js脚本，开始解析和执行fn(response) 。</li>
</ol>
<h4 id="jsonp简单实现"><a href="#jsonp简单实现" class="headerlink" title="jsonp简单实现"></a>jsonp简单实现</h4><p>一个简单的jsonp实现，其实就是拼接url，然后将动态添加一个script元素到头部。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">req</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> url = req.<span class="property">url</span> + <span class="string">&#x27;?callback=&#x27;</span> + req.<span class="property">callback</span>.<span class="property">name</span>;</span><br><span class="line">    script.<span class="property">src</span> = url;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(script); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>前端js示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params">res</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;hello &#x27;</span> + res.<span class="property">data</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">jsonp</span>(&#123;</span><br><span class="line">    url : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    callback : hello </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>服务器端代码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> urllib = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8080</span>;</span><br><span class="line"><span class="keyword">var</span> data = &#123;<span class="string">&#x27;data&#x27;</span>:<span class="string">&#x27;world&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req,res</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> params = urllib.<span class="title function_">parse</span>(req.<span class="property">url</span>,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span>(params.<span class="property">query</span>.<span class="property">callback</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(params.<span class="property">query</span>.<span class="property">callback</span>);</span><br><span class="line">        <span class="comment">//jsonp</span></span><br><span class="line">        <span class="keyword">var</span> str = params.<span class="property">query</span>.<span class="property">callback</span> + <span class="string">&#x27;(&#x27;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data) + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        res.<span class="title function_">end</span>(str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.<span class="title function_">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;).<span class="title function_">listen</span>(port,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;jsonp server is on&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然而，这个实现虽然简单，但有一些不足的地方：</p>
<ol>
<li>我们传递的回调必须是一个全局方法，我们都知道要尽量减少全局的方法。</li>
<li>需要加入一些参数校验，确保接口可以正常执行。</li>
</ol>
<h4 id="可靠的jsonp实现"><a href="#可靠的jsonp实现" class="headerlink" title="可靠的jsonp实现"></a>可靠的jsonp实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"><span class="variable language_">global</span></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="number">0</span>,</span><br><span class="line">        container = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!options || !options.<span class="property">url</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> scriptNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>),</span><br><span class="line">            data = options.<span class="property">data</span> || &#123;&#125;,</span><br><span class="line">            url = options.<span class="property">url</span>,</span><br><span class="line">            callback = options.<span class="property">callback</span>,</span><br><span class="line">            fnName = <span class="string">&quot;jsonp&quot;</span> + id++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加回调函数</span></span><br><span class="line">        data[<span class="string">&quot;callback&quot;</span>] = fnName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拼接url</span></span><br><span class="line">        <span class="keyword">var</span> params = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">            params.<span class="title function_">push</span>(<span class="built_in">encodeURIComponent</span>(key) + <span class="string">&quot;=&quot;</span> + <span class="built_in">encodeURIComponent</span>(data[key]));</span><br><span class="line">        &#125;</span><br><span class="line">        url = url.<span class="title function_">indexOf</span>(<span class="string">&quot;?&quot;</span>) &gt; <span class="number">0</span> ? (url + <span class="string">&quot;&amp;&quot;</span>) : (url + <span class="string">&quot;?&quot;</span>);</span><br><span class="line">        url += params.<span class="title function_">join</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">        scriptNode.<span class="property">src</span> = url;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传递的是一个匿名的回调函数，要执行的话，暴露为一个全局方法</span></span><br><span class="line">        <span class="variable language_">global</span>[fnName] = <span class="keyword">function</span> (<span class="params">ret</span>) &#123;</span><br><span class="line">            callback &amp;&amp; <span class="title function_">callback</span>(ret);</span><br><span class="line">            container.<span class="title function_">removeChild</span>(scriptNode);</span><br><span class="line">            <span class="keyword">delete</span> <span class="variable language_">global</span>[fnName];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出错处理</span></span><br><span class="line">        scriptNode.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            callback &amp;&amp; <span class="title function_">callback</span>(&#123;<span class="attr">error</span>:<span class="string">&quot;error&quot;</span>&#125;);</span><br><span class="line">            container.<span class="title function_">removeChild</span>(scriptNode);</span><br><span class="line">            <span class="variable language_">global</span>[fnName] &amp;&amp; <span class="keyword">delete</span> <span class="variable language_">global</span>[fnName];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        scriptNode.<span class="property">type</span> = <span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line">        container.<span class="title function_">appendChild</span>(scriptNode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">global</span>.<span class="property">jsonp</span> = jsonp;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="variable language_">this</span>);</span><br></pre></td></tr></table></figure>

<p><strong>使用示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">jsonp</span>(&#123;    </span><br><span class="line">  url : <span class="string">&quot;www.example.com&quot;</span>,   </span><br><span class="line">  data : &#123;id : <span class="number">1</span>&#125;,    </span><br><span class="line">  callback : <span class="keyword">function</span> (<span class="params">ret</span>)&#123;    </span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(ret);    </span><br><span class="line">  &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title>keep-alive作用</title>
    <url>/2019/10/10/keep-alive%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h4 id="keep-alive作用是什么呢？"><a href="#keep-alive作用是什么呢？" class="headerlink" title="keep-alive作用是什么呢？"></a>keep-alive作用是什么呢？</h4><blockquote>
<p>keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载</p>
</blockquote>
<ul>
<li><code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>包裹动态组件时，会缓存不活动得组件实例，主要用于保留组件状态或避免重新渲染</li>
</ul>
<blockquote>
<p>比如有一个列表和一个详情，那么用户就会经常执行打开详情&#x3D;》返回列表&#x3D;》打开详情….这样得话列表和详情都是一个频率很高得也买你，那么就可以对列表组件使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染。</p>
</blockquote>
<ul>
<li>常用的两个属性 <code>include/exclude</code>，允许组件有条件的进行缓存</li>
<li>两个生命周期<code>activated/deactivated</code>，用来得知当前组件是否处于活跃状态</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>var、let与const</title>
    <url>/2018/03/28/var%E3%80%81let%E4%B8%8Econst/</url>
    <content><![CDATA[<h4 id="var、let与const"><a href="#var、let与const" class="headerlink" title="var、let与const"></a>var、let与const</h4><h5 id="Var："><a href="#Var：" class="headerlink" title="Var："></a>Var：</h5><p>用var声明的变量既是全局变量，也是顶层变量。</p>
<p>注意：顶层变量，在浏览器环境里指的是window对象，在node指的是global对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用var存在变量提升的情况</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">//undefind</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>var</code>，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明 。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)   <span class="comment">//30</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在函数中使用var声明变量，该变量是局部的。</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">change</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">// 20 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>在函数中不使用var声明变量，该变量是全局的。</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">change</span>(<span class="params"></span>)&#123;</span><br><span class="line">   a = <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">change</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 30 </span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<hr>
<h5 id="Let："><a href="#Let：" class="headerlink" title="Let："></a>Let：</h5><p>let是es6新增的语法，用来声明变量。</p>
<ul>
<li>只能在let代码块内有效。具有块级作用域。</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// ReferenceError: a is not defined.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>存在暂时性死区的问题，没有变量提升。</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)   <span class="comment">// Uncaught ReferenceError: Cannot access &#x27;a&#x27; before    initialization</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> a = <span class="number">30</span></span><br></pre></td></tr></table></figure>

<ul>
<li>let 不能重复声明一个变量。</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)   <span class="comment">//SyntaxError: Identifier &#x27;a&#x27; has already been declared</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="Const："><a href="#Const：" class="headerlink" title="Const："></a>Const：</h5><ul>
<li><code>const</code>声明一个只读的常量，一旦声明，常量的值就不能改变 。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>之前用<code>var</code>或<code>let</code>声明过变量，再用<code>const</code>声明同样会报错 。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">30</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span></span><br><span class="line"><span class="comment">// 都会报错</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><ul>
<li>var存在变量提升，let和const不存在变量提升。</li>
<li>var不存在暂时性死区，let和const存在暂时性死区，只有先正确声明好变量才能获取和使用该变量。</li>
<li>var不存在块级作用域，let和const存在块级作用域。</li>
<li>var可以重复声明变量，后者声明的值覆盖前者。let和const不能重复声明。</li>
<li>var和let可以修改值，const是一个常量，不能修改。</li>
</ul>
<hr>
<h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5><hr>
<blockquote>
<ul>
<li><a href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><a href="https://vue3js.cn/interview/es6/var_let_const.html#%E4%B8%80%E3%80%81var">https://vue3js.cn/interview/es6/var_let_const.html#%E4%B8%80%E3%80%81var</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>web即时通讯</title>
    <url>/2020/04/25/web%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<h2 id="web即时通讯"><a href="#web即时通讯" class="headerlink" title="web即时通讯"></a>web即时通讯</h2><p>大体可以分为两类：一种是在HTTP基础上实现的，另一种即websocket。</p>
<h3 id="1-轮询（短轮询）"><a href="#1-轮询（短轮询）" class="headerlink" title="1.轮询（短轮询）"></a>1.轮询（短轮询）</h3><p><strong>短轮询</strong>的基本思路就是浏览器每隔一段时间向浏览器发送http请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。</p>
<p>　　这种方式的优点是比较简单，易于理解，实现起来也没有什么技术难点。<span style='color:red;'>缺点是显而易见的，这种方式由于需要不断的建立http连接，严重浪费了服务器端和客户端的资源。</span>尤其是在客户端，距离来说，如果有数量级想对比较大的人同时位于基于短轮询的应用中，那么每一个用户的客户端都会疯狂的向服务器端发送http请求，而且不会间断。人数越多，服务器端压力越大，这是很不合理的。</p>
<p>　　因此短轮询不适用于那些同时在线用户数量比较大，并且很注重性能的Web应用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;/user&#x27;</span>);</span><br><span class="line">        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.<span class="title function_">send</span>();</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<span id="more"></span>


<h3 id="2-长轮询（comet）"><a href="#2-长轮询（comet）" class="headerlink" title="2.长轮询（comet）"></a>2.长轮询（comet）</h3><p>ajax实现:</p>
<p>　　当服务器收到客户端发来的请求后,服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制(服务器端设置)才返回。 客户端JavaScript响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。</p>
<p>　　长轮询和短轮询比起来，明显减少了很多不必要的http请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">       xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;/user&#x27;</span>);</span><br><span class="line">       xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">             <span class="title function_">ajax</span>();</span><br><span class="line">       &#125;;</span><br><span class="line">       xhr.<span class="title function_">send</span>();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>轮询与长轮询都是基于HTTP的，<span style="color:red">两者本身存在着缺陷:轮询需要更快的处理速度；长轮询则更要求处理并发的能力;两者都是“被动型服务器”的体现</span>:服务器不会主动推送信息，而是在客户端发送ajax请求后进行返回的响应。而理想的模型是”在服务器端数据有了变化后，可以主动推送给客户端”,这种”主动型”服务器是解决这类问题的很好的方案。<strong>Web Sockets就是这样的方案。</strong></p>
<h3 id="3-长连接-SSE"><a href="#3-长连接-SSE" class="headerlink" title="3.长连接(SSE)"></a>3.长连接(SSE)</h3><p>　SSE是HTML5新增的功能，全称为Server-Sent Events。它可以允许服务推送数据到客户端。SSE在本质上就与之前的长轮询、短轮询不同，虽然都是基于http协议的，但是轮询需要客户端先发送请求。而SSE最大的特点就是不需要客户端发送请求，可以实现只要服务器端数据有更新，就可以马上发送到客户端。</p>
<p>　　SSE的优势很明显，它不需要建立或保持大量的客户端发往服务器端的请求，节约了很多资源，提升应用性能。SSE的实现非常简单，并且不需要依赖其他插件。</p>
<ul>
<li><span style="color: green">SSE 使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议。</span></li>
<li><span style="color: green">SSE 属于轻量级，使用简单；WebSocket 协议相对复杂。</span></li>
<li><span style="color: green">SSE 默认支持断线重连，WebSocket 需要自己实现。</span></li>
<li><span style="color: green">SSE 一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据。</span></li>
<li><span style="color: green">SSE 支持自定义发送的消息类型。</span></li>
</ul>
<h3 id="4-websocket"><a href="#4-websocket" class="headerlink" title="4.websocket"></a>4.websocket</h3><p>WebSocket是Html5定义的一个新协议，与传统的http协议不同，该协议可以实现服务器与客户端之间全双工通信。简单来说，首先需要在客户端和服务器端建立起一个连接，这部分需要http。连接一旦建立，客户端和服务器端就处于平等的地位，可以相互发送数据，不存在请求和响应的区别。</p>
<p>　　WebSocket的优点是实现了双向通信，缺点是服务器端的逻辑非常复杂。现在针对不同的后台语言有不同的插件可以使用。</p>
<p>举例(用法较简单)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;wss://echo.websocket.org&quot;</span>);</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Connection open ...&quot;</span>); </span><br><span class="line">  ws.<span class="title function_">send</span>(<span class="string">&quot;Hello WebSockets!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;Received Message: &quot;</span> + evt.<span class="property">data</span>);</span><br><span class="line">  ws.<span class="title function_">close</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Connection closed.&quot;</span>);</span><br><span class="line">&#125;;      </span><br></pre></td></tr></table></figure>



<h2 id="四种Web即时通信技术比较"><a href="#四种Web即时通信技术比较" class="headerlink" title="四种Web即时通信技术比较"></a>四种Web即时通信技术比较</h2><p>　　从兼容性角度考虑，短轮询&gt;长轮询&gt;长连接SSE&gt;WebSocket；</p>
<p>　　从性能方面考虑，WebSocket&gt;长连接SSE&gt;长轮询&gt;短轮询。</p>
]]></content>
      <categories>
        <category>网络通讯</category>
      </categories>
      <tags>
        <tag>网络通讯</tag>
      </tags>
  </entry>
  <entry>
    <title>介绍babel原理</title>
    <url>/2019/04/10/%E4%BB%8B%E7%BB%8Dbabel%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h4 id="介绍一下-webpack-scope-hosting"><a href="#介绍一下-webpack-scope-hosting" class="headerlink" title="介绍一下 webpack scope hosting"></a>介绍一下 webpack scope hosting</h4><p>作用域提升，将分散的模块划分到同一个作用域中，避免了代码的重复引入，有效减少打包后的代码体积和运行时的内存损耗；</p>
<span id="more"></span>

<h4 id="介绍一下-babel原理"><a href="#介绍一下-babel原理" class="headerlink" title="介绍一下 babel原理"></a>介绍一下 babel原理</h4><blockquote>
<p><code>babel</code> 的编译过程分为三个阶段：<strong>parsing</strong>、<strong>transforming</strong>、<strong>generating</strong>，以 ES6 编译为 ES5 作为例子：</p>
</blockquote>
<ol>
<li><code>ES6</code> 代码输入；</li>
<li><code>babylon</code> 进行解析得到 AST；</li>
<li><code>plugin</code> 用 <code>babel-traverse</code> 对 <code>AST</code>树进行遍历编译，得到新的 <code>AST</code>树；</li>
<li>用 <code>babel-generator</code> 通过 <code>AST</code>树生成 <code>ES5</code> 代码。</li>
</ol>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title>关于ES6新增Set、Map</title>
    <url>/2018/08/05/%E5%85%B3%E4%BA%8EES6%E6%96%B0%E5%A2%9ESet%E3%80%81Map/</url>
    <content><![CDATA[<h4 id="关于ES6新增Set、Map两种数据结构"><a href="#关于ES6新增Set、Map两种数据结构" class="headerlink" title="关于ES6新增Set、Map两种数据结构"></a>关于ES6新增Set、Map两种数据结构</h4><p><code>Set</code>是一种叫做集合的数据结构，<code>Map</code>是一种叫做字典的数据结构</p>
<h5 id="一、Set"><a href="#一、Set" class="headerlink" title="一、Set"></a>一、Set</h5><p><code>Set</code>是<code>es6</code>新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合</p>
<h6 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h6><p><code>Set</code>的实例关于增删改查的方法：</p>
<span id="more"></span>
<ul>
<li><p>add()</p>
<ul>
<li>添加某个值，返回 <code>Set</code> 结构本身，当添加实例中已经存在的元素，<code>set</code>不会进行处理添加</li>
</ul>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.<span class="title function_">add</span>(<span class="number">1</span>).<span class="title function_">add</span>(<span class="number">2</span>).<span class="title function_">add</span>(<span class="number">2</span>); <span class="comment">// 2只被添加了一次</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>delete()</p>
<ul>
<li>删除某个值，返回一个布尔值，表示删除是否成功</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.<span class="title function_">delete</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>has()</p>
<ul>
<li>返回一个布尔值，判断该值是否为<code>Set</code>的成员</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.<span class="title function_">has</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>clear()</p>
<ul>
<li>清除所有成员，没有返回值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h6><p><code>Set</code>实例遍历的方法有如下：</p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
<h5 id="二、Map"><a href="#二、Map" class="headerlink" title="二、Map"></a>二、Map</h5><p><code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型，相当于一个字典。<code>Map</code>本身是一个构造函数，用来生成 <code>Map</code> 数据结构。</p>
<h6 id="增删改查-1"><a href="#增删改查-1" class="headerlink" title="增删改查"></a>增删改查</h6><p><code>Map</code> 结构的实例针对增删改查有以下属性和操作方法：</p>
<ul>
<li><p>size 属性</p>
<ul>
<li><code>size</code>属性返回 Map 结构的成员总数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>set()</p>
<ul>
<li><p>设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构</p>
<p>如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键</p>
<p>同时返回的是当前<code>Map</code>对象，可采用链式写法</p>
</li>
</ul>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>)    <span class="comment">// 键是 undefined</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>).<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>).<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>) <span class="comment">// 链式操作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>get()</p>
<ul>
<li><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hello = <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);&#125;;</span><br><span class="line">m.<span class="title function_">set</span>(hello, <span class="string">&#x27;Hello ES6!&#x27;</span>) <span class="comment">// 键是函数</span></span><br><span class="line"></span><br><span class="line">m.<span class="title function_">get</span>(hello)  <span class="comment">// Hello ES6!</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>has()</p>
<ul>
<li><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>);</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&#x27;edition&#x27;</span>)     <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&#x27;years&#x27;</span>)       <span class="comment">// false</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="number">262</span>)           <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>delete()</p>
<ul>
<li><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>);</span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">m.<span class="title function_">delete</span>(<span class="literal">undefined</span>)</span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)       <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>clear()</p>
<ul>
<li><code>clear</code>方法清除所有成员，没有返回值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line">map.<span class="title function_">clear</span>()</span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h6><p><code>Map</code>结构原生提供三个遍历器生成函数和一个遍历方法：</p>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回所有成员的遍历器</li>
<li>forEach()：遍历 Map 的所有成员</li>
</ul>
<h5 id="三、WeakSet-和-WeakMap"><a href="#三、WeakSet-和-WeakMap" class="headerlink" title="三、WeakSet 和 WeakMap"></a>三、WeakSet 和 WeakMap</h5><h6 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h6><p>创建<code>WeakSet</code>实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br></pre></td></tr></table></figure>

<p><code>WeakSet</code>可以接受一个具有 <code>Iterable</code>接口的对象作为参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(a);</span><br><span class="line"><span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span><br></pre></td></tr></table></figure>

<p>在<code>API</code>中<code>WeakSet</code>与<code>Set</code>有两个区别：</p>
<ul>
<li>没有遍历操作的<code>API</code></li>
<li>没有<code>size</code>属性</li>
</ul>
<p><code>WeackSet</code>只能成员只能是引用类型，而不能是其他类型的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ws=<span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员不是引用类型</span></span><br><span class="line"><span class="keyword">let</span> weakSet=<span class="keyword">new</span> <span class="title class_">WeakSet</span>([<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(weakSet) <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员为引用类型</span></span><br><span class="line"><span class="keyword">let</span> obj1=&#123;<span class="attr">name</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2=&#123;<span class="attr">name</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> ws=<span class="keyword">new</span> <span class="title class_">WeakSet</span>([obj1,obj2]); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ws) <span class="comment">//WeakSet &#123;&#123;…&#125;, &#123;…&#125;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>WeakSet</code>里面的引用只要在外部消失，它在 <code>WeakSet</code>里面的引用就会自动消失</p>
<h6 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h6><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合</p>
<p>在<code>API</code>中<code>WeakMap</code>与<code>Map</code>有两个区别：</p>
<ul>
<li><p>没有遍历操作的<code>API</code></p>
</li>
<li><p>没有<code>clear</code>清空方法</p>
</li>
</ul>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WeakMap 可以使用 set 方法添加成员</span></span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line">wm1.<span class="title function_">set</span>(key, <span class="number">2</span>);</span><br><span class="line">wm1.<span class="title function_">get</span>(key) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakMap 也可以接受一个数组，</span></span><br><span class="line"><span class="comment">// 作为构造函数的参数</span></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([[k1, <span class="string">&#x27;foo&#x27;</span>], [k2, <span class="string">&#x27;bar&#x27;</span>]]);</span><br><span class="line">wm2.<span class="title function_">get</span>(k2) <span class="comment">// &quot;bar&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object!</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="title class_">Symbol</span>(), <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Vue3+setup+Ts的使用</title>
    <url>/2021/11/21/%E5%85%B3%E4%BA%8EVue3-setup-Ts%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="关于Vue3-setup-Ts的使用"><a href="#关于Vue3-setup-Ts的使用" class="headerlink" title="关于Vue3+setup+Ts的使用"></a>关于Vue3+setup+Ts的使用</h3><p>在自身英语还不错的情况下，建议阅读英文官网</p>
<p><span style="color:red;"><a href="https://vuejs.org/">https://vuejs.org/</a></span></p>
<h3 id="关于设置代码片段"><a href="#关于设置代码片段" class="headerlink" title="关于设置代码片段"></a>关于设置代码片段</h3><p>根据自己的使用习惯，设置vscode的vue代码片段，推荐使用<a href="https://link.juejin.cn/?target=https://snippet-generator.app">snippet-generator.app</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;vue3模版&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;prefix&quot;</span>: <span class="string">&quot;vue3&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;body&quot;</span>: [</span><br><span class="line"></span><br><span class="line">   <span class="string">&quot;&lt;template&gt;&quot;</span>,</span><br><span class="line"></span><br><span class="line">       <span class="string">&quot; &lt;div class=&#x27;$&#123;1:box&#125;&#x27;&gt;&lt;/div&gt;&quot;</span>,</span><br><span class="line"></span><br><span class="line">   <span class="string">&quot;&lt;/template&gt;&quot;</span>,</span><br><span class="line"></span><br><span class="line">   <span class="string">&quot; &quot;</span>,</span><br><span class="line"></span><br><span class="line">   <span class="string">&quot;&lt;script setup lang=&#x27;ts&#x27;&gt;&quot;</span>,</span><br><span class="line"></span><br><span class="line">   <span class="string">&quot; import &#123;ref,reactive&#125; from \&quot;vue\&quot;;&quot;</span>,</span><br><span class="line"></span><br><span class="line">   <span class="string">&quot; $&#123;3&#125;&quot;</span>,</span><br><span class="line"></span><br><span class="line">   <span class="string">&quot;&lt;/script&gt;&quot;</span>,</span><br><span class="line"></span><br><span class="line">   <span class="string">&quot; &quot;</span>,</span><br><span class="line"></span><br><span class="line">   <span class="string">&quot;&lt;style lang=\&quot;scss\&quot; scoped&gt;&quot;</span>,</span><br><span class="line"></span><br><span class="line">   <span class="string">&quot; .$&#123;2:box&#125; &#123;&quot;</span>,</span><br><span class="line"></span><br><span class="line">   <span class="string">&quot; &#125;&quot;</span>,</span><br><span class="line"></span><br><span class="line">   <span class="string">&quot;&lt;/style&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;vue3模版&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组件引入"><a href="#组件引入" class="headerlink" title="组件引入"></a>组件引入</h3><p>当使用setup的时候，组件直接引入就可以了，不需要再自己手动注册</p>
<span id="more"></span>
<h3 id="ref和reactive"><a href="#ref和reactive" class="headerlink" title="ref和reactive"></a>ref和reactive</h3><p>ref一般用于基本的数据类型，比如string，boolean reactive一般用于对象 ref的地方其实也是调用的reactive实现的。</p>
<h3 id="defineEmits和defineProps获取父组件传过来值和事件"><a href="#defineEmits和defineProps获取父组件传过来值和事件" class="headerlink" title="defineEmits和defineProps获取父组件传过来值和事件"></a>defineEmits和defineProps获取父组件传过来值和事件</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种不带默认值props</span></span><br><span class="line"><span class="keyword">const</span> props = defineProps&lt;&#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">string</span></span><br><span class="line">  bar?: <span class="built_in">number</span></span><br><span class="line">&#125;&gt;()</span><br><span class="line"><span class="comment">// 第二种带默认值props</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">ChildProps</span> &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="built_in">string</span></span><br><span class="line">  bar?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> props = <span class="title function_">withDefaults</span>(defineProps&lt;<span class="title class_">ChildProps</span>&gt;(), &#123;</span><br><span class="line">   <span class="attr">foo</span>: <span class="string">&quot;1qsd&quot;</span></span><br><span class="line">  bar?: <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种获取事件</span></span><br><span class="line"><span class="keyword">const</span> emit = defineEmits&lt;&#123;</span><br><span class="line">  (<span class="attr">e</span>: <span class="string">&#x27;change&#x27;</span>, <span class="attr">id</span>: <span class="built_in">number</span>): <span class="built_in">void</span></span><br><span class="line">  (<span class="attr">e</span>: <span class="string">&#x27;update&#x27;</span>, <span class="attr">value</span>: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line">&#125;&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种获取事件</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>([<span class="string">&quot;dosth&quot;</span>])</span><br></pre></td></tr></table></figure>

<h3 id="使用useAttrs和useSlots"><a href="#使用useAttrs和useSlots" class="headerlink" title="使用useAttrs和useSlots"></a>使用useAttrs和useSlots</h3><p>useAttrs 可以获取父组件传过来的id和class等值。 useSlots 可以获得插槽的内容。 例子中，我们使用useAttrs获取父组件传过来的id和class，useSlots获取插槽的内容。</p>
<p>父组件：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span>&#123;&#123; fatherRef &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">:fatherRef</span>=<span class="string">&quot;fatherRef&quot;</span> @<span class="attr">changeVal</span>=<span class="string">&quot;changeVal&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">id</span>=<span class="string">&quot;111&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">template</span> #<span class="attr">test1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>1223<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&quot;./Child.vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> fatherRef = <span class="title function_">ref</span>(<span class="string">&quot;1&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">changeVal</span>(<span class="params">val: string</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    fatherRef.<span class="property">value</span> = val;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.father</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">margin-top</span>: <span class="number">40px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">margin-bottom</span>: <span class="number">40px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.btn</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>&#123;&#123; props.fatherRef &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> --&gt;</span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">&quot;attrs&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;test1&quot;</span>&gt;</span>11<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;inputVal&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; computed, useAttrs, useSlots &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> props = defineProps&lt;&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">fatherRef</span>: string;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;&gt;();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> emits = <span class="title function_">defineEmits</span>([<span class="string">&quot;changeVal&quot;</span>]);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> slots = <span class="title function_">useSlots</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> attrs = <span class="title function_">useAttrs</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">122</span>, attrs, slots);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> inputVal = <span class="title function_">computed</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> props.<span class="property">fatherRef</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">set</span>(<span class="params">val: string</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">emits</span>(<span class="string">&quot;changeVal&quot;</span>, val);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">.child &#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="使用自定义指令"><a href="#使用自定义指令" class="headerlink" title="使用自定义指令"></a>使用自定义指令</h3><p>在setup里边自定义指令的时候，只需要遵循<code>vNameOfDirective</code> 这样的命名规范就可以了</p>
<p>比如如下自定义focus指令，命名就是vMyFocus，使用的就是v-my-focus</p>
<p>自定义指令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script setup lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">const</span> vMyFocus = &#123;</span><br><span class="line">  <span class="attr">onMounted</span>: <span class="function">(<span class="params">el: HTMLInputElement</span>) =&gt;</span> &#123;</span><br><span class="line">    el.<span class="title function_">focus</span>();</span><br><span class="line">    <span class="comment">// 在元素上做些操作</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-my-focus</span> <span class="attr">value</span>=<span class="string">&quot;111&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="使用defineExpose子组件传父组件"><a href="#使用defineExpose子组件传父组件" class="headerlink" title="使用defineExpose子组件传父组件"></a>使用defineExpose子组件传父组件</h3><p>子组件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">doSth</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">defineExpose</span>(&#123; doSth &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">.child &#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>父组件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;doSth1&quot;</span>&gt;</span>222<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">ref</span>=<span class="string">&quot;childRef&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&quot;./Child.vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> childRef = <span class="title function_">ref</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">doSth1</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    childRef.<span class="property">value</span>.<span class="title function_">doSth</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">.father &#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="父组件传子组件"><a href="#父组件传子组件" class="headerlink" title="父组件传子组件"></a>父组件传子组件</h3><p>父组件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> @<span class="attr">click</span>=<span class="string">&quot;doSth&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&quot;./Child.vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">doSth</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">112</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">.father &#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>2222<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref, reactive, onMounted &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> emits = <span class="title function_">defineEmits</span>([<span class="string">&quot;doSth&quot;</span>]);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">emits</span>(<span class="string">&quot;doSth&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">.child &#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><p>当从父组件向子组件传props的时候，必须使用toRefs或者toRef进行转一下，这是为什么呢？</p>
<p>这里是因为如果不使用toRefs转一次的话，当父组件中的props改变的时候，子组件如果使用了Es6的解析，会失去响应性。</p>
<p>可以看下如下例子</p>
<p>父组件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeVal&quot;</span>&gt;</span>&#123;&#123; fatherRef &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">:fatherRef</span>=<span class="string">&quot;fatherRef&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&quot;./Child.vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> fatherRef = <span class="title function_">ref</span>(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">changeVal</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    fatherRef.<span class="property">value</span> = <span class="number">2</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.father</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">margin-bottom</span>: <span class="number">40px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeVal&quot;</span>&gt;</span>&#123;&#123; fatherRef &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref, reactive, onMounted, toRefs &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> props = defineProps&lt;&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">fatherRef</span>: any;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;&gt;();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> &#123; fatherRef &#125; = props;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">changeVal</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    fatherRef.<span class="property">value</span> = <span class="number">34</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">.child &#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到当父组件如果点击之后，因为使用const { fatherRef } &#x3D; props;进行解析，就失去了响应性</p>
<p>所以当父组件变成2的时候，子组件还是1。</p>
<p>这里有两种解决办法</p>
<ol>
<li>使用const { fatherRef } &#x3D; toRefs(props);</li>
<li>在模版中中使用props.fatherRef</li>
</ol>
<h3 id="子组件使用v-model"><a href="#子组件使用v-model" class="headerlink" title="子组件使用v-model"></a>子组件使用v-model</h3><h4 id="可以在子组件中使用computed，实现双向绑定"><a href="#可以在子组件中使用computed，实现双向绑定" class="headerlink" title="可以在子组件中使用computed，实现双向绑定"></a>可以在子组件中使用computed，实现双向绑定</h4><p>父组件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span>&#123;&#123; fatherRef &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">:fatherRef</span>=<span class="string">&quot;fatherRef&quot;</span> @<span class="attr">changeVal</span>=<span class="string">&quot;changeVal&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&quot;./Child.vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> fatherRef = <span class="title function_">ref</span>(<span class="string">&quot;1&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">changeVal</span>(<span class="params">val: string</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    fatherRef.<span class="property">value</span> = val;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.father</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">margin-top</span>: <span class="number">40px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">margin-bottom</span>: <span class="number">40px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>&#123;&#123; props.fatherRef &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> --&gt;</span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;inputVal&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> props = defineProps&lt;&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">fatherRef</span>: string;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;&gt;();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> emits = <span class="title function_">defineEmits</span>([<span class="string">&quot;changeVal&quot;</span>]);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> inputVal = <span class="title function_">computed</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> props.<span class="property">fatherRef</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">set</span>(<span class="params">val: string</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">emits</span>(<span class="string">&quot;changeVal&quot;</span>, val);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">.child &#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="可以从父组件传递值和改变值的方法，然后子组件也可以使用v-model"><a href="#可以从父组件传递值和改变值的方法，然后子组件也可以使用v-model" class="headerlink" title="可以从父组件传递值和改变值的方法，然后子组件也可以使用v-model"></a>可以从父组件传递值和改变值的方法，然后子组件也可以使用v-model</h4><p>例子中父组件传递 modelValue和update:modelValue方法 </p>
<p>父组件：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">:modelValue</span>=<span class="string">&quot;searchText&quot;</span> @<span class="attr">update:modelValue</span>=<span class="string">&quot;changeVal&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&quot;./Child.vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> searchText = <span class="title function_">ref</span>(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">changeVal</span>(<span class="params">val: number</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    searchText.<span class="property">value</span> = val;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.father</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">margin-top</span>: <span class="number">40px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">margin-bottom</span>: <span class="number">40px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.btn</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>&#123;&#123; props.fatherRef &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">&quot;attrs&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;test1&quot;</span>&gt;</span>11<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;inputVal&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> --&gt;</span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;modelValue&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; computed, useAttrs, useSlots &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> props = defineProps&lt;&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">modelValue</span>: number;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;&gt;();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// const emits = defineEmits([&quot;changeVal&quot;]);</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">.child &#123;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><p>组件本身是可以调用组件自身的，也就是递归。 比如名为 <code>Child.vue</code> 的组件可以在其模板中用 <code>&lt;Child/&gt;</code> 引用它自己。这里需要注意的是需要设置条件语句，用来中断递归，不然递归会无限递归下去。</p>
<p>父组件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">:modelValue</span>=<span class="string">&quot;searchText&quot;</span> @<span class="attr">update:modelValue</span>=<span class="string">&quot;changeVal&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&quot;./Child.vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> searchText = <span class="title function_">ref</span>(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">changeVal</span>(<span class="params">val: number</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  searchText.<span class="property">value</span> = val;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.father</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">margin-top</span>: <span class="number">40px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">margin-bottom</span>: <span class="number">40px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.btn</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>子组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;modelValue&quot;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:modelValue</span>=<span class="string">&quot;test&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    @<span class="attr">update:modelValue</span>=<span class="string">&quot;changeTest&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-if</span>=<span class="string">&quot;modelValue &gt; 2&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; computed, useAttrs, useSlots, ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> props = defineProps&lt;&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">modelValue</span>: number;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;&gt;();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> test = <span class="title function_">ref</span>(<span class="number">0</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">changeTest</span>(<span class="params">val: number</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  test.<span class="property">value</span> = val;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// const emits = defineEmits([&quot;changeVal&quot;]);</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.child</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">position</span>: relative;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Vue3</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>关于tree-shaking</title>
    <url>/2019/08/04/%E5%85%B3%E4%BA%8Etree-shaking/</url>
    <content><![CDATA[<h4 id="介绍一下tree-shaking"><a href="#介绍一下tree-shaking" class="headerlink" title="介绍一下tree-shaking"></a>介绍一下tree-shaking</h4><h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a><strong>作用：</strong></h5><p>它表示在打包的时候会去除一些无用的代码</p>
<h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a><strong>原理</strong>：</h5><ul>
<li><code>ES6</code>的模块引入是静态分析的，所以在编译时能正确判断到底加载了哪些模块</li>
<li>分析程序流，判断哪些变量未被使用、引用，进而删除此代码</li>
</ul>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a><strong>特点：</strong></h5><ul>
<li>在生产模式下它是默认开启的，但是由于经过<code>babel</code>编译全部模块被封装成<code>IIFE</code>，它存在副作用无法被<code>tree-shaking</code>掉</li>
<li>可以在<code>package.json</code>中配置<code>sideEffects</code>来指定哪些文件是有副作用的。它有两种值，一个是布尔类型，如果是<code>false</code>则表示所有文件都没有副作用；如果是一个数组的话，数组里的文件路径表示改文件有副作用</li>
<li><code>rollup</code>和<code>webpack</code>中对<code>tree-shaking</code>的层度不同，例如对<code>babel</code>转译后的<code>class</code>，如果<code>babel</code>的转译是宽松模式下的话(也就是<code>loose</code>为<code>true</code>)，<code>webpack</code>依旧会认为它有副作用不会<code>tree-shaking</code>掉，而<code>rollup</code>会。这是因为<code>rollup</code>有程序流分析的功能，可以更好的判断代码是否真正会产生副作用。</li>
</ul>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h5><span id="more"></span>
<ul>
<li><code>ES6 Module</code> 引入进行静态分析，故而编译的时候正确判断到底加载了那些模块</li>
<li>静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码</li>
</ul>
<blockquote>
<p>依赖于<code>import/export</code></p>
</blockquote>
<p>通过导入所有的包后再进行条件获取。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> bar <span class="keyword">from</span> <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(condition) &#123;</span><br><span class="line">    <span class="comment">// foo.xxxx</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// bar.xxx</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>ES6的import语法完美可以使用tree shaking，因为可以在代码不运行的情况下就能分析出不需要的代码</p>
</blockquote>
<p><strong>CommonJS的动态特性模块意味着tree shaking不适用</strong>。因为它是不可能确定哪些模块实际运行之前是需要的或者是不需要的。在ES6中，进入了完全静态的导入语法：import。这也意味着下面的导入是不可行的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可行，ES6 的import是完全静态的</span></span><br><span class="line"><span class="keyword">if</span>(condition) &#123;</span><br><span class="line">    myDynamicModule = <span class="built_in">require</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    myDynamicModule = <span class="built_in">require</span>(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>Treeshaking</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工程化</title>
    <url>/2020/08/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    <content><![CDATA[<h4 id="什么是前端工程化"><a href="#什么是前端工程化" class="headerlink" title="什么是前端工程化"></a>什么是前端工程化</h4><p><strong>前端工程化</strong>是使用软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化，其主要目的<strong>为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间</strong>。</p>
<h4 id="如何做”前端工程化”"><a href="#如何做”前端工程化”" class="headerlink" title="如何做”前端工程化”"></a>如何做”前端工程化”</h4><p>前端工程化就是为了让前端开发能够“自成体系”，个人认为主要应该从<strong>模块化</strong>、<strong>组件化</strong>、<strong>规范化</strong>、<strong>自动化</strong>四个方面思考。</p>
<span id="more"></span>
<ul>
<li>模块化（js模块化，css模块化，资源模块化）</li>
<li>组件化（复用现有的UI结构，样式，行为）</li>
<li>规范化（目录结构的划分，编码规范化，接口规范化，文档规范化）</li>
<li>自动化（自动化构建，自动部署，自动化测试）</li>
</ul>
<h4 id="1-模块化"><a href="#1-模块化" class="headerlink" title="1.模块化"></a>1.模块化</h4><blockquote>
<p>简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。</p>
</blockquote>
<ul>
<li><h5 id="JS的模块化"><a href="#JS的模块化" class="headerlink" title="JS的模块化"></a>JS的模块化</h5><p>在ES6之前，JavaScript一直没有模块系统，这对开发大型复杂的前端工程造成了巨大的障碍。对此社区制定了一些模块加载方案，如CommonJS、AMD和CMD等。</p>
<p>现在ES6已经在语言层面上规定了模块系统，完全可以取代现有的CommonJS和AMD规范，而且使用起来相当简洁，并且有静态加载的特性。</p>
<ol>
<li>用<code>Webpack</code> + <code>Babel</code>将所有模块打包成一个文件同步加载，也可以搭乘多个chunk异步加载；</li>
<li>用<code>System</code>+<code>Babel</code>主要是分模块异步加载；</li>
<li>用浏览器的<code>&lt;script type=&quot;module&quot;&gt;</code>加载。</li>
</ol>
</li>
<li><h5 id="css的模块化"><a href="#css的模块化" class="headerlink" title="css的模块化"></a>css的模块化</h5><p>虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：选择器的全局污染问题。</p>
<p>按道理，一个模块化的文件应该要隐藏内部作用域，只暴露少量接口给使用者。而按照目前预处理器的方式，导入一个CSS模块后，已存在的样式有被覆盖的风险。虽然重写样式是CSS的一个优势，但这并不利于多人协作。</p>
<p>为了避免全局选择器的冲突，需要制定CSS命名风格：</p>
<ul>
<li>BEM风格</li>
<li>Bootstrap风格</li>
<li>…</li>
</ul>
<p>但是这毕竟是弱约束。所以很赞同一句话：</p>
<blockquote>
<p><em>与其费尽心思地告诉别人要遵守某种规则，以规避某种痛苦，倒不如从工具层面就消灭这种痛苦。</em></p>
</blockquote>
<p>从工具层面，社区又创造出Shadow DOM、CSS in JS和CSS Modules三种解决方案。</p>
<ul>
<li>Shadow DOM是WebComponents的标准。它能解决全局污染问题，但目前很多浏览器不兼容，对我们来说还很久远；</li>
<li>CSS in JS是彻底抛弃CSS，使用JS或JSON来写样式。这种方法很激进，不能利用现有的CSS技术，而且处理伪类等问题比较困难；</li>
<li>CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的scoped style也算是一种。</li>
</ul>
</li>
<li><h5 id="资源的模块化"><a href="#资源的模块化" class="headerlink" title="资源的模块化"></a>资源的模块化</h5><p>Webpack的强大之处不仅仅在于它统一了JS的各种模块系统，取代了Browserify、RequireJS、SeaJS的工作。更重要的是它的万能模块加载理念，即所有的资源都可以且也应该模块化。</p>
<p>资源模块化后，优点是：</p>
<ul>
<li><strong>依赖关系单一化</strong>。所有CSS和图片等资源的依赖关系统一走JS路线，无需额外处理CSS预处理器的依赖关系，也不需处理代码迁移时的图片合并、字体图片等路径问题；</li>
<li><strong>资源处理集成化</strong>。现在可以用loader对各种资源做各种事情，比如复杂的vue-loader等等；</li>
<li><strong>项目结构清晰化</strong>。使用Webpack后，你的项目结构总可以表示成这样的函数： dest &#x3D; webpack(src, config)。</li>
</ul>
</li>
</ul>
<h4 id="2-组件化"><a href="#2-组件化" class="headerlink" title="2.组件化"></a>2.组件化</h4><p>从UI拆分下来的<strong>每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元</strong>，我们称之为<strong>组件</strong>。</p>
<blockquote>
<p><strong>组件化≠模块化</strong>。模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。</p>
</blockquote>
<p>其实，组件化更重要是一种分治思想。</p>
<blockquote>
<p>Keep Simple. Everything can be a component.</p>
</blockquote>
<p>页面上所有的东西都是组件。页面是个大型组件，可以拆成若干个中型组件，然后中型组件还可以再拆，拆成若干个小型组件，小型组件也可以再拆，直到拆成DOM元素为止。DOM元素可以看成是浏览器自身的组件，作为组件的基本单元。</p>
<p>传统前端框架&#x2F;类库的思想是先组织DOM，然后把某些可复用的逻辑封装成组件来操作DOM，是DOM优先；而组件化框架&#x2F;类库的思想是先来构思组件，然后用DOM这种基本单元结合相应逻辑来实现组件，是组件优先。这是两者本质的区别。</p>
<p>其次，组件化实际上是一种按照模板(HTML)+样式(CSS)+逻辑(JS)三位一体的形式<strong>对面向对象的进一步抽象。</strong></p>
<p>所以我们除了封装组件本身，还要合理处理组件之间的关系，比如 <strong>（逻辑）继承</strong>、<strong>（样式）扩展</strong>、<strong>（模板）嵌套</strong>和<strong>包含</strong>等，这些关系都可以归为<strong>依赖</strong>。</p>
<p>目前市面上的组件化框架很多，主要的有Vue、React、Angular。Vue文档中的对比其他框架一文已经讲得很详细了。</p>
<h4 id="3-规范化"><a href="#3-规范化" class="headerlink" title="3.规范化"></a>3.规范化</h4><p>规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。</p>
<p>比如：</p>
<ul>
<li><p>目录结构的制定</p>
<p>目录结构的合理设定，能为项目带来很多优点：</p>
<ul>
<li>有助于提高项目的逻辑结构合理性；</li>
<li>对应扩展和合作；</li>
<li>方便资源的统一定位管理。</li>
</ul>
</li>
<li><p>编码规范</p>
<p>制定一套良好的编码规范可以增强团队开发协作、提高代码质量。<br> 推荐参考<strong>凹凸实验室</strong>打造的<a href="https://links.jianshu.com/go?to=https://guide.aotu.io/docs/index.html">前端代码规范</a>。</p>
<p>编码规范包括</p>
<ul>
<li><p><strong>HTML规范</strong>。</p>
<p>基于 W3C、苹果开发者 等官方文档，并结合团队业务和开发过程中总结的规范约定，让页面HTML代码更具语义性。</p>
</li>
<li><p><strong>CSS规范</strong>。</p>
<p>统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。</p>
</li>
<li><p><strong>JS规范</strong>。</p>
<p>统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。</p>
</li>
<li><p><strong>图片规范</strong>。</p>
<p>了解各种图片格式特性，根据特性制定图片规范，包括但不限于图片的质量约定、图片引入方式、图片合并处理等，旨在从图片层面优化页面性能。</p>
</li>
<li><p><strong>命名规范</strong>。</p>
<p>从 目录、图片、HTML&#x2F;CSS文件、ClassName 的命名等层面约定规范团队的命名习惯，增强团队代码的可读性。</p>
</li>
</ul>
</li>
<li><p>前后端接口规范</p>
<p>“基于 Ajax 带来的 SPA 时代”，这种模式下，前后端的分工非常清晰，前后端的关键协作点是 Ajax 接口，引发一个重要问题：前后端的对接界面双方却关注甚少，没有任何接口约定规范情况下各自撸起袖子就是干，导致我们在产品项目开发过程中，前后端的接口联调对接工作量占比在30%-50%左右，甚至会更高。往往前后端接口联调对接及系统间的联调对接都是整个产品项目研发的软肋。</p>
<p>接口规范主要初衷就是规范约定先行，尽量避免沟通联调产生的不必要的问题，让大家身心愉快地专注于各自擅长的领域。</p>
<p>那么，对于这一SPA阶段，前后端分离有几个重要的关注挑战：</p>
<ul>
<li><h5 id="职责分离"><a href="#职责分离" class="headerlink" title="职责分离"></a>职责分离</h5><ol>
<li>前后端仅仅通过异步接口(AJAX&#x2F;JSONP)来编程；</li>
<li>前后端都各自有自己的开发流程，构建工具，测试集合；</li>
<li>关注点分离，前后端变得相对独立并松耦合。</li>
</ol>
<table>
<thead>
<tr>
<th>后端</th>
<th>前端</th>
</tr>
</thead>
<tbody><tr>
<td>提供数据</td>
<td>接收数据，返回数据</td>
</tr>
<tr>
<td>处理业务逻辑</td>
<td>处理渲染逻辑</td>
</tr>
</tbody></table>
</li>
<li><h5 id="规范原则"><a href="#规范原则" class="headerlink" title="规范原则"></a>规范原则</h5><ol>
<li>接口返回数据即显示，前端仅做渲染逻辑处理；</li>
<li>渲染逻辑禁止跨多个接口调用；</li>
<li>前端关注交互、渲染逻辑，尽量避免业务逻辑处理的出现；</li>
<li>请求响应传输数据格式：JSON，JSON数据尽量简单轻量，避免多级JSON的出现；</li>
</ol>
</li>
<li><h5 id="响应格式"><a href="#响应格式" class="headerlink" title="响应格式"></a>响应格式</h5><ol>
<li>响应基本格式及处理状态值的规范。<ul>
<li>基本响应格式</li>
<li>列表响应格式</li>
</ul>
</li>
<li>特殊内容<ul>
<li>下拉框、复选框、单选框统一由后端逻辑判定选中返回给前端展示；</li>
<li>关于Boolean类型，JSON数据传输中一律使用1&#x2F;0来标示，1为是&#x2F;True，0为否&#x2F;False</li>
<li>关于日期类型，JSON数据传输中一律使用字符串，具体日期格式因业务而定；</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>文档规范</p>
</li>
<li><p>组件管理</p>
</li>
<li><p>git分支管理</p>
</li>
<li><p>commit描述规范</p>
</li>
<li><p>视觉图标规范</p>
</li>
<li><p>…</p>
</li>
</ul>
<h4 id="4-自动化"><a href="#4-自动化" class="headerlink" title="4.自动化"></a>4.自动化</h4><p>前端工程化的很多脏活累活都应该交给自动化工具来完成。需要秉持的一个理念是:</p>
<blockquote>
<p>任何简单机械的重复劳动都应该让机器去完成。</p>
</blockquote>
<ul>
<li>图标合并</li>
<li>持续集成</li>
<li>自动化构建</li>
<li>自动化部署</li>
<li>自动化测试</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>处理二进制图片</title>
    <url>/2019/07/09/%E5%A4%84%E7%90%86%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h3 id="关于后端传给前端图片的二进制流展示问题"><a href="#关于后端传给前端图片的二进制流展示问题" class="headerlink" title="关于后端传给前端图片的二进制流展示问题"></a>关于后端传给前端图片的二进制流展示问题</h3><h4 id="当后端传入的图片二进制流"><a href="#当后端传入的图片二进制流" class="headerlink" title="当后端传入的图片二进制流"></a>当后端传入的图片二进制流</h4><p>前端需要展示，如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/yinlifan/img/20220809155801.png"></p>
<h4 id="接口中处理"><a href="#接口中处理" class="headerlink" title="接口中处理"></a>接口中处理</h4><p>处理后台返回的二进制流图片时，设置返回类型responseType: ‘arraybuffer’</p>
<span id="more"></span>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">async</span> <span class="title function_">getImage</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> func = <span class="keyword">await</span> <span class="title function_">get</span>(<span class="string">&#x27;/hr/portrait/cumulative/index/spec/image/get&#x27;</span>, params, &#123;</span><br><span class="line">      <span class="attr">responseType</span>: <span class="string">&#x27;arraybuffer&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="组件中处理"><a href="#组件中处理" class="headerlink" title="组件中处理"></a>组件中处理</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">getImage</span>(<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title class_">Api</span>.<span class="title function_">getImage</span>(&#123;</span><br><span class="line">        <span class="attr">imageKey</span>: val.<span class="property">imageKey</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">imgStr</span> =</span><br><span class="line">        <span class="string">&quot;data:image/png;base64,&quot;</span> +</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">btoa</span>(</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(res).<span class="title function_">reduce</span>(</span><br><span class="line">            <span class="function">(<span class="params">data, byte</span>) =&gt;</span> data + <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(byte),</span><br><span class="line">            <span class="string">&quot;&quot;</span></span><br><span class="line">          )</span><br><span class="line">        );</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>对于mvvm的理解</title>
    <url>/2019/03/26/%E5%AF%B9%E4%BA%8Emvvm%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="对于mvvm的理解？"><a href="#对于mvvm的理解？" class="headerlink" title="对于mvvm的理解？"></a>对于mvvm的理解？</h4><p>mvvm就是modle-view-viewmodule。mvvm是一种设计思想。</p>
<ul>
<li>modle：模型层，用于处理逻辑和服务器的交互。</li>
<li>view：视图层，用于将数据渲染在页面上。UI视图。</li>
<li>view-model：视图模型层，用来连接model和view，是model和view之间的通信桥梁。达到数据驱动视图的效果。</li>
</ul>
<p>mvvm模式简化了界面与业务的依赖，解决了数据频繁更新。mvvm在使用当中，利用双向数据绑定技术，使得model变化时，viewmodel会自动更新，而viewmodel变化时，view也会自动变化。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建npm私有库</title>
    <url>/2021/11/05/%E6%90%AD%E5%BB%BAnpm%E7%A7%81%E6%9C%89%E5%BA%93/</url>
    <content><![CDATA[<h3 id="搭建npm私有库"><a href="#搭建npm私有库" class="headerlink" title="搭建npm私有库"></a>搭建npm私有库</h3><h4 id="为什么要搭建npm私有库"><a href="#为什么要搭建npm私有库" class="headerlink" title="为什么要搭建npm私有库"></a>为什么要搭建npm私有库</h4><ol>
<li><strong>npm</strong>私有库只针对公司内部局域网开放，不对外部公开，具有一定的保密性</li>
<li>速度比直接在<strong>npm</strong>下载更快，甚至是比淘宝源更快。因为毕竟是在公司局域网</li>
<li>对于发布和下载<strong>npm</strong>包配置权限管理</li>
<li>私有库能够将包资源进行缓存，响应的话会加快下载速度</li>
<li>搭建npm私有库算作对团队的一个技术亮点</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/yinlifan/img/20220808145454.png"></p>
<h3 id="verdaccio"><a href="#verdaccio" class="headerlink" title="verdaccio"></a>verdaccio</h3><p><code>verdaccio</code>是<code>nodejs</code>创建的轻量的私有<code>npm proxy registry</code>, <code>forked</code>于<code>sinopia@1.4.0</code> ,是一个开源的npm私有库的搭建工具，可以搭建一套属于自己公司的npm仓库。</p>
<ul>
<li>与yarn、npm和pnpm 100%兼容</li>
<li>提供docker 和 kubernetes 支持，很容易安装和使用</li>
<li>发布的包是私有和配置访问权限</li>
<li><strong>verdaccio</strong> 是需要缓存所有相关项，并且在本地或者私有网络下可以加速安装</li>
</ul>
<h4 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h4><span id="more"></span>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">下载之前保证您的node版本&gt;v8.x npm版本&gt;v5.x </span><br><span class="line"><span class="meta prompt_">yarn&gt;</span><span class="language-bash">v1.x pnpm&gt;v2.x ，web应用支持浏览器</span></span><br><span class="line">Chrome，Firefox，Edge和IE11以上</span><br></pre></td></tr></table></figure>

<h4 id="安装verdaccio"><a href="#安装verdaccio" class="headerlink" title="安装verdaccio"></a>安装verdaccio</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//在cmd输入</span><br><span class="line">npm install -g verdaccio  //npm下载</span><br><span class="line"></span><br><span class="line">yarn global add verdaccio  //yarn下载  用yarn下载的时候 verdaccio运行不起来的时候请换成npm下载</span><br><span class="line"></span><br><span class="line">//或者nrm切换下源地址  要是报权限错误的话，请选择cmd&lt;以管理员身份运行&gt;在输入一次</span><br><span class="line">//或者在cmd输入下面的命令：</span><br><span class="line">npm install -g verdaccio --unsafe-perm  </span><br><span class="line">//--unsafe-perm添加上是为了防止报 gyp ERR! permission denied 的权限问题</span><br><span class="line"></span><br><span class="line">//下载完成后会有红色字体表示：表示没有python的环境，这个时候不需要理会。</span><br><span class="line"></span><br><span class="line">//在cmd输入：verdaccio 执行效果如下：</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yinlifan/img/20220808150614.png"></p>
<h4 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h4><p>config.yaml文件的配置信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 这是默认的配置文件. 它会允许我们做任何事情,</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所以不要在生产环境(系统)使用它.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 在这里可以看见更多的配置示例:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">https://github.com/verdaccio/verdaccio/tree/master/conf</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">包含所有包的目录路径,npm私服包的存放目录以及缓存地址</span></span><br><span class="line">storage: ./storage</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">包含plugins的目录路径,默认插件的文件位置，一般只对docker部署有关系</span></span><br><span class="line">plugins: ./plugins</span><br><span class="line"></span><br><span class="line">web:  #verdaccio的界面</span><br><span class="line">  title: Verdaccio</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">comment out to <span class="built_in">disable</span> gravatar support 注释掉gravatar禁止使用</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">gravatar: <span class="literal">false</span></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">by default packages are ordercer ascendant (asc|desc)  默认的packages是准备好的两个选择</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">sort_packages: asc</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">convert your UI to the dark side  用户界面是黑夜模式</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">darkMode: <span class="literal">true</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">translate your registry, api i18n not available yet  看看下你的注册表，i18n api还不能使用</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">i18n:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">list of the available translations 查看可以使用的注册列表的地址：https://github.com/verdaccio/ui/tree/master/i18n/translations</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  web: en-US</span></span><br><span class="line"></span><br><span class="line">auth:  </span><br><span class="line">  htpasswd:</span><br><span class="line">    file: ./htpasswd  #保存用户的账号信息比如用户名，密码等，还没有注册或者登录的话暂时看不到</span><br><span class="line">    # Maximum amount of users allowed to register, defaults to &quot;+inf&quot;.允许注册的最大用户数量，可以是无穷大</span><br><span class="line">    # You can set this to -1 to disable registration. 你可以设置-1去禁止用户通过 npm adduser 去注册</span><br><span class="line">    # max_users: 1000  #默认注册人数最大数量是1000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a list of other known repositories we can talk to  我们需要了解其他相关有名的存储库</span></span><br><span class="line">uplinks: #配置上游的npm服务器，主要用于请求的库不存在时可以去到上游服务器去获取，可以多配置下上游链路的链接</span><br><span class="line">  npmjs:</span><br><span class="line">    url: https://registry.npmjs.org/</span><br><span class="line">    agent_options:  #代理的配置项</span><br><span class="line">      keepAlive: true </span><br><span class="line">      maxSockets: 40</span><br><span class="line">      maxFreeSockets: 10</span><br><span class="line"></span><br><span class="line">packages: # 配置模块,access访问下载权限，pushlish包的发布权限</span><br><span class="line">  &#x27;@*/*&#x27;: # 一种是@/表示某下面所属的某项目,关键字匹配</span><br><span class="line">    # scoped packages   配置权限管理</span><br><span class="line">    access: $all # 表示哪一类用户可以对匹配的项目进行安装(install)和查看包的信息</span><br><span class="line">    publish: $authenticated # 表示哪一类用户可以对匹配的项目进行发布(publish)</span><br><span class="line">    unpublish: $authenticated # 表示哪一类用户可以对匹配的项目进行卸载(publish)</span><br><span class="line">    proxy: npmjs # 这里的值是对应于 uplinks 的名称，如果本地不存在，允许去对应的uplinks去拉取</span><br><span class="line"></span><br><span class="line">  &#x27;**&#x27;: # 另一种是*匹配项目名称(名称在package.json中有定义)</span><br><span class="line">    # allow all users (including non-authenticated users) to read and</span><br><span class="line">    # publish all packages</span><br><span class="line">    # 允许所有用户（包括未经身份验证的用户）读取和发布所有包</span><br><span class="line">    # you can specify usernames/groupnames (depending on your auth plugin) 您可以指定用户名/组织名称（取决于验证身份的插件）</span><br><span class="line">    # and three keywords: &quot;$all&quot;, &quot;$anonymous&quot;, &quot;$authenticated&quot; 三个关键字:所有的,匿名的,验证过的  也可以使用具体的用户名或者组织名称(公司私有的名字)和配置的用户表 htpasswd 有关</span><br><span class="line">    access: $all</span><br><span class="line"></span><br><span class="line">    # allow all known users to publish/publish packages 允许所有用户去发布包</span><br><span class="line">    # (anyone can register by default, remember?)  任何人都可以默认注册</span><br><span class="line">    publish: $authenticated</span><br><span class="line">    unpublish: $authenticated</span><br><span class="line"></span><br><span class="line">    # if package is not available locally, proxy requests to &#x27;npmjs&#x27; registry 如果包不允许在本机使用，可以用proxy请求npmjs注册表的代理</span><br><span class="line">    proxy: npmjs</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can specify HTTP/1.1 server keep alive <span class="built_in">timeout</span> <span class="keyword">in</span> seconds <span class="keyword">for</span> incoming connections. 传入的指定连接的HTTP/1.1服务器保持活跃状态直到超时，以秒为单位</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">A value of 0 makes the http server behave similarly to Node.js versions prior to 8.0.0, <span class="built_in">which</span> did not have a keep-alive <span class="built_in">timeout</span>.  值为0的时候的服务表现行为和8.0.0之前版本的nodejs链接的时候没有保持活跃状态导致超时</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WORKAROUND: Through given configuration you can workaround following issue  解决办法：通过已知的配置，你可以解决这些问题: https://github.com/verdaccio/verdaccio/issues/301. Set to 0 <span class="keyword">in</span> <span class="keyword">case</span> 60 is not enough.  如果60不够的话可以设置为0</span></span><br><span class="line">server:</span><br><span class="line">  keepAliveTimeout: 60 </span><br><span class="line"></span><br><span class="line">middlewares:</span><br><span class="line">  audit:</span><br><span class="line">    enabled: true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">log</span> settings  设置日志</span></span><br><span class="line">logs:</span><br><span class="line">  - &#123; type: stdout, format: pretty, level: http &#125;</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">- &#123;<span class="built_in">type</span>: file, path: verdaccio.log, level: info&#125;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">experiments: 实验性的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="comment"># support for npm token command  支持npm的token令牌</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> token: <span class="literal">false</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="comment"># support for the new v1 search endpoint, functional by incomplete read more on ticket 1732</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> search: <span class="literal">false</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> <span class="comment"># disable writing body size to logs, read more on ticket 1912</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> bytesin_off: <span class="literal">false</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This affect the web and api (not developed yet) 这些会影响web和api(尚未开发的功能)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">i18n:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">web: en-US</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">默认是没有的，只能在本机访问，添加后可以通过外网访问</span></span><br><span class="line">listen:0.0.0.0:4873</span><br></pre></td></tr></table></figure>

<h4 id="通过pm2启动verdaccio"><a href="#通过pm2启动verdaccio" class="headerlink" title="通过pm2启动verdaccio"></a>通过pm2启动verdaccio</h4><p>什么是pm2?</p>
<p>pm2 是一款著名的nodejs进程守护和管理工具，下面我们用pm2来启动verdaccio：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g pm2 //安装pm2</span><br><span class="line"></span><br><span class="line">pm2 start verdaccio //启动verdaccio  </span><br></pre></td></tr></table></figure>

<p>status为online即为成功 如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yinlifan/img/20220808150936.png"></p>
<p>pm2常见命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> npm install pm2 -g     // 命令行安装 pm2</span><br><span class="line"> pm2 start app.js       // 启动app.js应用程序</span><br><span class="line"> pm2 start app.js -i 4  // 后台运行pm2，启动4个app.js</span><br><span class="line">                        // 也可以把&#x27;max&#x27; 参数传递给 star</span><br><span class="line">                        // 正确的进程数目依赖于Cpu的核心数目</span><br><span class="line"></span><br><span class="line">pm2 start app.js  --watch      // 当文件变化时自动重启应用</span><br><span class="line">pm2 list                       // 列表 PM2 启动的所有的应用程序</span><br><span class="line">pm2 monit                      // 显示每个应用程序的CPU和内存占用情况</span><br><span class="line">pm2 logs                       // 显示所有进程日志</span><br><span class="line">pm2 start app.js --name=&quot;api&quot;  // 启动应用程序并命名为 &quot;api&quot;</span><br><span class="line">pm2 start script.sh            // 启动 bash 脚本</span><br><span class="line">pm2 show [app-name]            // 显示应用程序的所有信息</span><br><span class="line">pm2 logs [app-name]            // 显示指定应用程序的日志</span><br><span class="line">pm2 stop all                   // 停止所有的应用程序</span><br><span class="line">pm2 stop 0                     // 停止 id为 0的指定应用程序</span><br><span class="line">pm2 restart all                // 重启所有应用</span><br><span class="line">pm2 restart 0                  // 重启指定的进程</span><br><span class="line">pm2 delete all                 // 关闭并删除所有应用</span><br><span class="line">pm2 delete 0                   // 删除指定应用程序id为0的</span><br><span class="line">...可以百度查阅下  ^_^</span><br></pre></td></tr></table></figure>

<h4 id="发布npm包的流程"><a href="#发布npm包的流程" class="headerlink" title="发布npm包的流程"></a>发布npm包的流程</h4><p>新建一个文件夹名称为npm-test ，在cmd控制台上输入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cd npm-test  </span><br><span class="line">npm init        <span class="comment">//初始化   默认指向index.js文件，所以新建一个index.js文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//index.js文件</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">Say</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>  (<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，执行verdaccio命令就可以发布了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm adduser --registry http://localhost:4873      //添加功能，无账号的添加完毕直接包</span><br><span class="line">npm login --registry=http://localhost:4873        //登录功能，有账号的话可以直接使用这个</span><br><span class="line">npm publish --registry http://localhost:4873      //发布包</span><br></pre></td></tr></table></figure>

<p>可以使用nrm进行管理npm源，来避免手动输入registry</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nrm add company http://localhost:4873  //company可以换任意名称  url地址  添加功能</span><br><span class="line">nrm use company       //使用company的源地址</span><br><span class="line"></span><br><span class="line">//这样的话简单了结，不用手动输入registry</span><br><span class="line">npm addUser  </span><br><span class="line">npm login</span><br><span class="line">npm publish</span><br><span class="line"></span><br><span class="line">//注意：registry要切换到公司私有服务器地址，如果不是用nrm管理切换，则需要带上私有registry(重复啦!)</span><br></pre></td></tr></table></figure>

<p>此时在<a href="http://localhost:4873/">http://localhost:4873/</a> 页面上进行更新，就会发现你发布的包(包的名称就是文件的名称)。</p>
<p>接下来，我们来下载刚刚发布的包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//注意：registry要切换到公司私有服务器地址，如果不是用nrm管理切换，则需要带上私有registry(再来一遍)</span><br><span class="line">//新建一个文件夹名为  app</span><br><span class="line">cd app</span><br><span class="line">npm install npm-test  //要是没有切换的话，请手动添加 --registry=http://localhost:4873</span><br><span class="line">//成功如图所示</span><br></pre></td></tr></table></figure>

<p>删除发布的包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm unpublish npm-test --force  //清除发布的包</span><br></pre></td></tr></table></figure>

<h4 id="npm私有库的权限管理"><a href="#npm私有库的权限管理" class="headerlink" title="npm私有库的权限管理"></a>npm私有库的权限管理</h4><p>因为verdaccio默认是人人都可以注册的，所以需要先将注册窗口关闭</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">auth</span>:</span><br><span class="line">  <span class="attr">htpasswd</span>:</span><br><span class="line">    <span class="attr">file</span>: ./htpasswd</span><br><span class="line">    <span class="comment">// 此配置项可以关闭注册功能</span></span><br><span class="line">    <span class="attr">max_users</span>: -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>verdaccio</code> 的认证是基于 <code>verdaccio-htpasswd</code>， 可以通过官方提供的工具来生成 <a href="http://www.htaccesstools.com/htpasswd-ge%E2%80%A6%EF%BC%8C%E5%B0%86%E7%94%9F%E6%88%90%E7%9A%84%E6%AE%B5%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%BB%E5%8A%A0%E5%88%B0">www.htaccesstools.com/htpasswd-ge…，将生成的段字符串添加到</a> <code>htpasswd</code> 中即可，这样的话就可以登录npm私有库	</p>
<p>之后就需要修改verdaccio文件下的config.yaml的配置：针对不同的包来设置access，publish，unpublish对应的权限组，因为htpasswd是默认的鉴权插件，所以只能写入相应的用户名，all，authenticated，$anonymous</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小小实例下：</span></span><br><span class="line"><span class="attr">auth</span>:</span><br><span class="line">  <span class="attr">htpasswd</span>:</span><br><span class="line">    <span class="attr">file</span>: ./htpasswd</span><br><span class="line">    <span class="comment">// 此配置项可以关闭注册功能</span></span><br><span class="line">    <span class="attr">max_users</span>: -<span class="number">1</span> </span><br><span class="line">    <span class="attr">duGroup</span>:</span><br><span class="line">    <span class="comment">// 这里可以自定义用户组</span></span><br><span class="line">    <span class="attr">demoPublish</span>: [xiaoming, xiaohong, xiaoli]</span><br><span class="line">    <span class="attr">demoUnpublish</span>: [xiaojun, xiaoming]</span><br><span class="line">    <span class="attr">testPublish</span>: [xiaoming,xiaojun]</span><br><span class="line"></span><br><span class="line"> <span class="attr">packages</span>:</span><br><span class="line">        <span class="string">&#x27;@demo/*&#x27;</span>:</span><br><span class="line">            <span class="attr">access</span>: $all</span><br><span class="line">        <span class="comment">// 针对不同的包，可以指定不同的用户组来满足权限控制</span></span><br><span class="line">            <span class="attr">publish</span>: demoPublish</span><br><span class="line">            <span class="attr">unpublish</span>: demoUnpublish</span><br><span class="line">            <span class="attr">proxy</span>: npmjs</span><br><span class="line">     <span class="string">&#x27;test&#x27;</span>: </span><br><span class="line">            <span class="attr">access</span>: $all</span><br><span class="line">            <span class="attr">publish</span>: testPublish</span><br><span class="line">            <span class="attr">unpublish</span>: demoUnpublish</span><br><span class="line">            <span class="attr">proxy</span>: npmjs</span><br></pre></td></tr></table></figure>

<p>或者通过安装htpasswd-for-sinopia工具来添加账号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install htpasswd-for-sinopia -g</span><br><span class="line"></span><br><span class="line">sinopia-adduser   // 在 htpasswd 目录执行</span><br></pre></td></tr></table></figure>

<p>为其他登录的用户生成用户名和密码，之后将用户名和密码写入verdaccio文件夹下的htpasswd文件中，然后就跟上文是一样的步骤。</p>
<hr>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://verdaccio.org/">https://verdaccio.org/</a></p>
]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数、实例对象和原型对象</title>
    <url>/2019/02/05/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h4 id="构造函数、实例对象、原型对象"><a href="#构造函数、实例对象、原型对象" class="headerlink" title="构造函数、实例对象、原型对象"></a>构造函数、实例对象、原型对象</h4><p>每创建一个函数，该函数都会自动带有一个prototype属性。该属性是一个指针，指向原型对象。（后期我们可以使用这个原型对象帮助我们在js中实现继承）。</p>
<p>原型对象上默认有一个属性constructor，该属性也是一个指针，指向其相关联的构造函数。</p>
<p>通过调用构造函数产生的实例对象，都拥有一个内部属性，指向了原型对象。其实例对象能够访问原型对象上的所有属性和方法。</p>
<p><strong>总结</strong>：三者的关系是，每个构造函数都有一个原型对象，原型对象上包含一个指向构造函数的指针，而实例都包含着一个指向原型对象的内部指针。通俗的说，实例可以通过内部指针访问到原型对象，原型对象可以通过constructor找到构造函数。</p>
<span id="more"></span>
<ul>
<li><code>实例.__proto__ === 原型</code></li>
<li><code>原型.constructor === 构造函数</code></li>
<li><code>构造函数.prototype === 原型</code></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yinlifan/img/20220805151309.png"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>柯里化</title>
    <url>/2021/10/06/%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>柯里化就是把接收多个参数的函数转化成接收单一参数的函数，并且返回一个（可以接收剩余参数的）新函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (a, b) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>add</code>接受两个参数<code>a</code>和<code>b</code>。</p>
<p>柯里化就是将上面的函数拆分成两个函数，每个函数都只接受一个参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (a) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者采用箭头函数写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = x =&gt; <span class="function"><span class="params">y</span> =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">const</span> f = <span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">f</span>(<span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>add</code>只接受一个参数<code>a</code>，返回一个函数<code>f</code>。函数<code>f</code>也只接受一个参数<code>b</code>。</p>
<span id="more"></span>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>可以延迟计算，也就是调用柯里化函数时传入的参数不是立即调用的，而是只有当满足一定条件时才会（将已经在数组中存储的参数作为参数）执行；参数可以复用，当多次调用同一个函数，并且传递的参数绝大多数是相同的，那么该函数可能是一个很好的柯里化函数。</p>
<h4 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h4><p>1.lodash 库中的 curry 方法就是一个柯里化函数</p>
<p><a href="https://www.lodashjs.com/docs/lodash.curry">https://www.lodashjs.com/docs/lodash.curry</a></p>
<p>2.自己实现一个柯里化函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b,c,d</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">curring</span> = (<span class="params">fn:<span class="built_in">Function</span></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">exec</span> = (<span class="params">sumArgs:any[] = []</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> sumArgs.<span class="property">length</span> &gt;= fn.<span class="property">length</span> ? <span class="title function_">fn</span>(...sumArgs) </span><br><span class="line">      : <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="title function_">exec</span>([...sumArgs,...args])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">exec</span>()   <span class="comment">//exec()的参数可以是初始化的值，可以是重复传递的参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = <span class="title function_">curring</span>(sum)(......)</span><br><span class="line"><span class="comment">//&quot;......&quot;指的是传递给sum函数的参数，形式有两种，如1.（1，2，3，4） 2. （1，2）（3）（4）......</span></span><br><span class="line">                        </span><br></pre></td></tr></table></figure>

<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><h5 id="1-减少重复不变的参数"><a href="#1-减少重复不变的参数" class="headerlink" title="1.减少重复不变的参数"></a>1.减少重复不变的参数</h5><p>实现url的拼接，如果我们要拼接一个url,即协议+域名+路径，那么重复参数的情况便出现，如协议是http还是https?</p>
<p>如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">splicingUrl</span>(<span class="params">protocol,domain,path</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;protocol&#125;</span>://<span class="subst">$&#123;domain&#125;</span>/<span class="subst">$&#123;path&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">splicingUrl</span>(http,www.<span class="property">baidu</span>.<span class="property">com</span>,home)</span><br><span class="line"><span class="title function_">splicingUrl</span>(https,taobao.<span class="property">com</span>,datail)</span><br></pre></td></tr></table></figure>

<p>下面通过柯里化实现减少传递重复参数的功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">splicingUrl</span>(<span class="params">protocol,domain,path</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;protocol&#125;</span>://<span class="subst">$&#123;domain&#125;</span>/<span class="subst">$&#123;path&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">curryPackage</span> = (<span class="params">fn:<span class="built_in">Function</span></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">curryFunc</span> = (<span class="params">splicingArgs:any[] = []</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> splicingArgs.<span class="property">length</span> &gt;= fn.<span class="property">length</span> ? <span class="title function_">fn</span>(...splicingArgs) </span><br><span class="line">        : <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="title function_">curryFunc</span>([...splicingArgs,...args])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">curryFunc</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newCurry = <span class="title function_">curryPackage</span>(splicingUrl)(<span class="string">&#x27;http&#x27;</span>,<span class="string">&#x27;www.baiducom&#x27;</span>)</span><br><span class="line"><span class="title function_">newCurry</span>(<span class="string">&#x27;home.html&#x27;</span>)   <span class="comment">//http://www.baiducom/home.html</span></span><br><span class="line"><span class="title function_">newCurry</span>(<span class="string">&#x27;photo.html&#x27;</span>)  <span class="comment">//http://www.baiducom/photo.html</span></span><br></pre></td></tr></table></figure>



<h5 id="2-将柯里化之后的callback参数传递给map-x2F-filter等函数"><a href="#2-将柯里化之后的callback参数传递给map-x2F-filter等函数" class="headerlink" title="2.将柯里化之后的callback参数传递给map&#x2F;filter等函数"></a>2.将柯里化之后的callback参数传递给map&#x2F;filter等函数</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> studentsInfo = [&#123;<span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&#x27;jarry&#x27;</span>,<span class="attr">age</span>:<span class="number">32</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&#x27;susan&#x27;</span>,<span class="attr">age</span>:<span class="number">33</span>&#125;]</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getObj</span>(<span class="params">key,obj</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将callback进行柯里化</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> curryCallback = <span class="title function_">_curry</span>(getObj)</span><br><span class="line"><span class="keyword">let</span> nameArray = studentsInfo.<span class="title function_">map</span>(<span class="title function_">curryCallback</span>(<span class="string">&#x27;name&#x27;</span>));  <span class="comment">// [&#x27;tom&#x27;,&#x27;jarry&#x27;,&#x27;susan&#x27;]</span></span><br><span class="line"><span class="keyword">let</span> agesArray = studentsInfo.<span class="title function_">map</span>(<span class="title function_">curryCallback</span>(<span class="string">&#x27;age&#x27;</span>));   <span class="comment">// [19,32,33]</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器事件循环</title>
    <url>/2019/06/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h4 id="说说你对事件循环的理解"><a href="#说说你对事件循环的理解" class="headerlink" title="说说你对事件循环的理解"></a>说说你对事件循环的理解</h4><p>event loop过程1：</p>
<ul>
<li>同步代码，一行一行在call stack（执行栈）执行</li>
<li>遇到异步，会先“记录”下，等待时机（定时，网络请求等）</li>
<li>时机到了，就移动到 Callback Queue （回调队列）</li>
</ul>
<p>event loop过程2：</p>
<ul>
<li>如Call Stack为空（及代码执行完）Event loop 开始工作</li>
<li>轮询查找Callback Queue，如有则移动到 Call Stack执行</li>
<li>然后继续轮询查找（永动机一样）</li>
</ul>
<p><a href="http://zslin.xyz/2019/06/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/69.png"><img src="http://zslin.xyz/2019/06/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/69.png" alt="img"></a></p>
<p><a href="http://zslin.xyz/2019/06/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/70.png"><img src="http://zslin.xyz/2019/06/05/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/70.png" alt="img"></a></p>
<h5 id="宏任务："><a href="#宏任务：" class="headerlink" title="宏任务："></a>宏任务：</h5><ul>
<li><p>我们可以将每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</p>
</li>
<li><p>每一个宏任务会从头到尾执行完毕，不会执行其他</p>
<blockquote>
<p>浏览器为了能够使js内部宏任务与dom任务有序的执行，会在一个宏任务执行结束后，在下一个宏任务执行开始前，对页面进行重新渲染。</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宏任务</span><span class="literal">--</span>&gt;<span class="comment">渲染</span><span class="literal">--</span>&gt;<span class="comment">宏任务</span><span class="literal">--</span>&gt;<span class="comment">渲染</span><span class="literal">--</span>&gt;<span class="comment">渲染．．</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>js代码</li>
<li>setTimeout</li>
<li>Ajax</li>
<li>Dom事件</li>
</ul>
</li>
</ul>
<h5 id="微任务："><a href="#微任务：" class="headerlink" title="微任务："></a>微任务：</h5><ul>
<li>我们已经知道 宏任务结束后，会执行渲染，然后执行下一个 宏任务。</li>
<li>而微任务可以理解成在当前 宏任务执行后立即执行的任务。</li>
<li>也就是说，当宏任务执行完，会在渲染前，将执行期间所产生的所有 微任务都执行完。<ul>
<li>Promise async&#x2F;</li>
<li>nextTick（Node.js）</li>
<li>MutaionObserver</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>Event Loop</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染机制</title>
    <url>/2019/06/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h4 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h4><h5 id="1-渲染机制步骤步骤："><a href="#1-渲染机制步骤步骤：" class="headerlink" title="1.渲染机制步骤步骤："></a>1.渲染机制步骤步骤：</h5><ul>
<li>处理<code>HTML</code>并构建<code>DOM</code>树</li>
<li>处理<code>css</code>构建<code>cssdom</code>树</li>
<li>将<code>DOM</code>与<code>cssdom</code>合并成一个渲染树</li>
<li>根据渲染树来布局，计算每个节点的位置</li>
<li>调用<code>GPU</code>绘制，合成图层，显示在屏幕上</li>
</ul>
<p><a href="http://zslin.xyz/2019/06/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/98.png"><img src="http://zslin.xyz/2019/06/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9D%97/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/98.png" alt="img"></a></p>
<p>在构建cssdom树时，会阻塞渲染，直至cssdom树构建完成。并且构建cssdom树是一个十分消耗性能的过程，所以尽量保证层级扁平，减少过度层叠，越是具体的css选择器，执行速度越慢。</p>
<p>css是阻塞渲染的资源。需要将他尽早，尽快的下载到客户端，以便缩短首次渲染的时间。</p>
<p>当html解析到script标签时，会暂停构建dom，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载js文件。并且css也会影响js的执行，只有当解析完样式才会执行js，所以也可以认为这种情况下，css也会暂停构建dom。</p>
<span id="more"></span>
<h5 id="2-图层"><a href="#2-图层" class="headerlink" title="2.图层"></a>2.图层</h5><blockquote>
<p>一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。</p>
</blockquote>
<p>通过以下几个常用属性可以生成新图层</p>
<ul>
<li><code>3D</code>变换：<code>translate3d</code>,<code>reanslatez</code></li>
<li><code>will-change</code></li>
<li><code>video</code>,<code>iframe</code>标签</li>
<li>通过动画实现的<code>opacity</code>动画转换</li>
<li><code>position：fixed</code></li>
</ul>
<h5 id="3-重绘与回流"><a href="#3-重绘与回流" class="headerlink" title="3.重绘与回流"></a>3.重绘与回流</h5><blockquote>
<ul>
<li>重绘(repaint)：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此，损耗较少</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>回流(reflow)：当元素的尺寸，结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作：</li>
</ul>
</blockquote>
<p>触发回流和重绘的操作：</p>
<ul>
<li>页面初次渲染</li>
<li>浏览器窗口大小发生改变</li>
<li>元素尺寸，位置，内容发生改变</li>
<li>元素字体大小变化</li>
<li>添加或者删除可见的dom元素</li>
<li>激活css伪类（列如：hover）</li>
<li>查询某些属性或调用某些方法<ul>
<li><code>clientWidth、clientHeight、clientTop、clientLeft</code></li>
<li><code>offsetWidth、offsetHeight、offsetTop、offsetLeft</code></li>
<li><code>scrollWidth、scrollHeight、scrollTop、scrollLeft</code></li>
<li><code>getComputedStyle()</code></li>
<li><code>getBoundingClientRect()</code></li>
<li><code>scrollTo()</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>回流必定触发重绘，重绘不不一定触发回流。重绘的开销小，回流的代价高。</p>
</blockquote>
<p>避免回流的优化：</p>
<ul>
<li>css层面：<ul>
<li>不要使用css表达式</li>
<li>避免table布局</li>
<li>避免多层嵌套样式</li>
</ul>
</li>
<li>js层面：<ul>
<li>避免频繁操作DOM，可以创建一个documentFragment文档流片段，在它上面应用所有dom操作，最后再把它添加到文档中。</li>
<li>避免频繁操作样式</li>
<li>可以先为元素设置不可见：<code>display：none</code>，操作结束后在显示出来。</li>
</ul>
</li>
</ul>
<h5 id="4-javascript会阻塞dom生成"><a href="#4-javascript会阻塞dom生成" class="headerlink" title="4.javascript会阻塞dom生成"></a>4.javascript会阻塞dom生成</h5><blockquote>
<p>javascript 会阻塞dom生成，而样式文件又会阻塞javascriot执行，所以在实际的工程中需要重点关注javascript文件和样式表文件，使用不当会影响页面性能的</p>
</blockquote>
<blockquote>
<p>当渲染进程接收html文件字节流时，会先开启一个与解析线程，如果遇到javascipt文件或者css文件，那么与解析线程会提前下载这些数据</p>
</blockquote>
<ul>
<li>如果代码里引用了外部的css文件，那么在执行javascript之前，还需要等待外部的css文件下载完成，并解析生成cssdom对象之后，才能执行javascript脚本。</li>
<li>而javascript引擎在解析javascript之前，是不知道javascript是否操作了cssdom的，所以渲染引擎在遇到javascript脚本时，不管脚本是否操作了cssdom，都会执行css文件下载，解析操作，在执行javascript脚本。</li>
<li>不管css文件和javascript文件谁先到达，都要等到css文件下载完成并生成cssdom，然后在执行javascript脚本，最后再继续构建dom，构建布局树，绘制页面。</li>
</ul>
<h5 id="5-缩短白屏时长的策略"><a href="#5-缩短白屏时长的策略" class="headerlink" title="5.缩短白屏时长的策略"></a>5.缩短白屏时长的策略</h5><ul>
<li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。</li>
<li>但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。</li>
<li>还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer</li>
<li>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器的夸标签页通讯</title>
    <url>/2019/06/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%A4%B8%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<h4 id="1-跨标签页通讯"><a href="#1-跨标签页通讯" class="headerlink" title="1.跨标签页通讯"></a>1.跨标签页通讯</h4><blockquote>
<p>不同标签页面间的通讯，本质与哪里就是去运用一些可以 共享的中间介质，因此比较常用的有以下方法：</p>
</blockquote>
<ul>
<li>通过父页面<code>windowopen()</code>和子页面<code>postmessage</code><ul>
<li>异步下通过<code>windowopen(&#39;about：blank&#39;)</code>和<code>tablocationhref=&#39;*&#39;</code></li>
</ul>
</li>
<li>同域下共享的<code>localStorage</code>与监听<code>windowonstorage</code><ul>
<li>重复写入相同的值无法触发</li>
<li>会受到浏览器隐身模式等限制</li>
</ul>
</li>
<li>共同设置<code>cookie</code>与不断轮询脏检查(<code>setInterval</code>)</li>
<li>借助服务端或者中间层实现。</li>
</ul>
<h4 id="2-浏览器架构"><a href="#2-浏览器架构" class="headerlink" title="2.浏览器架构"></a>2.浏览器架构</h4><ul>
<li>用户主界面</li>
<li>主进程</li>
<li>内核<ul>
<li>渲染引擎</li>
<li>JS引擎<ul>
<li>执行栈</li>
</ul>
</li>
</ul>
</li>
<li>事件触发线程<ul>
<li>消息队列<ul>
<li>微任务</li>
<li>宏任务</li>
</ul>
</li>
</ul>
</li>
<li>网络异步线程</li>
<li>定时器线程</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖与节流</title>
    <url>/2018/06/05/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><h4 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1.是什么"></a>1.是什么</h4><p>本质上是优化高频率执行代码的一种手段</p>
<p>如：浏览器的 <code>resize</code>、<code>scroll</code>、<code>keypress</code>、<code>mousemove</code> 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能</p>
<p>为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 <strong>防抖（debounce）</strong> 和 <strong>节流（throttle）</strong> 的方式来减少调用频率</p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul>
<li>节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</li>
<li>防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</li>
</ul>
<p>一个经典的比喻:</p>
<p>想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应</p>
<p>假设电梯有两种运行策略 <code>debounce</code> 和 <code>throttle</code>，超时设定为15秒，不考虑容量限制</p>
<p>电梯第一个人进来后，15秒后准时运送一次，这是节流</p>
<p>电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖</p>
<span id="more"></span>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p><strong>节流</strong></p>
<p>完成节流可以使用时间戳与定时器的写法</p>
<p>使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttled1</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> newtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">        <span class="keyword">if</span> (newtime - oldtime &gt;= delay) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="literal">null</span>, args)</span><br><span class="line">            oldtime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用定时器写法，<code>delay</code>毫秒后第一次执行，第二次事件停止触发后依然会再一次执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttled2</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流。实现如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttled</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> starttime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> curTime = <span class="title class_">Date</span>.<span class="title function_">now</span>() <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="keyword">let</span> remaining = delay - (curTime - starttime)  <span class="comment">// 从上一次到现在，还剩下多少多余时间</span></span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span></span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(context, args)</span><br><span class="line">            starttime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(fn, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>防抖</strong></p>
<p>简单版本的实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span>; <span class="comment">// 保存this指向</span></span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>; <span class="comment">// 拿到event对象</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>防抖如果需要立即执行，可加入第三个参数用于判断，实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait, immediate</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout); <span class="comment">// timeout 不为null</span></span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="keyword">let</span> callNow = !timeout; <span class="comment">// 第一次会立即执行，以后只有事件执行后才会再次触发</span></span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">                func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                func.<span class="title function_">apply</span>(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-区别"><a href="#2-区别" class="headerlink" title="2.区别"></a>2.区别</h4><h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h5><ul>
<li>都可以通过使用 <code>setTimeout</code> 实现</li>
<li>目的都是，降低回调执行频率。节省计算资源</li>
</ul>
<h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h5><ul>
<li>函数防抖，在一段连续操作结束后，处理回调，利用<code>clearTimeout</code>和 <code>setTimeout</code>实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能</li>
<li>函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次</li>
</ul>
<p>例如，都设置时间频率为500ms，在2秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在2s后，只会执行一次</p>
<p><img src="https://cdn.jsdelivr.net/gh/yinlifan/img/20220805170526.png"></p>
<h4 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h4><p>防抖在连续的事件，只需触发一次回调的场景有：</p>
<ul>
<li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li>
<li>手机号、邮箱验证输入检测</li>
<li>窗口大小<code>resize</code>。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li>
</ul>
<p>节流在间隔一段时间执行一次回调的场景有：</p>
<ul>
<li>滚动加载，加载更多或滚到底部监听</li>
<li>搜索框，搜索联想功能</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>页面布局</title>
    <url>/2019/07/03/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><h4 id="通栏布局："><a href="#通栏布局：" class="headerlink" title="通栏布局："></a>通栏布局：</h4><p>浏览器左侧固定，右侧自适应。<br>1.flex布局，左侧固定宽，右侧flex：1<br>2.两个盒子分别左浮右浮，右侧盒子减去左侧盒子的宽 100% - 宽<br>3.左侧盒子左浮动，右侧盒子设置 margin-left：左侧盒子的宽</p>
<span id="more"></span>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">		<span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">			<span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">		&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 方案2 </span></span></span><br><span class="line"><span class="comment"><span class="language-css">        .left &#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            width: 120px;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            float: left;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        &#125;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        .right &#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            margin-left: 120px;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        &#125; */</span></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 方案3 </span></span></span><br><span class="line"><span class="comment"><span class="language-css">        .left &#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            width: 120px;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            float: left;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        &#125;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        .right &#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            width: calc(100% - 120px);</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            float: left;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        &#125; */</span></span></span><br><span class="line"><span class="language-css">	</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左侧<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右侧<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="圣杯布局："><a href="#圣杯布局：" class="headerlink" title="圣杯布局："></a>圣杯布局：</h4><p>左右两侧固定，中间自适应。<br>1.使用浮动和定位实现。<br>2.左右盒子加float分别左浮，右浮，中间盒子百分比减去俩盒子的宽。<br>3.flex布局，左右给固定宽，中间给flex：1 。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 方案3</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        .box &#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            display: flex;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        &#125;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        .left &#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            width: 120px;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        &#125;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        .right &#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            width: 120px;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        &#125;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        .center &#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            flex: 1;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        &#125; */</span></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 方案2</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        .left &#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            width: 120px;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            float: left;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        &#125;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        .right &#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            float: right;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            width: 120px;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        &#125;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        .center &#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            width: calc(100% - 240px);</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            margin-left: 120px;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">        &#125; */</span></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        * &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* //设置基础样式 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">header</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">footer</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 清除浮动 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.center</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">right</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-right</span>: -<span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.center</span>,</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.left</span>,</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span>顶部<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左侧<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右侧<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span>底部<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="双飞翼布局："><a href="#双飞翼布局：" class="headerlink" title="双飞翼布局："></a>双飞翼布局：</h4><p>和圣杯布局相似，但是元素结构有点变化，没用到定位。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        * &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* //设置基础样式 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">header</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">footer</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 清除浮动 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.center</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.center</span>,</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.left</span>,</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span>顶部<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左侧<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右侧<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span>底部<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript几种继承方法</title>
    <url>/2020/07/20/JavaScript%E5%87%A0%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="JavaScript实现继承的几种方法"><a href="#JavaScript实现继承的几种方法" class="headerlink" title="JavaScript实现继承的几种方法"></a>JavaScript实现继承的几种方法</h4><h5 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h5><p>构造函数，原型，实例之间的关系：每一个构造函数都有一个原型对象(prototype)，原型对象中有一个指向构造函数的指针()，然而实例对象中包含一个指向原型对象的指针(<em>proto</em>)。</p>
<span id="more"></span>
<ul>
<li><p>优点：父类方法可以复用。</p>
</li>
<li><p>缺点：</p>
<ul>
<li>父类中所有引用类型的数据（对象，数组）会被子类共享。只要更改了其中一个子类的数据。其他数据都会受到影响，一起变化。</li>
<li>子类实例不能给父类构造函数传递参数。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类Person</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eats</span> = [<span class="string">&#x27;苹果&#x27;</span>]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在父类原型上定义方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person的原型上的get方法&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="comment">//将子类的原型指向父类的实例对象</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子类实例对象，会拥有父类Person所有的属性，方法。</span></span><br><span class="line"><span class="keyword">const</span> children = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line">children.<span class="property">name</span>=<span class="string">&#x27;赵先生&#x27;</span></span><br><span class="line">children.<span class="property">eats</span>.<span class="title function_">push</span>(<span class="string">&#x27;香蕉&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(children.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(children.<span class="property">eats</span>)</span><br><span class="line">children.<span class="title function_">getName</span>()</span><br><span class="line">children.<span class="title function_">get</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-----------------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子类实例对象，会拥有父类Person所有的属性，方法。</span></span><br><span class="line"><span class="keyword">const</span> children2 = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(children2.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(children2.<span class="property">eats</span>)</span><br><span class="line">children2.<span class="title function_">getName</span>()</span><br><span class="line">children2.<span class="title function_">get</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">赵先生</span></span><br><span class="line"><span class="comment">[&quot;苹果&quot;,&quot;香蕉&quot;]</span></span><br><span class="line"><span class="comment">赵先生</span></span><br><span class="line"><span class="comment">Person的原型上的get方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">小明</span></span><br><span class="line"><span class="comment">[&quot;苹果&quot;,&quot;香蕉&quot;]</span></span><br><span class="line"><span class="comment">小明</span></span><br><span class="line"><span class="comment">Person的原型上的get方法*/</span></span><br></pre></td></tr></table></figure>

<h5 id="2-构造函数继承"><a href="#2-构造函数继承" class="headerlink" title="2.构造函数继承"></a>2.构造函数继承</h5><ul>
<li><p>优点：父类的引用类型的数据，不会被子类共享。不会互相影响。</p>
</li>
<li><p>缺点：不能访问父类构造函数原型上（Person.prototype）的参数和方法。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类Person</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eats</span> = [<span class="string">&#x27;苹果&#x27;</span>]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在父类原型上定义方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person的原型上的get方法&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子类实例对象，会拥有父类Person构造函数的属性，方法。</span></span><br><span class="line"><span class="keyword">const</span> children = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line">children.<span class="property">name</span> = <span class="string">&#x27;赵先生&#x27;</span></span><br><span class="line">children.<span class="property">eats</span>.<span class="title function_">push</span>(<span class="string">&#x27;香蕉&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(children.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(children.<span class="property">eats</span>)</span><br><span class="line">children.<span class="title function_">getName</span>()</span><br><span class="line"><span class="comment">// children.get()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-----------------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子类实例对象，会拥有父类Person构造函数的属性，方法。</span></span><br><span class="line"><span class="keyword">const</span> children2 = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(children2.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(children2.<span class="property">eats</span>)</span><br><span class="line">children2.<span class="title function_">getName</span>()</span><br><span class="line"><span class="comment">// children2.get()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">赵先生</span></span><br><span class="line"><span class="comment">[&quot;苹果&quot;,&quot;香蕉&quot;]</span></span><br><span class="line"><span class="comment">赵先生</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">小明</span></span><br><span class="line"><span class="comment">[&quot;苹果&quot;]</span></span><br><span class="line"><span class="comment">小明</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h5><ul>
<li><p>优点：组合继承就是将 原型链继承和构造函数继承 结合起来。解决了这种继承的弊端。</p>
</li>
<li><p>缺点：会调用两次父类构造函数，拥有两份一样的属性和方法。影响性能的开销。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类Person</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eats</span> = [<span class="string">&#x27;苹果&#x27;</span>]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在父类原型上定义方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person的原型上的get方法&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>=<span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子类实例对象，会拥有父类Person构造函数的属性，方法。</span></span><br><span class="line"><span class="keyword">const</span> children = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line">children.<span class="property">name</span> = <span class="string">&#x27;赵先生&#x27;</span></span><br><span class="line">children.<span class="property">eats</span>.<span class="title function_">push</span>(<span class="string">&#x27;香蕉&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(children.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(children.<span class="property">eats</span>)</span><br><span class="line">children.<span class="title function_">getName</span>()</span><br><span class="line">children.<span class="title function_">get</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-----------------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子类实例对象，会拥有父类Person构造函数的属性，方法。</span></span><br><span class="line"><span class="keyword">const</span> children2 = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(children2.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(children2.<span class="property">eats</span>)</span><br><span class="line">children2.<span class="title function_">getName</span>()</span><br><span class="line">children2.<span class="title function_">get</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">赵先生</span></span><br><span class="line"><span class="comment">[&quot;苹果&quot;,&quot;香蕉&quot;]</span></span><br><span class="line"><span class="comment">赵先生</span></span><br><span class="line"><span class="comment">Person的原型上的get方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-----------------------------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">小明</span></span><br><span class="line"><span class="comment">[&quot;苹果&quot;]</span></span><br><span class="line"><span class="comment">小明</span></span><br><span class="line"><span class="comment">Person的原型上的get方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-寄生式组合继承"><a href="#4-寄生式组合继承" class="headerlink" title="4.寄生式组合继承"></a>4.寄生式组合继承</h5><ul>
<li>在组合继承的基础之上，做了一个中转，不在创建父类实例（new Person()），创建一个空的函数，将该函数的原型指向父类person的原型。之后在将子类的原型指向该函数的实例对象即可。是目前相对最优的继承方式。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类Person</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eats</span> = [<span class="string">&#x27;苹果&#x27;</span>]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在父类原型上定义方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person的原型上的get方法&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="comment">//创建空的函数，做中转，该函数指向父类的原型</span></span><br><span class="line"><span class="comment">//const fn = function()&#123;&#125;</span></span><br><span class="line"><span class="comment">//fn.prototype = Person.prototype</span></span><br><span class="line"><span class="comment">//最后子类的原型指向该函数的实例</span></span><br><span class="line"><span class="comment">//Child.prototype=new fn()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子类实例对象，会拥有父类Person构造函数的属性，方法。</span></span><br><span class="line"><span class="keyword">const</span> children = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line">children.<span class="property">name</span> = <span class="string">&#x27;赵先生&#x27;</span></span><br><span class="line">children.<span class="property">eats</span>.<span class="title function_">push</span>(<span class="string">&#x27;香蕉&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(children.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(children.<span class="property">eats</span>)</span><br><span class="line">children.<span class="title function_">getName</span>()</span><br><span class="line">children.<span class="title function_">get</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-----------------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子类实例对象，会拥有父类Person构造函数的属性，方法。</span></span><br><span class="line">  <span class="keyword">const</span> children2 = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(children2.<span class="property">name</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(children2.<span class="property">eats</span>)</span><br><span class="line">  children2.<span class="title function_">getName</span>()</span><br><span class="line">  children2.<span class="title function_">get</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="5-es6-class继承"><a href="#5-es6-class继承" class="headerlink" title="5.es6 class继承"></a>5.es6 class继承</h5><p>使用class构造一个父类， 构造一个子类使用extends来继承父类。super指向父类的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tt</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sdfsdfsdfsdfdsaf&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原型上的方法</span></span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age, gender</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name, age)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原型上的方法</span></span><br><span class="line">    <span class="title function_">sayGender</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">gender</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ming = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;ming&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">ming.<span class="title function_">sayGender</span>()</span><br><span class="line">ming.<span class="title function_">sayName</span>()</span><br><span class="line">ming.<span class="title function_">tt</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ming.<span class="property">name</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ming.<span class="property">age</span>);</span><br><span class="line"><span class="comment">//console.log(ming)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">男</span></span><br><span class="line"><span class="comment">ming</span></span><br><span class="line"><span class="comment">sdfsdfsdfsdfdsaf</span></span><br><span class="line"><span class="comment">ming</span></span><br><span class="line"><span class="comment">18</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><h4 id="第⼀部分：预备知识"><a href="#第⼀部分：预备知识" class="headerlink" title="第⼀部分：预备知识"></a>第⼀部分：预备知识</h4><h5 id="1、构造函数的属性"><a href="#1、构造函数的属性" class="headerlink" title="1、构造函数的属性"></a>1、构造函数的属性</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">funcion <span class="title function_">A</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">// 实例基本属性 (该属性，强调私有，不共享)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span> = [<span class="number">1</span>]; <span class="comment">// 实例引⽤属性 (该属性，强调私⽤，不共享)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 实例引⽤属性 (该属性，强调复⽤，需要共享)</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*注意：数组和⽅法都属于‘实例引⽤属性’，但是数组强调私有、不共享的。⽅法需要复⽤、共享。</span></span><br><span class="line"><span class="comment">在构造函数中，⼀般很少有数组形式的引⽤属性，⼤部分情况都是：基本属性 + ⽅法。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">JAVASCRIPT</span></span><br></pre></td></tr></table></figure>

<h5 id="2、什么是原型对象"><a href="#2、什么是原型对象" class="headerlink" title="2、什么是原型对象"></a>2、什么是原型对象</h5><p>简单来说，每个函数都有prototype属性，它就是原型对象，通过函数实例化出来的对象有个 __proto__属性，指向原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">A</span>()</span><br><span class="line">a.<span class="property">__proto__</span> == A.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// prototype的结构如下</span></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: A,</span><br><span class="line">    ...其他的原型属性和⽅法</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3、原型对象的作用"><a href="#3、原型对象的作用" class="headerlink" title="3、原型对象的作用"></a>3、原型对象的作用</h5><p>原型对象的⽤途是为每个实例对象存储共享的⽅法和属性，它仅仅是⼀个普通对象⽽已。并且所有 的实例是共享同⼀个原型对象，因此有别于实例⽅法或属性，原型对象仅有⼀份。⽽实例有很多 份，且实例属性和⽅法是独⽴的。在构造函数中：为了属性(实例基本属性)的私有性、以及⽅法(实 例引⽤属性)的复⽤、共享。我们提倡：</p>
<ul>
<li>将属性封装在构造函数中</li>
<li>将⽅法定义在原型对象上</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">funcion <span class="title function_">A</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">// (该属性，强调私有，不共享)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 定义在原型对象上的⽅法 (强调复⽤，需要共享)</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐的写法：[原因](https://blog.csdn.net/kkkkkxiaofei/article/details/46474303)</span></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">say</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="第⼆部分：五种js-继承⽅式"><a href="#第⼆部分：五种js-继承⽅式" class="headerlink" title="第⼆部分：五种js 继承⽅式"></a>第⼆部分：五种js 继承⽅式</h4><h5 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h5><ul>
<li>核⼼：将⽗类实例作为⼦类原型</li>
<li>优点：⽅法复⽤</li>
<li>由于⽅法定义在⽗类的原型上，复⽤了⽗类构造函数的⽅法。⽐如say⽅法。</li>
<li>缺点：</li>
<li>创建⼦类实例的时候，不能传⽗类的参数（⽐如name）。</li>
<li>⼦类实例共享了⽗类构造函数的引⽤属性，⽐如arr属性。</li>
<li>⽆法实现多继承。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name || <span class="string">&#x27;⽗亲&#x27;</span>; <span class="comment">// 实例基本属性 (该属性，强调私有，不共享)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span> = [<span class="number">1</span>]; <span class="comment">// (该属性，强调私有)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// -- 将需要复⽤、共享的⽅法定义在⽗类原型上</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">like</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">like</span> = like;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>() <span class="comment">// 核⼼，但此时Child.prototype.constructor==Parent</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span> <span class="comment">// 修正constructor指向</span></span><br><span class="line"><span class="keyword">let</span> boy1 = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"><span class="keyword">let</span> boy2 = <span class="keyword">new</span> <span class="title class_">Child</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点：共享了⽗类构造函数的say⽅法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy1.<span class="title function_">say</span>(), boy2.<span class="title function_">say</span>(), boy1.<span class="property">say</span> === boy2.<span class="property">say</span>); <span class="comment">// hello , hello , true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺点1：不能向⽗类构造函数传参</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy1.<span class="property">name</span>, boy2.<span class="property">name</span>, boy1.<span class="property">name</span>===boy2.<span class="property">name</span>); <span class="comment">// ⽗亲，⽗亲，true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺点2: ⼦类实例共享了⽗类构造函数的引⽤属性，⽐如arr属性</span></span><br><span class="line">boy1.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改了boy1的arr属性，boy2的arr属性，也会变化，因为两个实例的原型上(Child.prototype)有了⽗类构造函数的实例属性arr；</span></span><br><span class="line"><span class="comment">//所以只要修改了boy1.arr，boy2.arr的属性也会变化。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy2.<span class="property">arr</span>); <span class="comment">// [1,2]</span></span><br><span class="line"><span class="comment">//注意1：修改boy1的name属性，是不会影响到boy2.name。因为设置boy1.name相当于在⼦类实例新增了name属性。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注意2：</span></span><br><span class="line"><span class="comment">console.log(boy1.constructor); // Parent 你会发现实例的构造函数居然是Parent。</span></span><br><span class="line"><span class="comment">⽽实际上，我们希望⼦类实例的构造函数是Child,所以要记得修复构造函数指向。</span></span><br><span class="line"><span class="comment">修复如下：Child.prototype.constructor = Child; */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2、借⽤构造函数"><a href="#2、借⽤构造函数" class="headerlink" title="2、借⽤构造函数"></a>2、借⽤构造函数</h5><ul>
<li><p>核⼼：借⽤⽗类的构造函数来增强⼦类实例，等于是复制⽗类的实例属性给⼦类。</p>
</li>
<li><p>优点：实例之间独⽴。</p>
<ul>
<li>创建⼦类实例，可以向⽗类构造函数传参数。</li>
<li>⼦类实例不共享⽗类构造函数的引⽤属性。如arr属性</li>
<li>可实现多继承（通过多个call或者apply继承多个⽗类）</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>⽗类的⽅法不能复⽤</p>
<p>由于⽅法在⽗构造函数中定义，导致⽅法不能复⽤(因为每次创建⼦类实例都要创建⼀遍⽅法)。 ⽐如say⽅法。(⽅法应该要复⽤、共享)</p>
</li>
<li><p>⼦类实例，继承不了⽗类原型上的属性。(因为没有⽤到原型)</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">// 实例基本属性 (该属性，强调私有，不共享)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span> = [<span class="number">1</span>]; <span class="comment">// (该属性，强调私有)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 实例引⽤属性 (该属性，强调复⽤，需要共享)</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name,like</span>) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,name); <span class="comment">// 核⼼ 拷⻉了⽗类的实例属性和⽅法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">like</span> = like;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> boy1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;⼩红&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> boy2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;⼩明&#x27;</span>, <span class="string">&#x27;orange &#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点1：可向⽗类构造函数传参</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy1.<span class="property">name</span>, boy2.<span class="property">name</span>); <span class="comment">// ⼩红， ⼩明</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点2：不共享⽗类构造函数的引⽤属性</span></span><br><span class="line">boy1.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy1.<span class="property">arr</span>,boy2.<span class="property">arr</span>);<span class="comment">// [1,2] [1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//详解js继承 4</span></span><br><span class="line"><span class="comment">// 缺点1：⽅法不能复⽤</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy1.<span class="property">say</span> === boy2.<span class="property">say</span>) <span class="comment">// false (说明，boy1和boy2的say⽅法是独⽴，不是共享的)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺点2：不能继承⽗类原型上的⽅法</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">walk</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 在⽗类的原型对象上定义⼀个walk⽅法。</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我会⾛路&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boy1.<span class="property">walk</span>; <span class="comment">// undefined (说明实例，不能获得⽗类原型上的⽅法)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3、组合继承-核心"><a href="#3、组合继承-核心" class="headerlink" title="3、组合继承 核心"></a>3、组合继承 核心</h5><ul>
<li>通过调⽤⽗类构造函数，继承⽗类的属性并保留传参的优点；然后通过将⽗类实例作为 ⼦类原型，实现函数复⽤。</li>
<li>优点：</li>
<li>保留构造函数的优点：创建⼦类实例，可以向⽗类构造函数传参数。</li>
<li>保留原型链的优点：⽗类的⽅法定义在⽗类的原型对象上，可以实现⽅法复⽤。</li>
<li>不共享⽗类的引⽤属性。⽐如arr属性</li>
<li>缺点：<ul>
<li>由于调⽤了2次⽗类的构造⽅法，会存在⼀份多余的⽗类实例属性，具体原因⻅⽂末。</li>
</ul>
</li>
<li>注意：’组合继承’这种⽅式，要记得修复Child.prototype.constructor指向</li>
</ul>
<p>第⼀次Parent.call(this);从⽗类拷⻉⼀份⽗类实例属性，作为⼦类的实例属性，第⼆次 Child.prototype &#x3D; new Parent();创建⽗类实例作为⼦类原型，Child.protype中的⽗类属性和⽅法 会被第⼀次拷⻉来的实例属性屏蔽掉，所以多余。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">// 实例基本属性 (该属性，强调私有，不共享)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span> = [<span class="number">1</span>]; <span class="comment">// (该属性，强调私有)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// --- 将需要复⽤、共享的⽅法定义在⽗类原型上</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name,like</span>) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,name,like) <span class="comment">// 核⼼ 第⼆次</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">like</span> = like;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>() <span class="comment">// 核⼼ 第⼀次</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span> <span class="comment">// 修正constructor指向</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> boy1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;⼩红&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> boy2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;⼩明&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点1：可以向⽗类构造函数传参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy1.<span class="property">name</span>,boy1.<span class="property">like</span>); <span class="comment">// ⼩红，apple</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点2：可复⽤⽗类原型上的⽅法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy1.<span class="property">say</span> === boy2.<span class="property">say</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//详解js继承 5</span></span><br><span class="line"><span class="comment">// 优点3：不共享⽗类的引⽤属性，如arr属性</span></span><br><span class="line">boy1.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy1.<span class="property">arr</span>,boy2.<span class="property">arr</span>); <span class="comment">// [1,2] [1] 可以看出没有共享arr属性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺点1：由于调⽤了2次⽗类的构造⽅法，会存在⼀份多余的⽗类实例属性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实Child.prototype &#x3D; new Parent()</p>
<p>console.log(Child.prototype.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Parent.prototype); &#x2F;&#x2F; true</p>
<p>因为Child.prototype等于Parent的实例，所以__proto__指向Parent.prototype 。</p>
<h5 id="4、组合继承优化1"><a href="#4、组合继承优化1" class="headerlink" title="4、组合继承优化1"></a>4、组合继承优化1</h5><ul>
<li>核⼼：<ul>
<li>通过这种⽅式，砍掉⽗类的实例属性，这样在调⽤⽗类的构造函数的时候，就不会初始化两次实 例，避免组合继承的缺点。</li>
</ul>
</li>
<li>优点：</li>
<li>只调⽤⼀次⽗类构造函数。</li>
<li>保留构造函数的优点：创建⼦类实例，可以向⽗类构造函数传参数。</li>
<li>保留原型链的优点：⽗类的实例⽅法定义在⽗类的原型对象上，可以实现⽅法复⽤。</li>
<li>缺点：</li>
<li>修正构造函数的指向之后，⽗类实例的构造函数指向，同时也发⽣变化(这是我们不希望的)</li>
<li>注意：’组合继承优化1’这种⽅式，要记得修复Child.prototype.constructor指向 原因是：不能判断⼦类实例的直接构造函数，到底是⼦类构造函数还是⽗类构造函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">// 实例基本属性 (该属性，强调私有，不共享)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span> = [<span class="number">1</span>]; <span class="comment">// (该属性，强调私有)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// --- 将需要复⽤、共享的⽅法定义在⽗类原型上</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name,like</span>) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,name,like) <span class="comment">// 核⼼</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">like</span> = like;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// 核⼼ ⼦类原型和⽗类原型，实质上是同⼀个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这⾥是修复构造函数指向的代码</span></span><br><span class="line">    </span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//详解js继承 6</span></span><br><span class="line"><span class="keyword">let</span> boy1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;⼩红&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> boy2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;⼩明&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Parent</span>(<span class="string">&#x27;⼩爸爸&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点1：可以向⽗类构造函数传参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy1.<span class="property">name</span>,boy1.<span class="property">like</span>); <span class="comment">// ⼩红，apple</span></span><br><span class="line"><span class="comment">// 优点2：可复⽤⽗类原型上的⽅法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boy1.<span class="property">say</span> === boy2.<span class="property">say</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺点1：当修复⼦类构造函数的指向后，⽗类实例的构造函数指向也会跟着变了。</span></span><br><span class="line">没修复之前：<span class="variable language_">console</span>.<span class="title function_">log</span>(boy1.<span class="property">constructor</span>); <span class="comment">// Parent</span></span><br><span class="line">修复代码：<span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span></span><br><span class="line">修复之后：<span class="variable language_">console</span>.<span class="title function_">log</span>(boy1.<span class="property">constructor</span>); <span class="comment">// Child</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">constructor</span>);<span class="comment">// Child 这⾥就是存在的问题(我们希望是Parent)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*具体原因：因为是通过原型来实现继承的，Child.prototype的上⾯是没有constructor属性的，</span></span><br><span class="line"><span class="comment">就会往上找，这样就找到了Parent.prototype上⾯的constructor属性；当你修改了⼦类实例的</span></span><br><span class="line"><span class="comment">construtor属性，所有的constructor的指向都会发⽣变化。*/</span></span><br></pre></td></tr></table></figure>

<h5 id="5、组合继承优化2-⼜称-寄⽣组合继承-—-完美⽅式"><a href="#5、组合继承优化2-⼜称-寄⽣组合继承-—-完美⽅式" class="headerlink" title="5、组合继承优化2 ⼜称 寄⽣组合继承 — 完美⽅式"></a>5、组合继承优化2 ⼜称 寄⽣组合继承 — 完美⽅式</h5><p>核⼼：</p>
<p>优点：完美</p>
<p>缺点：—</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">// 实例基本属性 (该属性，强调私有，不共享)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span> = [<span class="number">1</span>]; <span class="comment">// (该属性，强调私有)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// --- 将需要复⽤、共享的⽅法定义在⽗类原型上</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name,like</span>) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>,name,like) <span class="comment">// 核⼼</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">like</span> = like;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核⼼ 通过创建中间对象，⼦类原型和⽗类原型，就会隔离开。不是同⼀个啦，有效避免了⽅式4的缺点。</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这⾥是修复构造函数指向的代码</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span></span><br><span class="line"><span class="keyword">let</span> boy1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;⼩红&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> boy2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;⼩明&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Parent</span>(<span class="string">&#x27;⼩爸爸&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：这种⽅法也要修复构造函数的</span></span><br><span class="line"><span class="comment">//修复代码：Child.prototype.constructor = Child</span></span><br><span class="line"><span class="comment">//详解js继承 7</span></span><br><span class="line"><span class="comment">//修复之后：console.log(boy1.constructor); // Child</span></span><br><span class="line"><span class="comment">//console.log(p1.constructor); // Parent 完美😊</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="第三部分：其他相关问题"><a href="#第三部分：其他相关问题" class="headerlink" title="第三部分：其他相关问题"></a>第三部分：其他相关问题</h4><h5 id="1、Object-create-object-propertiesObject"><a href="#1、Object-create-object-propertiesObject" class="headerlink" title="1、Object.create(object, propertiesObject)"></a>1、Object.create(object, propertiesObject)</h5><p>Object.create()⽅法创建⼀个新对象，使⽤第⼀个参数来提供新创建对象的__proto__（以第⼀个参 数作为新对象的构造函数的原型对象）； ⽅法还有第⼆个可选参数，是添加到新创建对象的属性，写法如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">    <span class="attr">age</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">12</span>,</span><br><span class="line">        <span class="attr">writable</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="new-与-Object-create-的区别？"><a href="#new-与-Object-create-的区别？" class="headerlink" title="new 与 Object.create() 的区别？"></a>new 与 Object.create() 的区别？</h5><p>new 产⽣的实例，优先获取构造函数上的属性；构造函数上没有对应的属性，才会去原型上查找； 如果构造函数中以及原型中都没有对应的属性，就会报错。Object.create() 产⽣的对象，只会在原 型上进⾏查找属性，原型上没有对应的属性，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Base1</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o1 = <span class="keyword">new</span> <span class="title class_">Base1</span>()</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Base1</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o1.<span class="property">a</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o2.<span class="property">a</span>); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Base2</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Base2</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="string">&#x27;aa&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o3 = <span class="keyword">new</span> <span class="title class_">Base2</span>()</span><br><span class="line"><span class="keyword">let</span> o4 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Base2</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o3.<span class="property">a</span>); <span class="comment">// aa</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o4.<span class="property">a</span>); <span class="comment">// aa</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Base3</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Base3</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="string">&#x27;aa&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o5 = <span class="keyword">new</span> <span class="title class_">Base3</span>()</span><br><span class="line"><span class="keyword">let</span> o6 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Base3</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//详解js继承 8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o5.<span class="property">a</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o6.<span class="property">a</span>); <span class="comment">// aa</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2、new-的过程"><a href="#2、new-的过程" class="headerlink" title="2、new 的过程"></a>2、new 的过程</h5><ul>
<li>创建新对象（如obj）。</li>
<li>将新对象的_proto_指向构造函数的prototype对象。</li>
<li>执⾏构造函数，为这个新对象添加属性，并将this指向创建的新对象obj。</li>
<li>当构造函数本⾝返回值为对象时，返回该对象，否则返回新对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Person构造函数，参数为name,age</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//1.拿到传⼊的参数中的第⼀个参数，即构造函数名Func</span></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">Func</span> = [].<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="comment">//2.创建⼀个空对象obj,并让其继承Func.prototype</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Func</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">    <span class="comment">//3.执⾏构造函数，并将this指向创建的空对象obj</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Func</span>.<span class="title function_">apply</span>(obj,<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="comment">//4.当函数也有返回值且为对象时返回该对象，否则返回创建的新对象obj</span></span><br><span class="line">    <span class="keyword">return</span> (result instanceOf <span class="title class_">Object</span> ? result : obj)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ming = <span class="title function_">_new</span>(<span class="title class_">Person</span>,<span class="string">&#x27;xiaoming&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ming);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>[].shift.call表⽰删除并返回auguments[0]。也可以通过以下⽅式取得函数名和函数的参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params">Func, ...params</span>)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、为什么‘组合继承’这种⽅式，会执⾏两次⽗类构造函数？？"><a href="#3、为什么‘组合继承’这种⽅式，会执⾏两次⽗类构造函数？？" class="headerlink" title="3、为什么‘组合继承’这种⽅式，会执⾏两次⽗类构造函数？？"></a>3、为什么‘组合继承’这种⽅式，会执⾏两次⽗类构造函数？？</h5><ul>
<li>第⼀次：Child.prototype &#x3D; new Parent()<ul>
<li>‘new 的过程’的第三步，其实就是执⾏了⽗类构造函数。</li>
</ul>
</li>
<li>第⼆次：Parent.call(this,name,like)</li>
<li>call的作⽤是改变函数执⾏时的上下⽂。⽐如：A.call(B)。其实，最终执⾏的还是A函数，只不过是 ⽤B来调⽤⽽已。所以，你就懂了Parent.call(this,name,like) ,也就是执⾏了⽗类构造函数Person</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>基础面试总结</title>
    <url>/2020/05/17/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="1-说说你对盒子模型的理解"><a href="#1-说说你对盒子模型的理解" class="headerlink" title="1. 说说你对盒子模型的理解"></a>1. 说说你对盒子模型的理解</h4><p>标准盒子模型：</p>
<ul>
<li>content（内容）</li>
<li>margin（外边距） ：盒子与盒子之间的距离。</li>
<li>padding（内边距）：内容与边框的距离。</li>
<li>border（边框）</li>
</ul>
<p>IE盒子模型（怪异盒模型）</p>
<ul>
<li>content</li>
<li>margin</li>
</ul>
<p>开发中往往使用IE盒模型，只需要设置box-sizing：border-box</p>
<p>盒⼦模型的实际宽度:width+左右padding+左右border</p>
<p>盒⼦模型的实际高度:height+左右padding+左右border</p>
<h4 id="2-css选择器有哪些？优先级？哪些属性可以继承？"><a href="#2-css选择器有哪些？优先级？哪些属性可以继承？" class="headerlink" title="2. css选择器有哪些？优先级？哪些属性可以继承？"></a>2. css选择器有哪些？优先级？哪些属性可以继承？</h4><ul>
<li>id选择器（#box），选择id为box的元素</li>
<li>类选择器（.one），选择类名为one的所有元素</li>
<li>标签选择器（div），选择标签为div的所有元素</li>
<li>后代选择器（#box div），选择id为box元素内部所有的div元素</li>
<li>通配符选择器(*)</li>
<li>伪类选择器(a:hover, li:nth-child)</li>
<li>伪元素选择器（::after, ::before)</li>
</ul>
<p><strong>优先级</strong></p>
<span id="more"></span>
<p>内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器 &gt;子代选择器&gt;后代选择器&gt;通配符选择器&gt;伪类选择器</p>
<p>可继承的属性：font-size, font-family, color， line-height：行高</p>
<p>不可继承的属性：border, padding, margin, width, height</p>
<h4 id="3-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"><a href="#3-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？" class="headerlink" title="3. 元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"></a>3. 元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</h4><ul>
<li>使用绝对定位：position:absolute; left:0, top:0, bottom:0, right:0, margin:auto。</li>
<li>使用flex布局：display：flex，aligin-item：center，justify-content：center。</li>
<li>使用表格中属性：display：table-cell，text-align：center</li>
<li>使用text-align：center水平居中，使用line-height：父元素的高度</li>
</ul>
<h4 id="4-怎么理解回流跟重绘？什么场景下会触发？"><a href="#4-怎么理解回流跟重绘？什么场景下会触发？" class="headerlink" title="4. 怎么理解回流跟重绘？什么场景下会触发？"></a>4. 怎么理解回流跟重绘？什么场景下会触发？</h4><p>回流一定会触发重绘，重绘不能触发回流。</p>
<p>回流的代价高，只要元素结构发生变化就有可能全部重新渲染。</p>
<p>回流：当渲染树中的一些元素结构，窗口大小，位置发生变化，浏览器就会重新渲染文档这个过程叫做回流。（连锁反应）</p>
<p>重绘：当页面样式发生改变而不影响它在文档流中的位置，布局不会发生改变这个过程叫做重绘。</p>
<p>导致回流的操作：</p>
<ul>
<li>页面重新渲染</li>
<li>页面内容改变</li>
<li>添加和删除节点</li>
<li>浏览器窗口大小发生改变</li>
</ul>
<p>导致重绘的操作：</p>
<ul>
<li>背景颜色 透明度 阴影 发生改变。</li>
</ul>
<p>如何避免减少回流？</p>
<ul>
<li>css<ul>
<li>避免设置多层内联样式。</li>
<li>避免使用table布局</li>
<li>避免使用CSS表达式</li>
</ul>
</li>
<li>JavaScript<ul>
<li>避免频繁操作样式。</li>
<li>避免频繁操作DOM。创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。</li>
<li>可以先为元素设置为不可见：display: none，操作结束后再把它显示出来。</li>
</ul>
</li>
</ul>
<h4 id="5-什么是响应式设计？响应式设计的基本原理是什么？如何做？"><a href="#5-什么是响应式设计？响应式设计的基本原理是什么？如何做？" class="headerlink" title="5. 什么是响应式设计？响应式设计的基本原理是什么？如何做？"></a>5. 什么是响应式设计？响应式设计的基本原理是什么？如何做？</h4><p>响应式设计就是：页面布局可以响应不同尺寸的屏幕，同一个页面，随着屏幕尺寸的改变，自适应的改变页面布局。</p>
<p>原理：利用CSS3媒体查询，为不同尺寸的设备适配不同样式。</p>
<p>实现响应式布局的方式有如下 ：</p>
<ul>
<li>媒体查询： 通过给不同分辨率的设备编写不同的样式。</li>
<li>百分比： 当浏览器高度，宽度发生变化时，样式也会随着变化。</li>
<li>vw&#x2F;vh： vw表示视图窗口的宽度，vh表示视图窗口高度。</li>
<li>rem ： 根据根元素html的font-size属性。</li>
</ul>
<h4 id="6-如果要做优化，CSS提高性能的方法有哪些？"><a href="#6-如果要做优化，CSS提高性能的方法有哪些？" class="headerlink" title="6. 如果要做优化，CSS提高性能的方法有哪些？"></a>6. 如果要做优化，CSS提高性能的方法有哪些？</h4><p>加载性能：</p>
<ul>
<li>css压缩：使用webpack将写好的css进行打包压缩，可以减少很多的体积 。</li>
<li>减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</li>
</ul>
<p>选择器性能：</p>
<ul>
<li>避免使用通配规则。 *{}计算次数惊人！只对需要用到的元素进行选择 。</li>
<li>尽量少的去对标签进行选择，而是用class。</li>
</ul>
<p>渲染性能：</p>
<ul>
<li>尽量减少页面重排、重绘 。</li>
<li>属性值为0时，不加单位。</li>
</ul>
<h4 id="7-对前端工程师这个职位是怎么样理解的？它的前景会怎么样"><a href="#7-对前端工程师这个职位是怎么样理解的？它的前景会怎么样" class="headerlink" title="7. 对前端工程师这个职位是怎么样理解的？它的前景会怎么样"></a>7. 对前端工程师这个职位是怎么样理解的？它的前景会怎么样</h4><p>理解：</p>
<p>前端工程师是跟用户最贴合的一个职位。一个产品的好坏并不是企业说了算，是用户喜欢的才是好的产品。而用户所能评价的就是他可以看到的，可以触摸到的。前端工程师要做的就是呈现给用户这些信息。</p>
<p>前景：</p>
<p>web前端人才需求量是比较大的。</p>
<p>同时他的就业方向多：包括网站，h5页面，小程序，APP等等，就需要前端开发工程师岗位。具体就业方向还可以按公司所需技术来区分，前端已经变得越来越广泛。</p>
<h4 id="8-说说JavaScript中的数据类型？存储上的差别？"><a href="#8-说说JavaScript中的数据类型？存储上的差别？" class="headerlink" title="8. 说说JavaScript中的数据类型？存储上的差别？"></a>8. 说说JavaScript中的数据类型？存储上的差别？</h4><p>基本数据类型：string，number，boolean，undefind，null，symbol，bigint</p>
<p>复杂数据类型：object，function，array，data，math</p>
<p>存储差别：</p>
<ul>
<li>基本数据类型存储在栈当中，固定大小，占空间小，适于频繁调用。</li>
<li>复杂数据类型存放在堆中，大小不固定，占空间大。并且在栈中存储了指向堆实体的指针，使用时会检索栈中的地址，再去堆中拿到实体。</li>
</ul>
<h4 id="9-typeof-与-instanceof-区别"><a href="#9-typeof-与-instanceof-区别" class="headerlink" title="9. typeof 与 instanceof 区别"></a>9. typeof 与 instanceof 区别</h4><p><strong>typeof</strong>：可以正确判断基本数据类型，除了null外（object）。他不能正确判断复杂数据类型，除function外都是object。</p>
<p><strong>instanceof</strong>：可以正确判断复杂数据类型，其内部机制是根据判断对象的原型链上是否含有该类型，是返回true，不是返回false。不能直接判断基本数据类型。</p>
<p>可使用原型判断的方式：</p>
<p><strong>object.prototype.toString().call()</strong> ：判断object类型的，直接调用<code>toString()</code>就可以返回正确类型，其他对象必须使用<code>.call（）</code>方法，才能返回正确的类型信息 。</p>
<h4 id="10-说说你对闭包的理解？闭包使用场景"><a href="#10-说说你对闭包的理解？闭包使用场景" class="headerlink" title="10. 说说你对闭包的理解？闭包使用场景"></a>10. 说说你对闭包的理解？闭包使用场景</h4><p>闭包就是一个有权访问其他函数里的变量及参数。最常见创建闭包的形式就是一个函数内嵌套一个函数。内部函数可以访问外部函数的变量和参数。突破了作用域。</p>
<p>两个用处：封装私有属性及私有方法。 可以读取函数内部的变量，并且不会被回收。</p>
<p>闭包的使用场景：</p>
<ol>
<li>返回一个函数</li>
<li>函数赋值，将内部函数赋值给外部变量</li>
<li>返回一个函数，作为函数参数传递</li>
</ol>
<h4 id="11-bind、call、apply-区别？如何实现一个bind"><a href="#11-bind、call、apply-区别？如何实现一个bind" class="headerlink" title="11. bind、call、apply 区别？如何实现一个bind?"></a>11. bind、call、apply 区别？如何实现一个bind?</h4><p>三者都可以改变函数的<code>this</code>对象指向</p>
<p>三者第一个参数都是<code>this</code>要指向的对象，如果没有这个参数或参数为<code>undefined</code>或<code>null</code>，则默认指向全局<code>window</code>。</p>
<p>call()传递参数是以参数列表的形式，apply是以数组的形式。这两者都是调用之后立即执行。</p>
<p>bind()返回一个绑定this之后的函数。bind第一个参数就作为运行时的this。</p>
<p>实现<code>bind</code>的步骤，我们可以分解成为三部分：</p>
<ul>
<li>修改<code>this</code>指向</li>
<li>动态传递参数</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：只在bind中传递函数参数</span></span><br><span class="line">fn<span class="selector-class">.bind</span>(obj,<span class="number">1</span>,<span class="number">2</span>)()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 方式二：在bind中传递函数参数，也在返回函数中传递参数</span></span><br><span class="line">fn<span class="selector-class">.bind</span>(obj,<span class="number">1</span>)(<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>兼容<code>new</code>关键字</li>
</ul>
<h4 id="12-说说你对事件循环的理解"><a href="#12-说说你对事件循环的理解" class="headerlink" title="12. 说说你对事件循环的理解"></a>12. 说说你对事件循环的理解</h4><p>event loop过程1：</p>
<ul>
<li>同步代码，一行一行在call stack（执行栈）执行</li>
<li>遇到异步，会先“记录”下，等待时机（定时，网络请求等）</li>
<li>时机到了，就移动到 Callback Queue （回调队列）</li>
</ul>
<p>event loop过程2：</p>
<ul>
<li>如Call Stack为空（及代码执行完）Event loop 开始工作</li>
<li>轮询查找Callback Queue，如有则移动到 Call Stack执行</li>
<li>然后继续轮询查找（永动机一样）</li>
</ul>
<p>宏任务：</p>
<ul>
<li>js代码</li>
<li>setTimeout</li>
<li>Ajax</li>
<li>Dom事件</li>
</ul>
<p>微任务：</p>
<ul>
<li>Promise async&#x2F;</li>
<li>nextTick（Node.js）</li>
<li>MutaionObserver</li>
</ul>
<h4 id="13-DOM常见的操作有哪些"><a href="#13-DOM常见的操作有哪些" class="headerlink" title="13. DOM常见的操作有哪些"></a>13. DOM常见的操作有哪些</h4><ul>
<li><p>创建dom节点</p>
<ul>
<li>document.createElement(‘元素名’); 创建新的元素节点</li>
<li>document.createAttribute(‘属性名’); 创建新的属性节点</li>
<li>document.createTextNode(‘⽂本内容’); 创建新的⽂本节点</li>
<li>document.createComment(‘注释节点’); 创建新的注释节点</li>
<li>document.createDocumentFragment(); 创建文档片段节点</li>
</ul>
</li>
<li><p>访问&#x2F;获取节点</p>
<ul>
<li>getElementById(‘id属性值’); 返回拥有指定id的第⼀个对象的引⽤</li>
<li>getElementsByClassName(‘class属性值’);返回拥有指定class的对象集合</li>
<li>getElementsByTagName(‘标签名’); 返回拥有指定标签名的对象集合</li>
<li>getElementsByName(‘name属性值’); 返回拥有指定名称的对象结合</li>
<li>querySelector(‘CSS选择器’); 仅返回第⼀个匹配的元素</li>
<li>querySelectorAll(‘CSS选择器’); 返回所有匹配的元素</li>
<li>document.documentElement; 获取页⾯中的HTML标签</li>
<li>document.body ； 获取页面body标签</li>
</ul>
</li>
<li><p>添加节点</p>
<ul>
<li>appendChild 添加节点</li>
</ul>
</li>
<li><p>删除节点</p>
<ul>
<li>parentNode.removeChild( existingChild ); 删除已有的⼦节点，返回值为删除节点</li>
<li>element.removeAttribute(‘属性名’); 删除具有指定属性名称的属性，⽆返回值</li>
<li>element.removeAttributeNode( attrNode ); 删除指定属性，返回值为删除的属性</li>
</ul>
<p>修改节点内容</p>
<ul>
<li>style 设置css样式</li>
<li>innerHTML 修改节点内容</li>
<li>innerText 修改内容，也可添加一个节点</li>
</ul>
</li>
</ul>
<h4 id="14-说说你对BOM的理解，常见的BOM对象你了解哪些？"><a href="#14-说说你对BOM的理解，常见的BOM对象你了解哪些？" class="headerlink" title="14. 说说你对BOM的理解，常见的BOM对象你了解哪些？"></a>14. 说说你对BOM的理解，常见的BOM对象你了解哪些？</h4><p><code>BOM</code> (Browser Object <a href="https://so.csdn.net/so/search?q=Model&spm=1001.2101.3001.7020">Model</a>)，浏览器对象模型，提供了内容与浏览器窗口进行交互的对象。</p>
<p>Bom作用：跟浏览器做一些交互效果。比如：页面的前进，后退，刷新，滚动条的滚动，鼠标的坐标 。</p>
<p>五个对象：</p>
<ul>
<li>window<ul>
<li><code>Bom</code>的核心对象是<code>window</code> ， 在全局作用域中声明的变量、函数都会变成<code>window</code>对象的属性和方法</li>
</ul>
</li>
<li>location<ul>
<li><code>location.reload()</code>，此方法可以重新刷新当前页面 。修改location，会重载页面。</li>
</ul>
</li>
<li>navigator<ul>
<li>主要用来获取浏览器的属性，区分浏览器类型。</li>
</ul>
</li>
<li>history<ul>
<li>主要用来操作浏览器<code>URL</code>的历史记录，可以通过参数向前，向后，或者向指定<code>URL</code>跳转</li>
<li><code>history.go()</code></li>
<li><code>history.forward()</code>：向前跳转一个页面</li>
<li><code>history.back()</code>：向后跳转一个页面</li>
<li><code>history.length</code>：获取历史记录数</li>
</ul>
</li>
<li>screen<ul>
<li>保存的是客户端的信息。比如像素的宽和高。</li>
</ul>
</li>
</ul>
<h4 id="15-Javascript本地存储的方式有哪些？区别及应用场景？"><a href="#15-Javascript本地存储的方式有哪些？区别及应用场景？" class="headerlink" title="15. Javascript本地存储的方式有哪些？区别及应用场景？"></a>15. Javascript本地存储的方式有哪些？区别及应用场景？</h4><ul>
<li>cookie</li>
<li>sessionStorage</li>
<li>locaStorage</li>
</ul>
<p>区别：</p>
<ul>
<li>cookie存储大小不能超过4k，http始终携带cookie，即使不使用。是为了解决 <code>HTTP</code> 无状态导致的问题。适合保存很小的数据。sessionStorage和localStorage比cookis大得多，可以达到5m或者更多。</li>
<li>cookie具有时效，时间过后清除数据。 sessionStorage是在关闭当前对话也就是当前页面清除缓存。locaStorage只有手动清除，否侧一直存在。适合做持久化。</li>
<li>sessionStorage只在当前浏览器窗口共享，locaStorage，cookie在所有同源浏览器窗口共享。</li>
</ul>
<h4 id="16-什么是防抖和节流？有什么区别？如何实现？"><a href="#16-什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="16. 什么是防抖和节流？有什么区别？如何实现？"></a>16. 什么是防抖和节流？有什么区别？如何实现？</h4><ul>
<li>防抖：在一定的时间后调用函数，如果在这段时间内重新调用该函数，则重新计算执行时间。只执行最后一次。</li>
<li>节流：持续触发一个事件，每隔一段时间，只执行一次事件。控制执行的次数以及事件触发的频率。从而提高性能。</li>
</ul>
<p>相同点：</p>
<ul>
<li>都可以通过使用 setTimeout 实现目的都是，降低回调执行频率。节省计算资源</li>
</ul>
<p>不同点：</p>
<ul>
<li>函数防抖，利用clearTimeout和 setTimeout实现。</li>
<li>防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次。</li>
</ul>
<p>应用场景：</p>
<p> 1.scroll事件滚动触发</p>
<p> 2.搜索框输入查询</p>
<p> 3.表单验证</p>
<p> 4.按钮提交事件</p>
<p> 5.浏览器窗口缩放，resize事件</p>
<h4 id="17-如何通过JS判断一个数组"><a href="#17-如何通过JS判断一个数组" class="headerlink" title="17. 如何通过JS判断一个数组"></a>17. 如何通过JS判断一个数组</h4><ul>
<li>isArray()数组自带的判断方法</li>
<li>instanceof 判断类型</li>
<li>constructor.toString()方法</li>
<li>Object.prototype.toString.call(a) 原型方法</li>
</ul>
<h4 id="18-说说你对作用域链的理解"><a href="#18-说说你对作用域链的理解" class="headerlink" title="18. 说说你对作用域链的理解"></a>18. 说说你对作用域链的理解</h4><p>作用域的作用就是保证有权被访问的变量及函数的有序性，作用域链的变量只能向上访问，不能向下访问。当访问到window对象时终止。作用链就是变量和函数的可访问范围，控制变量和函数的可见性及生命周期。</p>
<h4 id="19-JavaScript原型，原型链-有什么特点？"><a href="#19-JavaScript原型，原型链-有什么特点？" class="headerlink" title="19. JavaScript原型，原型链 ? 有什么特点？"></a>19. JavaScript原型，原型链 ? 有什么特点？</h4><ul>
<li>原型： 每个对象都会在其内部初始化一个属性，就是<code>__proto__</code> （原型）。还预置了prototype属性。构造函数创建实例时，该prototype属性值就会被作为实例对象的原型proto。</li>
<li>原型链：当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去， 直到找到属性&#x2F;方法或 <code>undefined</code> 为止 ，也就是原型链的概念 。</li>
<li>特点： javascript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变 。</li>
</ul>
<h4 id="20-请解释什么是事件代理"><a href="#20-请解释什么是事件代理" class="headerlink" title="20. 请解释什么是事件代理"></a>20. 请解释什么是事件代理</h4><p>事件代理也就是事件委托，将原本需要绑定的事件委托给父元素。让父元素去监听。其原理就是：dom元素的事件冒泡。好处：节省大量内存，减少事件注册，提高性能。当新增子对象时无需再次绑定。</p>
<h4 id="21-谈谈This对象的理解"><a href="#21-谈谈This对象的理解" class="headerlink" title="21. 谈谈This对象的理解"></a>21. 谈谈This对象的理解</h4><ul>
<li>this总是指向函数的直接调用者</li>
<li>如果有new关键字，this指向new出来的这个实例对象</li>
<li>在事件中，this指向触发这个事件的对象。</li>
<li>IE中，this总是指向全局对象window。</li>
<li>箭头函数没有this，箭头函数的this指向上一级的函数。</li>
<li>可通过apply，call，bind来改变this指向。</li>
</ul>
<h4 id="22-new操作符具体干了什么"><a href="#22-new操作符具体干了什么" class="headerlink" title="22. new操作符具体干了什么"></a>22. new操作符具体干了什么</h4><ul>
<li>创建一个空对象，并且this引用该对象，也继承了该对象的原型。</li>
<li>将所有的属性，方法都添加到了this引用的这个对象。</li>
<li>新创建的对象由this引用，最后隐式的返回this。</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mynew</span><span class="params">(Func, <span class="rest_arg">...args</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建一个新对象</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">    <span class="comment">// 2.新对象原型指向构造函数原型对象</span></span><br><span class="line">    obj.__proto__ = Func.prototype</span><br><span class="line">    <span class="comment">// 3.将构建函数的this指向新对象</span></span><br><span class="line">    let result = Func.apply(obj, args)</span><br><span class="line">    <span class="comment">// 4.根据返回值判断</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> Object ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="23-null，undefined-的区别"><a href="#23-null，undefined-的区别" class="headerlink" title="23. null，undefined 的区别"></a>23. null，undefined 的区别</h4><ul>
<li>undefinded：表示没有不存在的值，一个缺少值。此处应有值，但没定义。读取时，返回undefined。</li>
<li>null：表示一个空对象，没有任何属性及方法。对比验证时使用&#x3D;&#x3D;&#x3D;。</li>
</ul>
<h4 id="24-javascript-代码中的”use-strict”-是什么意思"><a href="#24-javascript-代码中的”use-strict”-是什么意思" class="headerlink" title="24. javascript 代码中的”use strict”;是什么意思"></a>24. javascript 代码中的”use strict”;是什么意思</h4><p>use strict是 es5添加的一种严格运行模式，这种模式使JavaScript能够在更严格的条件下运行。使js编码更加规范，消除了一些不严谨，不合理之处。</p>
<h4 id="25-同步和异步的区别"><a href="#25-同步和异步的区别" class="headerlink" title="25. 同步和异步的区别"></a>25. 同步和异步的区别</h4><p>同步是阻塞模式，异步是非阻塞模式。</p>
<ul>
<li>同步<ul>
<li>同步是指一个进程在执行某个请求时，该请求需要一定时间返回消息。那么这个进程就会一直等待下去，直到返回消息后，才执行下面的操作。</li>
</ul>
</li>
<li>异步<ul>
<li>异步是指不需要一直等待下去，而是继续执行下面的操作。不管其他进程的状态，当返回消息时，系统会通知该进程进行处理。提高了执行效率。</li>
</ul>
</li>
</ul>
<h4 id="26-谈一谈箭头函数与普通函数的区别"><a href="#26-谈一谈箭头函数与普通函数的区别" class="headerlink" title="26. 谈一谈箭头函数与普通函数的区别"></a>26. 谈一谈箭头函数与普通函数的区别</h4><ul>
<li>语法形式不同，箭头函数更简短</li>
<li>没有单独的<code>this</code></li>
<li>不绑定<code>arguments</code></li>
<li>不能使用<code>new</code>操作</li>
<li>没有<code>prototype</code>属性</li>
<li>通过<code>call</code>或<code>apply</code>调用会忽略第一个参数，只能传递参数，不能绑定<code>this</code></li>
<li>不能使用<code>yield</code>关键字</li>
</ul>
<h4 id="27-JS-数组和对象的遍历方式，以及几种方式的比较"><a href="#27-JS-数组和对象的遍历方式，以及几种方式的比较" class="headerlink" title="27. JS 数组和对象的遍历方式，以及几种方式的比较"></a>27. JS 数组和对象的遍历方式，以及几种方式的比较</h4><ul>
<li>for in 循环</li>
<li>for of循环</li>
<li>forEach循环</li>
<li>map循环</li>
</ul>
<p>区别：</p>
<ul>
<li>for in循环 和 for循环 性能低。</li>
<li>for in适合遍历对象，for of适合遍历数组。for in遍历的是数组的索引，对象的key值，以及原型链上的属性 。</li>
<li>forEach ⽆法遍历对象 forEach ⽆法使⽤ break ， continue 跳出循环，且使⽤ return 是跳过本次循环 。</li>
<li>map可以return出一个新数组，原数组不会改变 。⽆法遍历对象 。</li>
</ul>
<h4 id="28-如何解决跨域问题"><a href="#28-如何解决跨域问题" class="headerlink" title="28. 如何解决跨域问题"></a>28. 如何解决跨域问题</h4><p>产生跨域的是因为浏览器的同源策略，同源策略是一种约定，它是浏览器最核心也最基本的安全功能。所谓同源是指 协议 域名 端口 三者一致。若其中一项不一致就会产生跨域。</p>
<ul>
<li>jsonp跨域<ul>
<li>只可以使用get方式提交。设置请求url –》 参数拼接 –》创建script节点 –》 返回数据，清除script。</li>
</ul>
</li>
<li>nginx代理跨域</li>
<li>node中间件跨域</li>
<li>cors后端头部设置安全域名<ul>
<li>需要浏览器和服务器的支持，自动完成跨域。添加一些头部信息。</li>
</ul>
</li>
</ul>
<h4 id="29-XML和JSON的区别"><a href="#29-XML和JSON的区别" class="headerlink" title="29. XML和JSON的区别"></a>29. XML和JSON的区别</h4><p>json是一个轻量的数据交换格式。是javascript的一个子集。</p>
<p>xml是纯文本的格式的，可扩展标记语言。</p>
<ul>
<li>JSON 比 XML 体积小，传递速度快。</li>
<li>JSON对jacascript交互更方便，更容易解析。</li>
<li>JSON 比 XML 传输速度快很多。</li>
<li>JSON对数据的描述性差。</li>
</ul>
<h4 id="30-谈谈你对webpack的看法"><a href="#30-谈谈你对webpack的看法" class="headerlink" title="30. 谈谈你对webpack的看法"></a>30. 谈谈你对webpack的看法</h4><p>webpack是一个模块打包工具，可以使用webpack管理模块依赖，并编译除模块所需的静态文件。打包web开发中所用到的html，css，js等静态文件。提高开发效率。对于不同的类型的资源，webpack由相对应的模块加载器。webpack会分析模块间的相关依赖，最后生成优化后的静态资源。</p>
<h4 id="31-webpack的打包原理"><a href="#31-webpack的打包原理" class="headerlink" title="31. webpack的打包原理"></a>31. webpack的打包原理</h4><p><a href="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71b263000fa94db792cf1e98d67a578a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71b263000fa94db792cf1e98d67a578a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></a></p>
<ul>
<li>初始化参数：从配置文件和 Shell 语句中读取并合并参数，得出最终的配置参数。</li>
<li>开始编译：从上一步得到的参数初始化 <code>Compiler</code> 对象，加载所有配置的插件，执行对象的 <code>run</code> 方法开始执行编译。</li>
<li>确定入口：根scope据配置中的 <code>entry</code> 找出所有的入口文件。</li>
<li>编译模块：从入口文件出发，调用所有配置的 <code>loader</code> 对模块进行翻译，再找出该模块依赖的模块，这个步骤是递归执行的，直至所有入口依赖的模块文件都经过本步骤的处理。</li>
<li>完成模块编译：经过第 4 步使用 loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。</li>
<li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>chunk</code>，再把每个 <code>chunk</code> 转换成一个单独的文件加入到输出列表，这一步是可以修改输出内容的最后机会。</li>
<li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li>
</ul>
<p>webpack打包原理是将根据文件间的依赖关系对其进行静态分析，然后将这些模块按指定规则生成静态资源，当 webpack处理程序时，会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所所有这些模块打包成bundle。</p>
<p>从配置文件中读取所需要的参数，并且加载所有的插件，开始执行编译。找到entry入口文件。调用loader对模板进行递归解析翻译。等确定每个模块的依赖关系后，将他们组装成一个个包含多个模块的chunk。确定好内容后，根据出口配置将打包后的文件写入到具体位置。</p>
<h4 id="32-如何优化webpack打包速度"><a href="#32-如何优化webpack打包速度" class="headerlink" title="32. 如何优化webpack打包速度"></a>32. 如何优化webpack打包速度</h4><ul>
<li>优化 loader 配置： 减少文件的搜索范围，使用test，include，exclude。</li>
<li>使用image-webpack-loader进行图片压缩</li>
<li>terser启用多线程 ： 使用多进程并行运行来提高构建速度</li>
<li>使用 cache-loader： 将开销较大的loader结果缓存到磁盘</li>
<li>优化 resolve.modules: 指明存放第三方模块的绝对路径，以减少寻找 。</li>
<li>优化 resolve.alias</li>
<li>使用 DLLPlugin 插件</li>
<li>合理使用 sourceMap</li>
</ul>
<h4 id="33-说说webpack中常见的Loader？解决了什么问题？"><a href="#33-说说webpack中常见的Loader？解决了什么问题？" class="headerlink" title="33. 说说webpack中常见的Loader？解决了什么问题？"></a>33. 说说webpack中常见的Loader？解决了什么问题？</h4><p>webpack默认情况下，只支持对js，json文件打包。像css，less，png等这些类型文件，webpack需要采用相对应的loader（模块加载器）进行解析。</p>
<p>关于<code>loader</code>的配置，我们是写在<code>module.rules</code>属性中，属性介绍如下：</p>
<ul>
<li><code>rules</code>是一个数组的形式，因此我们可以配置很多个<code>loader</code></li>
<li>每一个<code>loader</code>对应一个对象的形式，对象属性<code>test</code> 为匹配的规则，一般情况为正则表达式</li>
<li>属性<code>use</code>针对匹配到文件类型，调用对应的 <code>loader</code> 进行处理</li>
</ul>
<p>常见的<code>loader</code>如下：</p>
<ul>
<li>style-loader: 将css添加到DOM的内联样式标签style里</li>
<li>css-loader :允许将css文件通过require的方式引入，并返回css代码</li>
<li>less-loader: 处理less</li>
<li>sass-loader: 处理sass</li>
<li>babel-loader :用babel来转换ES6文件到ES5</li>
<li>file-loader: 分发文件到output目录并返回相对路径</li>
<li>url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url</li>
</ul>
<p>css-loader: 分析 <code>css</code> 模块之间的关系，并合成⼀个 <code>css</code></p>
<p>staly-loader: 把 <code>css-loader</code> 生成的内容，用 <code>style</code> 标签挂载到页面的 <code>head</code> 中</p>
<p>less-loader: 开发中，我们也常常会使用<code>less</code>、<code>sass</code>、<code>stylus</code>预处理器编写<code>css</code>样式，使开发效率提高，这里需要使用<code>less-loader</code></p>
<p>url-loader: 可以处理 <code>file-loader</code> 所有的事情，遇到图片格式的模块，可以选择性的把图片转成 <code>base64</code> 格式的字符串，并打包到 <code>js</code> 中，对小体积的图片比较合适，大图片不合适。</p>
<h4 id="34-说说webpack中常见的Plugin？解决了什么问题？"><a href="#34-说说webpack中常见的Plugin？解决了什么问题？" class="headerlink" title="34. 说说webpack中常见的Plugin？解决了什么问题？"></a>34. 说说webpack中常见的Plugin？解决了什么问题？</h4><p>plugin是插件，对于webpack本身的扩展，是一个扩展器。</p>
<p>配置方式：写在plugins属性中传入new实例对象，他是个数组，可以写多个插件。</p>
<p>下面介绍几个常用的插件用法：</p>
<ul>
<li>HtmlWebpackPlugin<ul>
<li>⾃动生成⼀个 <code>html</code> ⽂文件，并把打包生成的<code>js</code> 模块引⼊到该 <code>html</code> 中</li>
</ul>
</li>
<li>clean-webpack-plugin<ul>
<li>删除（清理）构建目录</li>
</ul>
</li>
<li>mini-css-extract-plugin<ul>
<li>提取css到一个单独文件中</li>
</ul>
</li>
<li>copy-webpack-plugin<ul>
<li>复制文件或目录到执行区域。</li>
</ul>
</li>
</ul>
<h4 id="35-说说你对promise的了解"><a href="#35-说说你对promise的了解" class="headerlink" title="35. 说说你对promise的了解"></a>35. 说说你对promise的了解</h4><p>promise是es6新增的语法，解决了回调地狱的问题。（ 多个异步任务顺序执行，形成的多层回调函数的嵌套结构，就称为回调地狱现象 ）。</p>
<p>promise有三个状态：pending等待初始化状态，resolved成功的状态，rejected成功的状态。变化不可逆。</p>
<p>promise构造函数内代码是同步的，而之后then和catch执行的是异步的。构造函数接收两个参数resolve和reject。他们的执行是传递给then，catch，表示成功的回调及失败的回调。</p>
<h4 id="36-async函数是什么，有什么作用"><a href="#36-async函数是什么，有什么作用" class="headerlink" title="36. async函数是什么，有什么作用"></a>36. async函数是什么，有什么作用</h4><p>async&#x2F;await 是为了简化使用基于promiseAPI的一种语法（语法糖）。async和await简化了promise的异步行为，不用链式的调用promise。</p>
<p>async表示是异步操作，await表示跟在表达式后面等待结果。await只能在async函数中有效，不然会报错。async返回一个promise对象，可以使用then方法添加回调函数。不管是不是promise对象，都会被包装成promise对象。async函数内部会被await阻塞并按顺序执行代码。也可使用try..catch进行异常处理。</p>
<h4 id="37-有使用过vue吗？说说你对vue的理解"><a href="#37-有使用过vue吗？说说你对vue的理解" class="headerlink" title="37. 有使用过vue吗？说说你对vue的理解"></a>37. 有使用过vue吗？说说你对vue的理解</h4><p>vue是一个构建用户界面的渐进式框架。vue所关注的核心是视图层。有一套精简的mvvm框架。</p>
<p>vue是一款轻量级别的框架，适合开发小型项目。</p>
<p>vue核心特性：</p>
<ul>
<li>数据驱动（MVVM  Model-View-ViewModel）<ul>
<li>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</li>
<li>View：视图层：负责将数据渲染出来展示页面，可以简单的理解为HTML页面</li>
<li>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁。</li>
</ul>
</li>
<li>组件化开发<ul>
<li>组件可以重复使用。提高开发效率。高内聚低耦合。</li>
<li>提高可维护性，每个组件的职责单一 。</li>
</ul>
</li>
<li>有着一套丰富的vue指令<ul>
<li>条件渲染指令 <code>v-if</code></li>
<li>列表渲染指令<code>v-for</code></li>
<li>属性绑定指令<code>v-bind</code></li>
<li>事件绑定指令<code>v-on</code></li>
<li>双向数据绑定指令<code>v-model</code></li>
</ul>
</li>
</ul>
<h4 id="38-你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"><a href="#38-你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢" class="headerlink" title="38. 你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢"></a>38. 你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢</h4><p>SPA仅在Web页面初始化时加载相应的HTML、JavaScript和CSS。一旦页面加载完成,SPA不会因为用户操作而进行页面的重新加载或跳转;取而代之的是利用JavaScript实现HTML内容变换,UI与用户的交互,避免页面的重新加载。</p>
<p>优点：</p>
<ul>
<li>用户体验好、快，内容的改变不需要重新加载整个页面</li>
<li>SPA相对于服务器压力小;</li>
<li>良好的前后端分离，分工更明确。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不利于搜索引擎的抓取</li>
<li>首次加载页面速度比较慢</li>
</ul>
<p>实现：</p>
<ul>
<li>hash模式<ul>
<li>通过onhashchange监听路由的改变，从而跳转路由更新页面。</li>
</ul>
</li>
<li>history模式<ul>
<li>history采用HTML5的新特性；pushState()添加历史记录，replaceState()修改浏览器历史记录。</li>
<li>通过popState()监听路由的改变，从而触发路由跳转和页面更新。</li>
</ul>
</li>
</ul>
<h4 id="39-SPA首屏加载速度慢的怎么解决？"><a href="#39-SPA首屏加载速度慢的怎么解决？" class="headerlink" title="39. SPA首屏加载速度慢的怎么解决？"></a>39. SPA首屏加载速度慢的怎么解决？</h4><ul>
<li>减小入口文件积<ul>
<li>路由懒加载，不同组件的分割。</li>
</ul>
</li>
<li>静态资源本地缓存</li>
<li>UI框架按需加载</li>
<li>开启GZip压缩</li>
<li>使用服务器端渲染SSR（nuxt.js）</li>
<li>图片资源的压缩</li>
</ul>
<h4 id="40-VUE路由的原理"><a href="#40-VUE路由的原理" class="headerlink" title="40. VUE路由的原理"></a>40. VUE路由的原理</h4><p>hash：</p>
<ul>
<li>其中对象中的location.hash储存的是路由的地址、可以赋值改变其URL的地址。而这会触发hashchange事件，而通过window.addEventListener监听hash值然后去匹配对应的路由、从而渲染页面的组件 。</li>
</ul>
<p>history：</p>
<ul>
<li>history采用HTML5的新特性，通过 pushState 和 replaceState 两个方法来实现 URL 的变化</li>
<li>可以通过 popstate 事件来监听 URL 的变化，从而对页面进行跳转（渲染）</li>
</ul>
<h4 id="41-Vue中组件和插件有什么区别？"><a href="#41-Vue中组件和插件有什么区别？" class="headerlink" title="41. Vue中组件和插件有什么区别？"></a>41. Vue中组件和插件有什么区别？</h4><p>组件 <code>(Component)</code> 是用来构成 <code>App</code> 的业务模块，它的目标是 <code>App.vue</code>。 在<code>Vue</code>中每一个<code>.vue</code>文件都可以视为一个组件</p>
<p>插件就是指对<code>Vue</code>的功能的增强或补充。</p>
<p>编写形式区别：</p>
<ul>
<li>组件是以.vue后缀结尾的组件，包含三部分。template，script，style。</li>
<li>插件需要暴露一个install方法，第一个参数是vue构造器，第二个参数是可选对象。</li>
</ul>
<p>注册形式区别：</p>
<ul>
<li>组件是在main.js中全局注册vue.component(),局部注册就是在组件内。</li>
<li>插件在main.js中使用vue实例vue.use（插件名）</li>
</ul>
<h4 id="42-Vue组件之间的通信方式都有哪些"><a href="#42-Vue组件之间的通信方式都有哪些" class="headerlink" title="42. Vue组件之间的通信方式都有哪些"></a>42. Vue组件之间的通信方式都有哪些</h4><ul>
<li>父子组件之间的通信<ul>
<li>使用props进行传递</li>
</ul>
</li>
<li>兄弟组件之间的通信<ul>
<li>使用eventbus vue实例进行传递</li>
</ul>
</li>
<li>provide 和 inject<ul>
<li>在祖先组件定义<code>provide</code>属性，返回传递的值</li>
<li>在后代组件通过<code>inject</code>接收组件传递过来的值</li>
</ul>
</li>
<li>vuex</li>
</ul>
<h4 id="43-你了解vue的diff算法吗"><a href="#43-你了解vue的diff算法吗" class="headerlink" title="43. 你了解vue的diff算法吗"></a>43. 你了解vue的diff算法吗</h4><p>diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁 。</p>
<p>原理：当数据发生改变时，<code>set</code>方法会调用<code>Dep.notify</code>通知所有订阅者<code>Watcher</code>，调用<code>patch</code>给真实的<code>DOM</code>打补丁，更新相应的视图 。</p>
<p>其有两个特点：</p>
<ul>
<li>比较只会在同层级进行, 不会跨层级比较</li>
<li>在diff比较的过程中，循环从两边向中间比较</li>
<li>同一个节点，进行最小量的更新。</li>
</ul>
<p>diff 算法的在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较</p>
<p>Diff算法的步骤：</p>
<ul>
<li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文 档当中。</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较(diff)，记录两棵树差异。</li>
<li>把第二棵树所记录的差异应用到第一棵树所构建的真正的DOM树上(patch)，视图就更新了。</li>
</ul>
<h4 id="44-为什么需要-Virtual-Dom"><a href="#44-为什么需要-Virtual-Dom" class="headerlink" title="44. 为什么需要 Virtual Dom"></a>44. 为什么需要 Virtual Dom</h4><ul>
<li>DOM的操作本身是性能会出现问题，操作比较复杂的</li>
<li>MVVM框架解决视图和状态同步问题</li>
<li>模板引擎可以简化视图操作，没办法跟踪状态（无法得知当前页面变化之前的状态）</li>
<li>虚拟DOM能够跟踪状态变化</li>
<li>虚拟DOM可以维护程序的状态，跟踪上一次的状态，通过比较前后两次状态差异更新真实DOM</li>
</ul>
<p><strong>虚拟 DOM 的作用</strong></p>
<ul>
<li>维护视图和状态的关系</li>
<li>复杂视图情况下提升渲染性能</li>
<li>除了渲染 <code>DOM</code> 以外，还可以实现 <code>SSR(Nuxt.js/Next.js)</code>、原生应用(<code>Weex/React Native</code>)、小程序(<code>mpvue/uni-app</code>)等</li>
</ul>
<h4 id="45-Vue3-0的设计目标是什么？做了哪些优化"><a href="#45-Vue3-0的设计目标是什么？做了哪些优化" class="headerlink" title="45. Vue3.0的设计目标是什么？做了哪些优化"></a>45. Vue3.0的设计目标是什么？做了哪些优化</h4><p>设计目标：</p>
<ul>
<li>打包体积更小： <code>Vue3</code>移除一些不常用的 <code>API</code> ， 将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了</li>
<li>速度更快： diff算法优化，静态提升。</li>
<li>更灵活的代码组织能力：推出Composition API，大大增加了代码的逻辑组织能力和代码复用能力。</li>
</ul>
<p>优化方案：</p>
<ul>
<li>源码<ul>
<li>使用ts语法，源码的优化。</li>
</ul>
</li>
<li>性能<ul>
<li>体积，编译，数据劫持优化。</li>
</ul>
</li>
<li>语法 API<ul>
<li>组合式API，根据相关逻辑组织代码。</li>
</ul>
</li>
</ul>
<h4 id="46-Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#46-Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="46. Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>46. Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h4><ul>
<li>Options：</li>
</ul>
<p> 在一个vue文件中的data，methods，computed…定义属性和方法，共同处理页面逻辑。</p>
<p> 缺点：一个功能的实现 需要不同的vue配置项，定义属性方法比较分散。大项目methods可能 包含多个方法，这可能会导致组件难以阅读和理解。</p>
<p> 优点：新手入门会比较简单。</p>
<ul>
<li><p>Compositions API:</p>
<p> 一个功能的所有api会放在一起（高内聚，低耦合），方便找到功能所对应的方法及属性。</p>
<p> 缺点：学习思维方式改变。</p>
<p> 优点：根据逻辑相关性组织代码，提高可读性和可维护性，基于函数组合的API。</p>
</li>
</ul>
<h4 id="47-说一下Vue数据响应式的原理"><a href="#47-说一下Vue数据响应式的原理" class="headerlink" title="47. 说一下Vue数据响应式的原理"></a>47. 说一下Vue数据响应式的原理</h4><p>当一个vue实例被创建时，vue会遍历data选项的属性。采用数据劫持结合发布&#x2F;订阅者模式，用es5的object.defindproerty将他们转化为getter&#x2F;setter，并在内部追踪相关依赖。在属性被访问和修改时通知变化。也就是observer使用object.defindproerty来监听数据的读写。读取数据时，调用get方法通知dep收集订阅者（watcher）。添加到dep的一个属性subs数组里。 修改数据时，调用set方法，通知dep数据改变了。 使用notify方法遍历subs里面的watcher，调用watcher的update（）方法。创建出一个新的dom树与原本旧的dom树做对比，从而更新视图。</p>
<h4 id="48-说说对-React-的理解？有哪些特性？"><a href="#48-说说对-React-的理解？有哪些特性？" class="headerlink" title="48. 说说对 React 的理解？有哪些特性？"></a>48. 说说对 React 的理解？有哪些特性？</h4><p>由FaceBook在2011年开发的。React用于构建用户界面的 JavaScript 库 ，声明式编程，组件化开发。</p>
<ol>
<li>它使用<strong>虚拟DOM</strong>而不是真正的DOM。</li>
<li>它可以用<strong>服务器端渲染</strong>。</li>
<li>它遵循<strong>单向数据流</strong>或数据绑定。</li>
<li>使用jsx语法，将html和css代码写入到一个js文件。</li>
</ol>
<h4 id="49-说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？"><a href="#49-说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？" class="headerlink" title="49. 说说 Real DOM 和 Virtual DOM 的区别？优缺点？"></a>49. 说说 Real DOM 和 Virtual DOM 的区别？优缺点？</h4><p>Real DOM（真实的dom），在页面渲染出的每个节点都是一个真实的DOM结构 。</p>
<p>Virtual DOM （虚拟dom），是一个轻量级的js对象，它最初只是real DOM的副本，也是一个节点树。将属性和内容作为该对象的属性。</p>
<p>区别：</p>
<ul>
<li>虚拟dom会减少重绘和回流，而真实dom会频繁进行重绘和回流。</li>
<li>虚拟dom的总损耗是”虚拟dom的增删改+真实dom的<strong>差异</strong>增删改+重排“；真实dom的消耗是”真实dom全部增删改+重排“</li>
</ul>
<p>真实dom： 优点：直接操作html，易用。 缺点：解析速度慢，效率低，内存占用高， 频繁操作真实 DOM，导致重绘、 回流</p>
<p>虚拟dom： 优点：减少真实dom的频繁更新，减少重绘，回流，占内存少。 跨平台：一套react代码可以多 端运行</p>
<p> 缺点：初次渲染时，多了一层虚拟dom计算，速度慢些。</p>
<h4 id="50-说说-React-生命周期有哪些不同阶段？每个阶段对应的方法是？"><a href="#50-说说-React-生命周期有哪些不同阶段？每个阶段对应的方法是？" class="headerlink" title="50. 说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？"></a>50. 说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？</h4><p><code>React</code>生命周期就是从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等这一过程 。</p>
<ul>
<li>创建阶段<ul>
<li>render 用于渲染<code>DOM</code>结构，可以访问组件<code>state</code>与<code>prop</code>属性</li>
<li>componentDidMount 组件挂载到真实<code>DOM</code>节点后执行，其在<code>render</code>方法之后执行</li>
<li>constructor 初始化<code>state</code>状态</li>
</ul>
</li>
<li>更新阶段<ul>
<li>componentDidUpdate 组件更新结束后触发</li>
<li>shouldComponentUpdate 告诉组件本身是否需要重新渲染，默认false。</li>
<li>render 用于渲染<code>DOM</code>结构</li>
</ul>
</li>
<li>卸载阶段<ul>
<li><strong>componentWillUnmount()</strong> – 从 DOM 卸载组件前调用。</li>
</ul>
</li>
</ul>
<h4 id="51-说说-React中的setState执行机制"><a href="#51-说说-React中的setState执行机制" class="headerlink" title="51. 说说 React中的setState执行机制"></a>51. 说说 React中的setState执行机制</h4><p>当需要修改状态时通过调用<code>setState</code>来改变，从而达到更新组件内部数据的作用 。</p>
<p>当使用setState（）更新状态后，然后会执行render函数，从而导致页面的视图更新。</p>
<p>更新类型：</p>
<ul>
<li>异步更新<ul>
<li>在组件生命周期或React合成事件中，setState是异步</li>
</ul>
</li>
<li>同步更新<ul>
<li>在setTimeout或者原生dom事件中，setState是同步</li>
</ul>
</li>
</ul>
<h4 id="52-说说对React中类组件和函数组件的理解？有什么区别？"><a href="#52-说说对React中类组件和函数组件的理解？有什么区别？" class="headerlink" title="52. 说说对React中类组件和函数组件的理解？有什么区别？"></a>52. 说说对React中类组件和函数组件的理解？有什么区别？</h4><p>类组件：通过使用es6类的编写形式来定义，继承React.Component。如果想要访问父组件传递过来的参数，可通过this.props来拿到。使用render方法，返回一个react对象。</p>
<p>函数组件：通过函数来编写一个react组件，函数第一个参数用于接收父组件传过来的参数。</p>
<p>在hooks出来之前，函数式组件时没有生命周期的，以及无法定义状态。现在可以使用useState定义状态。</p>
<p>useEffect定义生命周期。类式组件是不能使用hooks的。</p>
<h4 id="53-说说对React-Hooks的理解？解决了什么问题？"><a href="#53-说说对React-Hooks的理解？解决了什么问题？" class="headerlink" title="53. 说说对React Hooks的理解？解决了什么问题？"></a>53. 说说对React Hooks的理解？解决了什么问题？</h4><p>hooks是react 16版本以后新增的特性，可以在不写class组件的情况下使用state及其他属性。</p>
<p>useState（）定义组件状态 useEffect（）定义组件生命周期，第一个参数相当于 componentDidMount 和 componentDidUpdate 。第二个参数是个列表。可以返回一个函数，相当于 componentwillUnmount 销毁生命周期。 useReducer，useRef。</p>
<p>解决：</p>
<ul>
<li>每调用useHook一次都会生成一份独立的状态</li>
<li>通过自定义hook能够更好的封装我们的功能</li>
</ul>
<p>hook的出现，使函数式组件拥有了类式组件的相似功能。还可以进行代码复用。</p>
<h4 id="54-说说你对Redux的理解？其工作原理？"><a href="#54-说说你对Redux的理解？其工作原理？" class="headerlink" title="54. 说说你对Redux的理解？其工作原理？"></a>54. 说说你对Redux的理解？其工作原理？</h4><p>redux与vux相似，也是将组件状态进行集中管理。相当于管理组件状态的一个工具。</p>
<p><strong>Redux三大原则</strong> ：</p>
<ul>
<li>单一数据源</li>
<li>state是只读的</li>
<li>使用纯函数修改状态</li>
</ul>
<p><strong>redux三大核心</strong>：</p>
<ul>
<li>action： 动作对象，两个参数type，和data</li>
<li>reducer： 用于初始化状态，加工状态</li>
<li>store</li>
</ul>
<p>原理： 页面需要获取数据时，通过Action creates创建一个action动作对象，提交dispatch请求给store。store通知reducer进行匹配action的属性type。从而进行返回一个新的对象。</p>
<h4 id="55-说说-React-性能优化的手段有哪些"><a href="#55-说说-React-性能优化的手段有哪些" class="headerlink" title="55. 说说 React 性能优化的手段有哪些"></a>55. 说说 React 性能优化的手段有哪些</h4><ul>
<li>为避免不必要的render渲染，可以使用shouldComponentUpdate。</li>
<li>避免使用内联函数</li>
<li>懒加载组件</li>
<li>服务端渲染</li>
<li>事件绑定方式</li>
<li>列表渲染的时候加key</li>
<li>避免使用内联样式属性</li>
</ul>
<h4 id="56-vue、react、angular-区别"><a href="#56-vue、react、angular-区别" class="headerlink" title="56. vue、react、angular 区别"></a>56. vue、react、angular 区别</h4><ul>
<li>angular是基于MVC架构，vue和react都是基于虚拟dom。</li>
<li><strong>Angular</strong>使用的是双向数据绑定，<strong>React</strong>用的是单数据流的，而<strong>Vue</strong>则支持两者。</li>
<li>vue与angular自带的渲染指令不同。react没有渲染指令。</li>
<li>react使用jsx语法，angular使用ts语法。</li>
</ul>
<h4 id="57-说说你对-TypeScript-的理解？与-JavaScript-的区别"><a href="#57-说说你对-TypeScript-的理解？与-JavaScript-的区别" class="headerlink" title="57. 说说你对 TypeScript 的理解？与 JavaScript 的区别"></a>57. 说说你对 TypeScript 的理解？与 JavaScript 的区别</h4><p>typescript是一个强类型的JavaScript超集， 支持面向对象编程的概念，如类、接口、继承、泛型等 ，可编译为纯JavaScript 。typescrit可以在任何浏览器运行。但是不能直接运行，需要一个编译器编译成javascript文件。</p>
<p>区别：</p>
<ul>
<li>ts支持es6语法，js不支持es6。</li>
<li>ts支持模块，js不支持模块。</li>
<li>js中没有静态类型的概念。</li>
<li>TypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js</li>
</ul>
<h4 id="58-说说你对-TypeScript-中泛型的理解？应用场景？"><a href="#58-说说你对-TypeScript-中泛型的理解？应用场景？" class="headerlink" title="58. 说说你对 TypeScript 中泛型的理解？应用场景？"></a>58. 说说你对 TypeScript 中泛型的理解？应用场景？</h4><p>泛型是设计语言的一种风格或规范。</p>
<p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性 。</p>
<p>泛型通过<code>&lt;&gt;</code>的形式进行表述，可以声明 ：函数，类，接口。</p>
<h4 id="59-说说你对微信小程序的理解？优缺点？"><a href="#59-说说你对微信小程序的理解？优缺点？" class="headerlink" title="59. 说说你对微信小程序的理解？优缺点？"></a>59. 说说你对微信小程序的理解？优缺点？</h4><p>小程序是一种不需要下载安装即可使用的应用，用户扫一扫或者搜一下即可打开应用。</p>
<p>也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。</p>
<p>注意的是，除了微信小程序，还有百度小程序、支付宝小程序、抖音小程序，都是每个平台自己开发的，都是有针对性平台的应用程序。</p>
<p>优点：</p>
<ul>
<li>随搜随用，用完即走：使得小程序可以代替许多APP，或是做APP的整体嫁接，或是作为阉割版功能的承载体</li>
<li>流量大，易接受：小程序借助自身平台更加容易引入更多的流量</li>
<li>安全</li>
<li>开发门槛低</li>
<li>降低兼容性限制</li>
</ul>
<p>缺点：</p>
<ul>
<li>用户留存：及相关数据显示，小程序的平均次日留存在13%左右，但是双周留存骤降到仅有1%</li>
<li>体积限制：微信小程序只有2M的大小，这样导致无法开发大型一些的小程序</li>
<li>受控微信：比起APP，尤其是安卓版的高自由度，小程序要面对很多来自微信的限制，从功能接口，甚至到类别内容，都要接受微信的管控</li>
</ul>
<h4 id="60-说说你对发布订阅、观察者模式的理解？区别？"><a href="#60-说说你对发布订阅、观察者模式的理解？区别？" class="headerlink" title="60. 说说你对发布订阅、观察者模式的理解？区别？"></a>60. 说说你对发布订阅、观察者模式的理解？区别？</h4><ul>
<li>发布订阅模式三个角色：订阅者，发布者。信号中心。<ul>
<li>我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”(publish)一个信 号，其他任务可以向信号中心”订阅”(subscribe)这个信号，从而知道什么时候自己可以开始执 行。这就叫做”发布&#x2F;订阅模式”</li>
<li>例子： Vue 的自定义事件 ， 兄弟组件通信， 模拟 Vue 自定义事件的实现</li>
</ul>
</li>
<li>观察者模式三个角色：<ul>
<li>观察者(订阅者)–Watcher<ul>
<li><code>update()</code>:当事件发生时，具体要做的事情</li>
</ul>
</li>
<li>目标(发布者) –Dep<ul>
<li><code>subs</code> 数组:存储所有的观察者</li>
<li><code>addSub()</code>:添加观察者</li>
<li><code>notify()</code>:当事件发生，调用所有观察者的 <code>update()</code> 方法</li>
</ul>
</li>
<li>没有事件中心</li>
</ul>
</li>
</ul>
<p><strong>发布&#x2F;订阅模式</strong>由统一信号中心调用，因此发布者和订阅者不需要知道对方的存在</p>
<p><strong>观察者模式</strong>是由具体目标调动，比如当事件触发，<code>Dep</code> 就会去调用观察者的方法，所以观察者模 式的订阅者与发布者之间是存在依赖的</p>
<h4 id="61-项目做过哪些性能优化"><a href="#61-项目做过哪些性能优化" class="headerlink" title="61. 项目做过哪些性能优化"></a>61. 项目做过哪些性能优化</h4><ul>
<li>减少 <code>HTTP</code> 请求数</li>
<li>减少<code>DOM</code> 操作</li>
<li>压缩css，js，图片等</li>
<li>在外部使用js和css</li>
<li>路由懒加载，图片懒加载</li>
<li>减少重绘，和回流。</li>
<li>ui框架按需加载</li>
<li>减少 <code>DNS</code> 查询</li>
<li>使用 <code>CDN</code></li>
<li>避免重定向</li>
<li>减少 <code>DOM</code> 元素数量</li>
<li>优化 <code>CSS Sprite</code></li>
<li>使用 <code>iconfont</code></li>
<li>字体裁剪</li>
<li>多域名分发划分内容到不同域名</li>
<li>尽量减少 <code>iframe</code> 使用</li>
<li>避免图片 <code>src</code> 为空</li>
<li>把样式表放在<code>link</code> 中</li>
<li>把<code>JavaScript</code>放在页面底部</li>
</ul>
<h4 id="62-描述浏览器的渲染过程，DOM树和渲染树的区别"><a href="#62-描述浏览器的渲染过程，DOM树和渲染树的区别" class="headerlink" title="62. 描述浏览器的渲染过程，DOM树和渲染树的区别"></a>62. 描述浏览器的渲染过程，DOM树和渲染树的区别</h4><ul>
<li>浏览器的渲染过程：<ul>
<li>解析<code>HTML</code>构建 <code>DOM</code>(DOM树)，并请求 <code>css/image/js</code></li>
<li><code>CSS</code> 文件下载完成，开始构建 <code>CSSDOM</code>(<code>CSS</code>树)</li>
<li>css树构建结束后，和 <code>DOM</code> 一起生成 <code>Render Tree</code>(渲染树)</li>
<li>布局：计算出每个节点在屏幕中的位置</li>
<li>显示：通过显卡把页面画到屏幕上</li>
</ul>
</li>
<li>DOM树 和 渲染树 的区别：<ul>
<li><code>DOM</code>树与<code>HTML</code>标签一一对应，包括<code>head</code>和隐藏元素</li>
<li>渲染树不包括<code>head</code>和隐藏元素，大段文本每一行都是独立节点，每一个节点都有对应的<code>css</code>属性。</li>
</ul>
</li>
</ul>
<h4 id="63-你认为什么样的前端代码是好的"><a href="#63-你认为什么样的前端代码是好的" class="headerlink" title="63. 你认为什么样的前端代码是好的"></a>63. 你认为什么样的前端代码是好的</h4><p>完成一个项目操作尽量是低代码，代码是高内聚，低耦合的。</p>
<p>代码维护性比较高，而且容易扩展的。遵循代码的规范。</p>
<p><code>高内聚：</code>内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事，它描述的是模块内的功能联系。<br><code>低耦合：</code>耦合是软件结构中各模块之间相互连接的一种 度量 ，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</p>
<h4 id="64-从浏览器地址栏输入url到显示页面的步骤"><a href="#64-从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="64. 从浏览器地址栏输入url到显示页面的步骤"></a>64. 从浏览器地址栏输入url到显示页面的步骤</h4><p>1，URL解析 ：判断url格式是否正确</p>
<p>2，DNS域名查询 ：获取域名对应的服务器IP地址</p>
<p>3，建立TCP连接： 三次握手建立TCP连接</p>
<p>4，发起http请求: 浏览器发送请求到目标服务器，进行逻辑操作</p>
<p>5，响应请求和页面渲染：服务器返回一个响应请求，响应完，当页面关闭，tcp经过四次挥手断开连接</p>
<p>6 ，页面渲染：浏览器拿到服务器响应返回的资源，解析 先对资源进行解析，比如重定向 储存cookie、解压gzip等</p>
<p>7，解析html，构建dom树。</p>
<p>8，解析css 生成css规则树。</p>
<p>9，合并dom树，生成rander树</p>
<p>10，布局rander树，绘制rander树，绘制页面像素信息</p>
<p>11最后，浏览器把信息给gpu将各层信息合并，显示到屏幕上；</p>
<h4 id="65-http-请求报文和响应报文的格式"><a href="#65-http-请求报文和响应报文的格式" class="headerlink" title="65. http 请求报文和响应报文的格式"></a>65. http 请求报文和响应报文的格式</h4><ul>
<li><p>向后端服务器发出一个web资源请求，称之为客户端向服务器端发出了一个http请求。</p>
<p>HTTP请求报文主要由请求行、请求头、请求正文3部分组成 。</p>
</li>
<li><p>响应就是后端服务器对该请求做了个处理，返回一些数据等等。</p>
<p>HTTP响应报文主要由响应行、响应头、响应正文3部分组成。</p>
</li>
</ul>
<h4 id="66-Token-cookie-session-区别"><a href="#66-Token-cookie-session-区别" class="headerlink" title="66. Token cookie session 区别"></a>66. Token cookie session 区别</h4><p><strong>Session</strong>会话：客户端A访问服务器，服务器存储A的数据value，把key返回给客户端A，客户端A下次带着key（<a href="https://so.csdn.net/so/search?q=session&spm=1001.2101.3001.7020">session</a> ID）来访问服务器，服务器就能给出客户端A的数据。</p>
<p><strong>Cookie</strong>：客户端A访问服务器，服务器返回cookie给客户端A，客户端A存储cookie，下次需要带着cookie访问服务器，服务器返回相应的数据。</p>
<p><strong>Token</strong>令牌：客户端A访问服务器，服务器给了客户端token，客户端A拿着token访问服务器，服务器验证token，返回数据。</p>
<ul>
<li><code>cookie</code> 数据存放在浏览器上，session 数据存放在服务器上</li>
<li><code>cookie</code> 不是很安全，别人可以分析存放在本地的cookie 并进行 cookie 欺骗 考虑到安全应当使用 session</li>
<li><code>session</code> 会在一定时间内保存在服务器上。当访问增多，服务器性能会变差，这时应当使用cookie。</li>
<li>单个 <code>cookie</code> 保存的数据不能超过 <code>4K</code>，很多浏览器都限制一个站点最多保存 20 个 <code>cookie</code>。session是根据服务器大小来定。</li>
</ul>
<p>token：</p>
<p>token是服务器生成的一串字符串，作为客户端进行请求的一个令牌。</p>
<p>token比较安全，cookie容易伪造，但是token不容易伪造，盗取。</p>
<h4 id="67-CORS跨域的原理"><a href="#67-CORS跨域的原理" class="headerlink" title="67. CORS跨域的原理"></a>67. CORS跨域的原理</h4><ul>
<li>当我们发起跨域请求时，如果是非简单请求，浏览器会帮我们自动触发预检请求，也就是 options请求，用于确认目标资源是否支持跨域。如果是简单请求，则不会触发预检，直接发出正常请求。</li>
<li>浏览器会根据服务端响应的 header 自动处理剩余的请求，如果响应支持跨域，则继续发出正常请求，如果不支持，则在控制台显示错误。</li>
</ul>
<h4 id="68-什么是MVVM"><a href="#68-什么是MVVM" class="headerlink" title="68. 什么是MVVM"></a>68. 什么是MVVM</h4><p>mvvm就是modle –view –viewmodle。mvvm是一种设计思想 。</p>
<p>modle：模型层，用于处理逻辑和服务器的交互。</p>
<p>view：视图层，用于将数据渲染在页面上。UI视图。</p>
<p>view-modle：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁。达到数据驱动视图的效果。</p>
<p>MVVM模式简化了界面与业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。</p>
<h4 id="69-说说你对版本管理的理解？常用的版本管理工具有哪些？"><a href="#69-说说你对版本管理的理解？常用的版本管理工具有哪些？" class="headerlink" title="69. 说说你对版本管理的理解？常用的版本管理工具有哪些？"></a>69. 说说你对版本管理的理解？常用的版本管理工具有哪些？</h4><p>简单来说： 你的修改只要提到到版本控制系统，基本都可以找回，版本控制系统就像一台时光机器，可以让你回到任何一个时间点 。</p>
<p>三个分类：</p>
<ul>
<li>本地版本控制系统</li>
<li>集中式版本控制系统 优点：适合多人团队协作开发，代码集中管理。 缺点：必须联网，无法单机工作。<ul>
<li>SVN</li>
<li>CVS</li>
</ul>
</li>
<li>分布式版本控制系统 优点：适合多人团队协作开发，代码集中管理。可离线工作。<ul>
<li>Git 一般公司都是使用git和gitlab自己搭建版本控制环境。比较安全。</li>
<li>HG</li>
</ul>
</li>
</ul>
<h4 id="70-说说你对Git的理解？"><a href="#70-说说你对Git的理解？" class="headerlink" title="70. 说说你对Git的理解？"></a>70. 说说你对Git的理解？</h4><p>git是目前世界上最先进的分布式版本控制系统，快速高效的处理小型到大型项目的事务。</p>
<p>当我们通过<code>git init</code>创建或者<code>git clone</code>一个项目的时候，项目目录会隐藏一个<code>.git</code>子目录，其作用是用来跟踪管理版本库的 。</p>
<p>特性：易于学习，占用内存小，具有闪电般快速的性能。</p>
<p>使用<code>Git</code>和<code>Gitlab</code>搭建版本控制环境是现在互联网公司最流行的版本控制方式。</p>
<h4 id="71-说说Git常用的命令有哪些"><a href="#71-说说Git常用的命令有哪些" class="headerlink" title="71. 说说Git常用的命令有哪些"></a>71. 说说Git常用的命令有哪些</h4><ul>
<li>git add . ：提交暂存区</li>
<li>git status： 查看当前分支状态</li>
<li>git commit -m ‘’ ：提交本地库</li>
<li>git pull 更新或合并</li>
<li>git push -u origin master 提交到远程仓库</li>
</ul>
<h4 id="72-说说-git-发生冲突的场景？如何解决？"><a href="#72-说说-git-发生冲突的场景？如何解决？" class="headerlink" title="72. 说说 git 发生冲突的场景？如何解决？"></a>72. 说说 git 发生冲突的场景？如何解决？</h4><p>多个分支修改了同一个文件，比如在项目开发中，需要写组件了。要注册路由，然后你增加了几个路由。在你提交前，已经有人提交了并且已经修改了路由文件。这时你提交就会冲突。</p>
<p>首先将修改过的文件add 提到暂存区，commit 提交本地库，git pull 更新合并代码。然后根据提示手动去解决冲突。</p>
<h4 id="73-loader和plugin的区别"><a href="#73-loader和plugin的区别" class="headerlink" title="73. loader和plugin的区别"></a>73. loader和plugin的区别</h4><p>对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程。<br>plugin是一个插件，在webpack中相当于一个扩展器。是对现有webpack功能的一个扩展。针对于loader结束后，在webpack打包过程中并不是直接进行操作的，而是遵循事件机制工作的。会监听webpack打包过程中的某些节点，执行广泛的任务。</p>
]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端面试</tag>
      </tags>
  </entry>
</search>
